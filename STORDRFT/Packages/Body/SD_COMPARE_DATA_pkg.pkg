create or replace PACKAGE BODY SD_COMPARE_DATA_pkg
/**************************************************************** 
Purpose : Comapre Data Package is Used to get the Difference records and 
           Matching records between two table data.  
Created : 05/19/2016 axd783 CCN Project Team...
Changed :
*****************************************************************/
AS

g_char                  CONSTANT    VARCHAR2(1) := 'X';
g_number                CONSTANT    NUMBER := 9999999999;
g_date                  CONSTANT    DATE := TO_DATE('01-01-1000','MM-DD-YYYY');


FUNCTION VALIDATE_TABLES_fnc(in_TABLE_NAME1 IN VARCHAR2
                            ,in_TABLE_NAME2 IN VARCHAR2
/**************************************************************** 
Purpose : This Function is used to find the tables are Identical or not
          If they are identical then it returns True and if they are not returns False
Created : 05/19/2016 axd783 CCN Project Team...
Changed :
*****************************************************************/
                            ) RETURN BOOLEAN
IS

v_diff_count                        NUMBER;
v_exist_count                       NUMBER;
v_return                            BOOLEAN := FALSE;
table_error_excp                    EXCEPTION;

BEGIN

    -- This will look for, if in_TABLE_NAME1 and in_TABLE_NAME2 tables exist in current schema.
    SELECT COUNT(*) INTO v_exist_count
      FROM USER_TABLES
     WHERE table_name IN (UPPER(in_TABLE_NAME1),UPPER(in_TABLE_NAME2));

    IF v_exist_count != 2 THEN
        RAISE table_error_excp;
    ELSE
        -- This will check, Both tables has same structures which includes Column_id, Column_name,Data_type and Data_length columns
        SELECT COUNT(*) INTO v_diff_count 
          FROM 
            (
             SELECT *
               FROM (
                     SELECT COLUMN_ID
                           ,COLUMN_NAME
                           ,DATA_TYPE
                           ,DATA_LENGTH
                       FROM user_tab_cols
                      WHERE table_name = UPPER(in_TABLE_NAME1)
                      MINUS
                     SELECT COLUMN_ID
                           ,COLUMN_NAME
                           ,DATA_TYPE
                           ,DATA_LENGTH
                       FROM user_tab_cols
                      WHERE table_name = UPPER(in_TABLE_NAME2)
                    ) 
              UNION
             SELECT *
               FROM (
                     SELECT  COLUMN_ID
                            ,COLUMN_NAME
                            ,DATA_TYPE
                            ,DATA_LENGTH
                       FROM user_tab_cols
                      WHERE table_name = UPPER(in_TABLE_NAME2)
                      MINUS
                     SELECT COLUMN_ID
                           ,COLUMN_NAME
                           ,DATA_TYPE
                           ,DATA_LENGTH
                       FROM user_tab_cols
                      WHERE table_name = UPPER(in_TABLE_NAME1)
                    )
             );
         -- Check if the diff_count is '0', if it is '0' that means two input tables structures are similiar
         -- if it is not '0' then two input tables structures are different 
         IF v_diff_count = 0 THEN
            v_return:= TRUE;
        ELSE
            v_return:= FALSE;
        END IF;
    END IF;    
    RETURN v_return;
EXCEPTION
    WHEN table_error_excp THEN
        DBMS_OUTPUT.PUT_LINE('Either one or two given Tables are not Valid');
        ERRPKG.INSERT_ERROR_LOG_SP(SQLCODE
                                  ,'VALIDATE_TABLES_fnc'
                                  ,SQLERRM||'Either one or two given Tables are not Valid'
                                  ,'000000'
                                  ,'0000000000');
        RETURN v_return;
    WHEN OTHERS THEN
        ERRPKG.INSERT_ERROR_LOG_SP(SQLCODE
                                  ,'VALIDATE_TABLES_fnc'
                                  ,SQLERRM
                                  ,'000000'
                                  ,'0000000000');
        RETURN v_return;
END VALIDATE_TABLES_fnc;                             

PROCEDURE DIFF_DATA_sp(in_TABLE_NAME1 IN VARCHAR2
                      ,in_TABLE_NAME2 IN VARCHAR2
                      ,in_file_name IN VARCHAR2
                      ,in_key  IN VARCHAR2 DEFAULT NULL
/**************************************************************** 
Purpose : This will create a Diff .CSV formatted file on the the server 
          Input Parameters:
          in_TABLE_NAME1,in_TABLE_NAME2 : tables to be compared
          in_file_name : Name of the Diff file to be written on server
          in_key : Key columns to compare two tables      
Created : 05/19/2016 axd783 CCN Project Team...
Changed :
*****************************************************************/
)
IS
v_file_path                         VARCHAR2(50);
diff_output_file                    utl_file.file_type;
diff_filename                       VARCHAR2(100); 
v_diff_str                          VARCHAR2(32767) := NULL;
v_t1_select_str                     VARCHAR2(10000) := NULL;
v_t2_select_str                     VARCHAR2(10000) := NULL;
v_nvl_str                           VARCHAR2(10000) := NULL;
v_whr_cond_str                      VARCHAR2(10000) := NULL;
v_join_str                          VARCHAR2(10000) := NULL;
v_null_cond_str                     VARCHAR2(10000) := NULL;
v_ref_cursor                        SYS_REFCURSOR;
v_data                              VARCHAR2(32767);
v_data_rec1                         VARCHAR2(32767);
v_data_rec2                         VARCHAR2(32767);
v_header_rec                        VARCHAR2(32767);
v_count                             NUMBER;
table_structure_excp                EXCEPTION; 

CURSOR cur_tab (in_TABLE_NAME IN VARCHAR2)
IS
    SELECT COLUMN_NAME,DATA_TYPE,COLUMN_ID
      FROM USER_TAB_COLS
     WHERE TABLE_NAME = upper(in_TABLE_NAME)
     ORDER BY COLUMN_ID asc ;

  
BEGIN
     -- Call Validate Function to validate input paramters (in_TABLE_NAME1 and in_TABLE_NAME2) to see if they are having Identical structure 
    IF NOT VALIDATE_TABLES_fnc(in_TABLE_NAME1,in_TABLE_NAME2) THEN
        RAISE table_structure_excp;    
    ELSE
        -- Get_datafile_path_fnc returns the 'STORDRFT' user UTL_FILE path
        v_file_path := ccn_common_tools.get_datafile_path_fnc('STORDRFT');
        -- Output Diff File Name 
        diff_filename:=    UPPER(in_file_name)||'_Diff_File_'||TO_CHAR(SYSDATE,'MMDDYY') ||'.csv';
        diff_output_file := utl_file.fopen ( v_file_path
                                            ,diff_filename 
                                            ,'W' 
                                            ,32767);
        -- This will build the v_t1_select_str,v_t2_select_str and v_header_rec strings 
        -- As we already verified two table structures which includes column names and the column sequence,So here we are looping through
        -- once and building select strings.
        FOR rec1 IN cur_tab( in_TABLE_NAME1)   LOOP
           IF cur_tab%ROWCOUNT = 1   THEN    
              v_header_rec      := rec1.COLUMN_NAME;
              v_t1_select_str   := '''"'''||'|| T1.'||rec1.COLUMN_NAME||'||''"'''|| CHR(10);              
              v_t2_select_str   := '||'',"'''||'|| T2.'||rec1.COLUMN_NAME||'||''"'''|| CHR(10);
          
           ELSE 
            v_header_rec      := v_header_rec||','||rec1.COLUMN_NAME;
            v_t1_select_str   := v_t1_select_str ||'||'',"'''||'|| T1.'||rec1.COLUMN_NAME||'||''"'''|| CHR(10) ;           
            v_t2_select_str   := v_t2_select_str ||'||'',"'''||'|| T2.'||rec1.COLUMN_NAME||'||''"'''|| CHR(10) ; 
           END IF;
            
        END LOOP;
        
        -- This will build the join condition string and null condition string based ont the passed key columns input
        FOR r_key IN (SELECT LEVEL
                            ,trim(regexp_substr(in_key, '[^,]+', 1, LEVEL)) str
                        FROM dual
                     CONNECT BY LEVEL <= regexp_count(in_key, '[^,]+', 1)
                      )LOOP
           IF r_key.level = 1 THEN
              v_join_str := 'T1.'||r_key.str|| ' = ' || 'T2.'||r_key.str;
              v_null_cond_str := 'T1.'||r_key.str||' IS NULL OR'||CHR(10)||'T2.'||r_key.str||' IS NULL OR';
           ELSE 
              v_join_str := v_join_str||CHR(10)||'AND '||'T1.'||r_key.str|| ' = ' || 'T2.'||r_key.str;
              v_null_cond_str := v_null_cond_str||CHR(10)||'T1.'||r_key.str||' IS NULL OR'||CHR(10)||'T2.'||r_key.str||' IS NULL OR';
           END IF; 
        END LOOP;
        
        -- This will built the rest of the where condition string
        -- This also handles Null values comparision by passing default values based on the Data_type
        FOR rec2 IN cur_tab(in_TABLE_NAME1)   LOOP
           IF rec2.DATA_TYPE = 'VARCHAR2' THEN
             v_nvl_str := 'NVL(T1.'||rec2.COLUMN_NAME||','||''''||g_char||''''||') <> NVL(T2.'||rec2.COLUMN_NAME||','||''''||g_char||''''||') OR';   
           ELSIF rec2.DATA_TYPE = 'DATE' THEN
             v_nvl_str := 'NVL(T1.'||rec2.COLUMN_NAME||','||''''||g_date||''''||') <> NVL(T2.'||rec2.COLUMN_NAME||','||''''||g_date||''''||') OR';
           ELSIF rec2.DATA_TYPE = 'NUMBER' THEN
             v_nvl_str :='NVL(T1.'||rec2.COLUMN_NAME||','||''''||g_number||''''||') <> NVL(T2.'||rec2.COLUMN_NAME||','||''''||g_number||''''||') OR'; 
           END IF;        
        
          v_whr_cond_str := v_whr_cond_str||v_nvl_str || CHR(10);     
        END LOOP;        
                
        -- This will remove the ' OR' from the Where condition string
        v_whr_cond_str := SUBSTR(v_whr_cond_str,1,LENGTH(v_whr_cond_str)-3);

        -- This will built the whole Dynamic Diff Select string
        v_diff_str         :=  'SELECT '|| v_t1_select_str || v_t2_select_str || CHR(10) ||
                               '  FROM '|| in_TABLE_NAME1 ||' T1'|| CHR(10) ||
                               '  FULL OUTER JOIN '|| in_TABLE_NAME2 ||' T2'|| CHR(10) || 
                               '    ON ' || v_join_str || CHR(10) ||
                               ' WHERE '|| v_null_cond_str || CHR(10) || v_whr_cond_str || CHR(10) 
                               ;  
        --DBMS_OUTPUT.PUT_LINE(v_diff_str);
        -- This will Appened the IN_TABLE for the v_header_rec string.
        v_header_rec := 'IN_TABLE'||','||v_header_rec;     
        UTL_FILE.PUT_LINE(diff_output_file, v_header_rec, TRUE);
        
        -- Open the ref cursor for the Dynamic Diff Select string
        OPEN  v_ref_cursor FOR v_diff_str;
        LOOP
        FETCH v_ref_cursor INTO v_data;
        EXIT WHEN v_ref_cursor%NOTFOUND;
        
        -- v_count is the count of the ", pattern in the v_data record to cut in to the two records.
        v_count := regexp_count(v_data,'",');
        v_data_rec1 := UPPER(in_TABLE_NAME1)||','||SUBSTR(v_data,1,INSTR(v_data,'",',1,(v_count/2)));
        v_data_rec2 := UPPER(in_TABLE_NAME2)||','||SUBSTR(v_data,INSTR(v_data,'",',1,(v_count/2))+2);

        UTL_FILE.PUT_LINE(diff_output_file, v_data_rec1, TRUE);
        UTL_FILE.PUT_LINE(diff_output_file, v_data_rec2, TRUE);
        END LOOP;
    END IF;

EXCEPTION
    WHEN table_structure_excp THEN
        DBMS_OUTPUT.PUT_LINE('Given table Structures are not Similar');
        ERRPKG.INSERT_ERROR_LOG_SP(SQLCODE
                                  ,'DIFF_DATA_sp'
                                  ,'Given table Structures are not Similar'
                                  ,'000000'
                                  ,'0000000000');
    WHEN OTHERS THEN
        ERRPKG.INSERT_ERROR_LOG_SP(SQLCODE
                                  ,'DIFF_DATA_sp'
                                  ,SQLERRM
                                  ,'000000'
                                  ,'0000000000');
END  DIFF_DATA_sp;  


PROCEDURE MATCH_DATA_sp(in_TABLE_NAME1 IN VARCHAR2
                       ,in_TABLE_NAME2 IN VARCHAR2
                       ,in_file_name IN VARCHAR2
/**************************************************************** 
Purpose : This will create a Diff .CSV formatted file on the the server 
          Input Parameters:
          in_TABLE_NAME1,in_TABLE_NAME2 : tables to be compared
          in_file_name : Name of the Match file to be written on server           
Created : 05/19/2016 axd783 CCN Project Team...
Changed :
*****************************************************************/
)
IS
v_file_path                         VARCHAR2(50);
match_output_file                   utl_file.file_type;
match_filename                      VARCHAR2(100);
v_t1_select_str                     VARCHAR2(10000) := NULL;  
v_t2_select_str                     VARCHAR2(10000) := NULL;
v_header_rec                        VARCHAR2(10000) := NULL;
v_match_str                         VARCHAR2(32767) := NULL;
v_ref_cursor                        SYS_REFCURSOR;
v_data                              VARCHAR2(32767);
v_count                             NUMBER;
table_structure_excp                EXCEPTION; 

CURSOR cur_tab (in_TABLE_NAME IN VARCHAR2)
IS
   SELECT COLUMN_NAME
     FROM USER_TAB_COLUMNS
    WHERE TABLE_NAME = upper(in_TABLE_NAME)
 ORDER BY COLUMN_ID asc ;
     
BEGIN
    -- Call Validate Function to validate input paramters (in_TABLE_NAME1 and in_TABLE_NAME2) to see if they are having Identical structure    
    IF NOT VALIDATE_TABLES_fnc(in_TABLE_NAME1,in_TABLE_NAME2) THEN    
        RAISE table_structure_excp;
    
    ELSE

        v_file_path := ccn_common_tools.get_datafile_path_fnc('STORDRFT');
        -- Output Match File Name 
        match_filename:=    UPPER(in_file_name)||'_Match_File_'||TO_CHAR(SYSDATE,'MMDDYY') ||'.csv';
        match_output_file := utl_file.fopen ( v_file_path
                                             ,match_filename 
                                             ,'W' 
                                             ,32767); 
        -- This will build the select string which includes all the table columns,As we already validated the two tables structures 
        -- which includes column names,So in one loop building two tables select strings including all the columns in tables
        FOR rec1 IN cur_tab( in_TABLE_NAME1)   LOOP
           IF cur_tab%ROWCOUNT = 1   THEN             
              v_t1_select_str   := rec1.COLUMN_NAME;              
              v_t2_select_str   := rec1.COLUMN_NAME;
           ELSE
              v_t1_select_str   := v_t1_select_str ||','||rec1.COLUMN_NAME;           
              v_t2_select_str   := v_t2_select_str ||','||rec1.COLUMN_NAME;
           END IF;    
        END LOOP; 
       -- This will built the whole Dynamic Match Select string
        v_match_str      := 'SELECT '||v_t1_select_str|| CHR(10) ||
                            '  FROM (SELECT COUNT(tab1) AS tab1, COUNT(tab2) AS tab2, '||v_t1_select_str || CHR(10) || 
                            '           FROM (SELECT ' || v_t1_select_str || CHR(10) ||
                            '                           , 1 AS tab1' || CHR(10) ||
                            '                           , TO_NUMBER(NULL) AS tab2' || CHR(10) ||  -- To_number as this is there to match the data type with below select column
                            '                   FROM '|| in_TABLE_NAME1 || CHR(10) ||
                            '                 UNION ALL' || CHR(10) ||
                            '                 SELECT '|| v_t2_select_str || CHR(10) ||
                            '                          , TO_NUMBER(NULL) AS tab1' || CHR(10) ||   -- To_number as this is there to match the data type with above select column
                            '                          , 2 AS tab2 '|| CHR(10) ||
                            '                   FROM '|| in_TABLE_NAME2 || CHR(10) || 
                            '         GROUP BY '|| v_t1_select_str || CHR(10) ||      
                            '         HAVING COUNT(tab1)'||' = '|| 'COUNT(tab2)' || CHR(10) ||
                            '         ORDER BY '|| v_t1_select_str ||')'|| CHR(10) 
                            ;

        --DBMS_OUTPUT.PUT_LINE( v_match_str);
        
        -- This will write the header String.
        v_header_rec := v_t1_select_str;
        
        UTL_FILE.PUT_LINE(match_output_file, v_header_rec, TRUE);
        
        -- Open the ref cursor for the Dynamic Match Select string        
        OPEN  v_ref_cursor FOR v_match_str;
        LOOP
        FETCH v_ref_cursor INTO v_data;
        EXIT WHEN v_ref_cursor%NOTFOUND;      
        UTL_FILE.PUT_LINE(match_output_file, v_data, TRUE); 
        END LOOP;    
          
    END IF;

EXCEPTION
    WHEN table_structure_excp THEN   
        DBMS_OUTPUT.PUT_LINE('Given table Structures are not Similar');   
        ERRPKG.INSERT_ERROR_LOG_SP(SQLCODE
                                  ,'MATCH_DATA_sp'
                                  ,'Given table Structures are not Similar'
                                  ,'000000'
                                  ,'0000000000');
    WHEN OTHERS THEN
        ERRPKG.INSERT_ERROR_LOG_SP(SQLCODE
                                  ,'MATCH_DATA_sp'
                                  ,SQLERRM
                                  ,'000000'
                                  ,'0000000000');
END MATCH_DATA_sp;

END SD_COMPARE_DATA_pkg;