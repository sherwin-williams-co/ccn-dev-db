create or replace PACKAGE BODY SD_COMPARE_DATA_pkg
/**************************************************************** 
Purpose : Comapre Data Package is Used to get the Difference records and 
           Matching records between two table data.  
Created : 05/19/2016 axd783 CCN Project Team...
Changed :
*****************************************************************/
AS

g_char                  CONSTANT    VARCHAR2(1) := 'X';
g_number                CONSTANT    NUMBER := 9999999999;
g_date                  CONSTANT    DATE := TO_DATE('01-01-1000','MM-DD-YYYY');


FUNCTION VALIDATE_TABLES_fnc(in_TABLE_NAME1 IN VARCHAR2
                            ,in_TABLE_NAME2 IN VARCHAR2
/**************************************************************** 
Purpose : This Function is used to find the tables are Identical or not
          If they are identical then it returns True and if they are not returns False
Created : 05/19/2016 axd783 CCN Project Team...
Changed :
*****************************************************************/
                            ) RETURN BOOLEAN
IS

v_diff_count                        NUMBER;
v_exist_count                       NUMBER;
v_return                            BOOLEAN;
table_error_excp                    EXCEPTION;

BEGIN

    -- This will look for, if in_TABLE_NAME1 and in_TABLE_NAME2 tables exist in current schema.
    SELECT COUNT(*) INTO v_exist_count
      FROM USER_TABLES
     WHERE table_name IN (UPPER(in_TABLE_NAME1),UPPER(in_TABLE_NAME2));

    IF v_exist_count != 2 THEN
        RAISE table_error_excp;
    ELSE
        -- This will check, Both tables has same structures which includes Column_id, Column_name,Data_type and Data_length columns
        SELECT COUNT(*) INTO v_diff_count 
          FROM 
            (
             SELECT  COLUMN_ID
                    ,COLUMN_NAME
                    ,DATA_TYPE
                    ,DATA_LENGTH
               FROM (
                     SELECT COLUMN_ID
                           ,COLUMN_NAME
                           ,DATA_TYPE
                           ,DATA_LENGTH
                       FROM user_tab_cols
                      WHERE table_name = UPPER(in_TABLE_NAME1)
                      MINUS
                     SELECT COLUMN_ID
                           ,COLUMN_NAME
                           ,DATA_TYPE
                           ,DATA_LENGTH
                       FROM user_tab_cols
                      WHERE table_name = UPPER(in_TABLE_NAME2)
                    ) 
              UNION
             SELECT  COLUMN_ID
                    ,COLUMN_NAME
                    ,DATA_TYPE
                    ,DATA_LENGTH
               FROM (
                     SELECT  COLUMN_ID
                            ,COLUMN_NAME
                            ,DATA_TYPE
                            ,DATA_LENGTH
                       FROM user_tab_cols
                      WHERE table_name = UPPER(in_TABLE_NAME2)
                      MINUS
                     SELECT COLUMN_ID
                           ,COLUMN_NAME
                           ,DATA_TYPE
                           ,DATA_LENGTH
                       FROM user_tab_cols
                      WHERE table_name = UPPER(in_TABLE_NAME1)
                    )
             );
         -- Check if the diff_count is '0', if it is '0' that means two input tables structures are similiar
         -- if it is not '0' then two input tables structures are different 
         IF v_diff_count = 0 THEN
            v_return:= TRUE;
        ELSE
            v_return:= FALSE;
        END IF;
    END IF;    
    RETURN v_return;
EXCEPTION
    WHEN table_error_excp THEN
        DBMS_OUTPUT.PUT_LINE('Either one or two given Tables are not Valid');
        ERRPKG.INSERT_ERROR_LOG_SP(SQLCODE
                                  ,'VALIDATE_TABLES_fnc'
                                  ,'Either one or two given Tables are not Valid'
                                  ,'000000'
                                  ,'0000000000');
        RETURN FALSE;
    WHEN NO_DATA_FOUND THEN
         ERRPKG.INSERT_ERROR_LOG_SP(SQLCODE
                                  ,'VALIDATE_TABLES_fnc'
                                  ,SQLERRM
                                  ,'000000'
                                  ,'0000000000');
          RETURN FALSE;
END VALIDATE_TABLES_fnc;                             

PROCEDURE DIFF_DATA_sp(in_TABLE_NAME1 IN VARCHAR2
                      ,in_TABLE_NAME2 IN VARCHAR2
                      ,in_file_name IN VARCHAR2
                      ,in_key  IN VARCHAR2 DEFAULT NULL
/**************************************************************** 
Purpose : This will create a Diff .CSV formatted file on the the server 
          Input Parameters:
          in_TABLE_NAME1,in_TABLE_NAME2 : tables to be compared
          in_file_name : Name of the Diff file to be written on server
          in_key : Key columns to compare two tables      
Created : 05/19/2016 axd783 CCN Project Team...
Changed :
*****************************************************************/
)
IS
v_file_path                         VARCHAR2(50);
diff_output_file                    utl_file.file_type;
diff_filename                       VARCHAR2(100); 
v_diff_str                          VARCHAR2(10000) := NULL;
v_t1_select_str                     VARCHAR2(10000) := NULL;
v_t2_select_str                     VARCHAR2(10000) := NULL;
v_nvl_str                           VARCHAR2(10000) := NULL;
v_whr_cond_str                      VARCHAR2(10000) := NULL;
v_join_str                          VARCHAR2(10000) := NULL;
v_null_cond_str                     VARCHAR2(10000) := NULL;
v_ref_cursor                        SYS_REFCURSOR;
v_desc                              DBMS_SQL.DESC_TAB;
v_cols                              BINARY_INTEGER;
v_cursor                            BINARY_INTEGER;
v_varchar2                          VARCHAR2(4000);
v_number                            NUMBER;
v_date                              DATE;
v_data                              VARCHAR2(32767);
v_data_rec1                         VARCHAR2(32767);
v_data_rec2                         VARCHAR2(32767);
v_header_rec                        VARCHAR2(32767);
v_count                             NUMBER;
table_structure_excp                EXCEPTION; 

CURSOR cur_tab (in_TABLE_NAME IN VARCHAR2)
IS
    SELECT COLUMN_NAME,DATA_TYPE,COLUMN_ID
      FROM USER_TAB_COLS
     WHERE TABLE_NAME = upper(in_TABLE_NAME)
     ORDER BY COLUMN_ID asc ;

  
BEGIN
     -- Call Validate Function to validate input paramters (in_TABLE_NAME1 and in_TABLE_NAME2) to see if they are having Identical structure 
    IF NOT VALIDATE_TABLES_fnc(in_TABLE_NAME1,in_TABLE_NAME2) THEN
        RAISE table_structure_excp;    
    ELSE
        -- Get_datafile_path_fnc returns the 'STORDRFT' user UTL_FILE path
        v_file_path := ccn_common_tools.get_datafile_path_fnc('STORDRFT');
        -- Output Diff File Name 
        diff_filename:=    UPPER(in_file_name)||'_Diff_File_'||TO_CHAR(SYSDATE,'MMDDYY') ||'.csv';
        diff_output_file := utl_file.fopen ( v_file_path
                                            ,diff_filename 
                                            ,'W' 
                                            ,32767);
        -- This will build the select string which includes all the table columns,As we already validated the two tables structures 
        -- which includes column names and the sequence, So in one loop building two tables select strings including all the columns in tables
        FOR rec1 IN cur_tab( in_TABLE_NAME1)   LOOP
           IF cur_tab%ROWCOUNT = 1   THEN    
              v_t1_select_str   := 'T1.'||rec1.COLUMN_NAME||' '||rec1.COLUMN_NAME||'1'||CHR(10);              
              v_t2_select_str   := 'T2.'||rec1.COLUMN_NAME||' '||rec1.COLUMN_NAME||'2'||CHR(10);
          
           ELSE 
            v_t1_select_str   := v_t1_select_str ||','|| 'T1.'||rec1.COLUMN_NAME||' '||rec1.COLUMN_NAME||'1'||CHR(10) ;           
            v_t2_select_str   := v_t2_select_str ||','|| 'T2.'||rec1.COLUMN_NAME||' '||rec1.COLUMN_NAME||'2'||CHR(10) ; 
           END IF;
            
        END LOOP;
        
        -- This will build the join condition string and null condition string based ont the passed key columns input
        FOR r_key IN (SELECT LEVEL, trim(regexp_substr(in_key, '[^,]+', 1, LEVEL)) str
                      FROM dual
                      CONNECT BY LEVEL <= regexp_count(in_key, '[^,]+', 1)
                      )LOOP
           IF r_key.level = 1 THEN
              v_join_str := 'T1.'||r_key.str|| ' = ' || 'T2.'||r_key.str;
              v_null_cond_str := 'T1.'||r_key.str||' IS NULL OR'||CHR(10)||'T2.'||r_key.str||' IS NULL OR';
           ELSE 
              v_join_str := v_join_str||CHR(10)||'AND '||'T1.'||r_key.str|| ' = ' || 'T2.'||r_key.str;
              v_null_cond_str := v_null_cond_str||CHR(10)||'T1.'||r_key.str||' IS NULL OR'||CHR(10)||'T2.'||r_key.str||' IS NULL OR';
           END IF; 
        END LOOP;
        
        -- This will built the rest of the where condition string
        -- This also handles Null values comparision by passing default values based on the Data_type
        FOR rec2 IN cur_tab(in_TABLE_NAME1)   LOOP
           IF rec2.DATA_TYPE = 'VARCHAR2' THEN
             v_nvl_str := 'NVL(T1.'||rec2.COLUMN_NAME||','||''''||g_char||''''||') <> NVL(T2.'||rec2.COLUMN_NAME||','||''''||g_char||''''||') OR';   
           ELSIF rec2.DATA_TYPE = 'DATE' THEN
             v_nvl_str := 'NVL(T1.'||rec2.COLUMN_NAME||','||''''||g_date||''''||') <> NVL(T2.'||rec2.COLUMN_NAME||','||''''||g_date||''''||') OR';
           ELSIF rec2.DATA_TYPE = 'NUMBER' THEN
             v_nvl_str :='NVL(T1.'||rec2.COLUMN_NAME||','||''''||g_number||''''||') <> NVL(T2.'||rec2.COLUMN_NAME||','||''''||g_number||''''||') OR'; 
           END IF;        
        
          v_whr_cond_str := v_whr_cond_str||v_nvl_str || CHR(10);     
        END LOOP;
        
        DBMS_OUTPUT.PUT_LINE (v_whr_cond_str);
        
        -- This will remove the ' OR' from the Where condition string
        v_whr_cond_str := SUBSTR(v_whr_cond_str,1,LENGTH(v_whr_cond_str)-3);

        -- This will built the whole Dynamic Diff Select string
        v_diff_str         :=  'SELECT '||v_t1_select_str||','||v_t2_select_str
                               ||'FROM ' ||in_TABLE_NAME1||' T1'||CHR(10)
                               ||'FULL OUTER JOIN '||in_TABLE_NAME2 ||' T2'|| CHR(10) 
                               ||'ON ' ||v_join_str|| CHR(10) 
                               ||'WHERE '||v_null_cond_str||CHR(10)||v_whr_cond_str || CHR(10) 
                               ;  
        --DBMS_OUTPUT.PUT_LINE(v_diff_str);
        
        -- Open the ref cursor for the Dynamic Diff Select string
        OPEN  v_ref_cursor FOR v_diff_str;
        
           -- Convert refcursor "parameter" to DBMS_SQL cursor.
           v_cursor := DBMS_SQL.TO_CURSOR_NUMBER(v_ref_cursor);
        
           -- Describe the cursor.
           DBMS_SQL.DESCRIBE_COLUMNS(v_cursor, v_cols, v_desc);
    
           --Define columns to be fetched.
           FOR i IN 1 .. v_cols LOOP
              IF v_desc(i).col_type = 2   THEN
                 DBMS_SQL.DEFINE_COLUMN(v_cursor, i, v_number); 
              ELSIF v_desc(i).col_type = 12   THEN
                 DBMS_SQL.DEFINE_COLUMN(v_cursor, i, v_date);
              ELSE
                 DBMS_SQL.DEFINE_COLUMN(v_cursor, i, v_varchar2, 4000);
              END IF; 
           END LOOP; 
 
        --Output the data header...
        FOR i IN 1 .. v_cols LOOP 
           IF  v_data IS NULL   THEN
              v_data := v_desc(i).col_name;
           ELSE
              v_data := v_data ||','|| v_desc(i).col_name ;
          END IF;
        END LOOP;
        v_count := regexp_count(v_data,',');
        v_header_rec := SUBSTR(v_data,1,INSTR(v_data,',',1,(v_count/2)));
        v_data := 'IN_TABLE'||','||v_header_rec;
        
        -- This writes Header record in to the file
        UTL_FILE.PUT_LINE(diff_output_file, v_data, TRUE); 
      
        -- Fetch all the Diff Records...      
        WHILE DBMS_SQL.FETCH_ROWS(v_cursor) > 0 LOOP
           v_data := NULL;         
           FOR i IN 1 .. v_cols LOOP
              IF v_desc(i).col_type = 1 THEN
                 DBMS_SQL.COLUMN_VALUE(v_cursor, i, v_varchar2);
                 v_data := v_data ||'"'||v_varchar2||'"'||',';
              ELSIF v_desc(i).col_type = 2 THEN         
                 DBMS_SQL.COLUMN_VALUE(v_cursor, i, v_number);
                 v_data := v_data ||'"'||v_number||'"'||',';
              ELSIF v_desc(i).col_type = 12 THEN
                 DBMS_SQL.COLUMN_VALUE(v_cursor, i, v_date);
                 v_data := v_data ||'"'||v_date||'"'||',';
              END IF;         
           END LOOP;      
           v_count := 0;        
           v_count := regexp_count(v_data,'",');
           v_data_rec1 := in_TABLE_NAME1||','||SUBSTR(v_data,1,INSTR(v_data,'",',1,(v_count/2))+1);
           v_data_rec2 := in_TABLE_NAME2||','||SUBSTR(v_data,INSTR(v_data,'",',1,(v_count/2))+2);
           
           UTL_FILE.PUT_LINE(diff_output_file, v_data_rec1, TRUE);
           UTL_FILE.PUT_LINE(diff_output_file, v_data_rec2, TRUE); 
        END LOOP;
        DBMS_SQL.CLOSE_CURSOR(v_cursor);
    END IF;

EXCEPTION
    WHEN table_structure_excp THEN
        DBMS_OUTPUT.PUT_LINE('Given table Structures are not Similar');
        ERRPKG.INSERT_ERROR_LOG_SP(SQLCODE
                                  ,'DIFF_DATA_sp'
                                  ,'Given table Structures are not Similar'
                                  ,'000000'
                                  ,'0000000000');
    WHEN OTHERS THEN
        ERRPKG.INSERT_ERROR_LOG_SP(SQLCODE
                                  ,'DIFF_DATA_sp'
                                  ,SQLERRM
                                  ,'000000'
                                  ,'0000000000');
END  DIFF_DATA_sp;  


PROCEDURE MATCH_DATA_sp(in_TABLE_NAME1 IN VARCHAR2
                       ,in_TABLE_NAME2 IN VARCHAR2
                       ,in_file_name IN VARCHAR2
/**************************************************************** 
Purpose : his will create a Diff .CSV formatted file on the the server 
          Input Parameters:
          in_TABLE_NAME1,in_TABLE_NAME2 : tables to be compared
          in_file_name : Name of the Match file to be written on server           
Created : 05/19/2016 axd783 CCN Project Team...
Changed :
*****************************************************************/
)
IS
v_file_path                         VARCHAR2(50);
match_output_file                   utl_file.file_type;
match_filename                      VARCHAR2(100);
v_t1_select_str                     VARCHAR2(10000) := NULL;  
v_t2_select_str                     VARCHAR2(10000) := NULL; 
v_match_str                         VARCHAR2(10000) := NULL;
v_ref_cursor                        SYS_REFCURSOR;
v_desc                              DBMS_SQL.DESC_TAB;
v_cols                              BINARY_INTEGER;
v_cursor                            BINARY_INTEGER;
v_varchar2                          VARCHAR2(4000);
v_number                            NUMBER;
v_date                              DATE;
v_data                              VARCHAR2(32767);
table_structure_excp                EXCEPTION; 

CURSOR cur_tab (in_TABLE_NAME IN VARCHAR2)
IS
   SELECT COLUMN_NAME
     FROM ALL_TAB_COLUMNS
    WHERE TABLE_NAME = upper(in_TABLE_NAME)
 ORDER BY COLUMN_ID asc ;
     
BEGIN
    -- Call Validate Function to validate input paramters (in_TABLE_NAME1 and in_TABLE_NAME2) to see if they are having Identical structure    
    IF NOT VALIDATE_TABLES_fnc(in_TABLE_NAME1,in_TABLE_NAME2) THEN    
        RAISE table_structure_excp;
    
    ELSE

        v_file_path := ccn_common_tools.get_datafile_path_fnc('STORDRFT');
        -- Output Match File Name 
        match_filename:=    UPPER(in_file_name)||'_Match_File_'||TO_CHAR(SYSDATE,'MMDDYY') ||'.csv';
        match_output_file := utl_file.fopen ( v_file_path
                                             ,match_filename 
                                             ,'W' 
                                             ,32767); 
        -- This will build the select string which includes all the table columns,As we already validated the two tables structures 
        -- which includes column names,So in one loop building two tables select strings including all the columns in tables
        FOR rec1 IN cur_tab( in_TABLE_NAME1)   LOOP
           IF cur_tab%ROWCOUNT = 1   THEN             
              v_t1_select_str   := rec1.COLUMN_NAME;              
              v_t2_select_str   := rec1.COLUMN_NAME;
           ELSE
              v_t1_select_str   := v_t1_select_str ||','||rec1.COLUMN_NAME;           
              v_t2_select_str   := v_t2_select_str ||','||rec1.COLUMN_NAME;
           END IF;    
        END LOOP; 
       -- This will built the whole Dynamic Match Select string
        v_match_str      := 'SELECT '||v_t1_select_str|| CHR(10)
                            || CHR(9)|| 'FROM ' ||'('|| CHR(10)
                            || CHR(9)|| 'SELECT COUNT(tab1) AS tab1' ||','||'COUNT(tab2) AS tab2'||','||v_t1_select_str || CHR(10) 
                            || CHR(9)|| 'FROM ' ||'('|| 'SELECT ' || v_t1_select_str ||','||' 1 AS tab1' ||','||' TO_NUMBER(NULL) AS tab2 '|| 'FROM '||in_TABLE_NAME1|| CHR(10) 
                            || CHR(9)|| CHR(9)|| CHR(9)|| CHR(9)|| 'UNION ALL' ||CHR(10)
                            || CHR(9)|| CHR(9)|| CHR(9)|| CHR(9)||'SELECT '||v_t2_select_str||','||' TO_NUMBER(NULL) AS tab1' ||','|| '2 AS tab2 '||'FROM '||in_TABLE_NAME2|| CHR(10) 
                            || CHR(9)|| CHR(9)|| CHR(9)|| CHR(9)||')'|| CHR(10) 
                            ||'GROUP BY '|| v_t1_select_str || CHR(10)       
                            ||'HAVING COUNT(tab1)'||' = '||'COUNT(tab2)'|| CHR(10) 
                            ||'ORDER BY '|| v_t1_select_str || CHR(10)
                            ||')'|| CHR(10) 
                             ;

        DBMS_OUTPUT.PUT_LINE( v_match_str);
        -- Open the ref cursor for the Dynamic Match Select string
        OPEN  v_ref_cursor FOR v_match_str;      
           -- Convert refcursor "parameter" to DBMS_SQL cursor... 
           v_cursor := DBMS_SQL.TO_CURSOR_NUMBER(v_ref_cursor);
           -- Describe the cursor... 
           DBMS_SQL.DESCRIBE_COLUMNS(v_cursor, v_cols, v_desc);
           --Define columns to be fetched. We're only using V2, NUM, DATE for example
           FOR i IN 1 .. v_cols LOOP
              IF v_desc(i).col_type = 2   THEN
                 DBMS_SQL.DEFINE_COLUMN(v_cursor, i, v_number);
              ELSIF v_desc(i).col_type = 12   THEN
                 DBMS_SQL.DEFINE_COLUMN(v_cursor, i, v_date);
              ELSE
                 DBMS_SQL.DEFINE_COLUMN(v_cursor, i, v_varchar2, 4000);
              END IF; 
           END LOOP; 
           --Now output the data, Start with header...    
           DBMS_OUTPUT.NEW_LINE;      
           FOR i IN 1 .. v_cols LOOP 
           IF  v_data IS NULL   THEN
              v_data := v_desc(i).col_name;
           ELSE
              v_data := v_data ||','|| v_desc(i).col_name ;
           END IF;
           END LOOP;           
           -- This writes Header 
           UTL_FILE.PUT_LINE(match_output_file, v_data, TRUE);
           v_data := NULL;
           
           -- Fetch all the matching data...
           WHILE DBMS_SQL.FETCH_ROWS(v_cursor) > 0 LOOP
              v_data := NULL;
              FOR i IN 1 .. v_cols LOOP
                 IF v_desc(i).col_type = 1 THEN
                    DBMS_SQL.COLUMN_VALUE(v_cursor, i, v_varchar2);
                    v_data := v_data ||v_varchar2||','; 
                 ELSIF v_desc(i).col_type = 2 THEN
                    DBMS_SQL.COLUMN_VALUE(v_cursor, i, v_number);
                    v_data := v_data ||v_number||',';
                 ELSIF v_desc(i).col_type = 12 THEN
                    DBMS_SQL.COLUMN_VALUE(v_cursor, i, v_date);
                    v_data := v_data ||v_date||',';
                 END IF;
              END LOOP;          
              UTL_FILE.PUT_LINE(match_output_file, v_data, TRUE);
           END LOOP; 
        DBMS_SQL.CLOSE_CURSOR(v_cursor);   
    END IF;

EXCEPTION
    WHEN table_structure_excp THEN   
        DBMS_OUTPUT.PUT_LINE('Given table Structures are not Similar');   
        ERRPKG.INSERT_ERROR_LOG_SP(SQLCODE
                                  ,'MATCH_DATA_sp'
                                  ,'Given table Structures are not Similar'
                                  ,'000000'
                                 ,'0000000000');
    WHEN OTHERS THEN
        ERRPKG.INSERT_ERROR_LOG_SP(SQLCODE
                                  ,'MATCH_DATA_sp'
                                  ,SQLERRM
                                  ,'000000'
                                  ,'0000000000');
END MATCH_DATA_sp;

END SD_COMPARE_DATA_pkg;