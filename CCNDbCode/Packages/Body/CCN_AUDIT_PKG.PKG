create or replace 
PACKAGE BODY CCN_AUDIT_PKG as 
/*********************************************************** 
This package has procedures and functions related to the audit_log table
created : 02/29/2012 tal CCN project
revisions: 
************************************************************/

FUNCTION XML_TO_STRING

/*******************************************************
Function to Return pipe delimited string (key value 
concatenated) based on the input key XML 

created : 06/07/2012
*******************************************************/

( 
  IN_Table_Name 	IN 	VARCHAR2
, IN_XML_KEY 		IN 	XMLTYPE
)
  RETURN VARCHAR2

IS

CURSOR KEY_COL IS
	SELECT COL.COLUMN_NAME
	  FROM ALL_CONS_COLUMNS COL,
         ALL_CONSTRAINTS CON
	 WHERE COL.TABLE_NAME      = CON.TABLE_NAME
	   AND CON.CONSTRAINT_TYPE = 'P' 
	   AND COL.CONSTRAINT_NAME = CON.CONSTRAINT_NAME
	   AND COL.TABLE_NAME      = IN_Table_Name
	 ORDER BY COL.POSITION;

	V_CONCAT_STR	VARCHAR2(1000):='|';
	V_CONTEXT	VARCHAR2(200);
	SQ NUMBER;
	SE VARCHAR2(100);
        

BEGIN
	V_CONTEXT := 'Looping through input key XML';
	
	FOR KEY_COLS_REC IN KEY_COL LOOP
     V_CONCAT_STR := V_CONCAT_STR ||  XML_EXTRACT_NO_EXCEPTION(IN_XML_KEY,'//' || KEY_COLS_REC.COLUMN_NAME) || '|';
	END LOOP;
	
	V_CONTEXT := 'Returning string';
	
	RETURN V_CONCAT_STR;

EXCEPTION WHEN OTHERS THEN
	SQ := SQLCODE;
	SE := SQLERRM;
	V_CONTEXT := V_CONTEXT || ' ' || SQ || ' ' || SE; 

	ERRPKG.RAISE_ERR(-20003,'XML_TO_STRING',V_CONTEXT);

END XML_TO_STRING;
	

FUNCTION XML_EXTRACT_NO_EXCEPTION
/**********************************************************
This function returns null if XPATH does not exist within xmltype, 
oracle throws an exception if not handled this way
**********************************************************/
( p_xml IN XMLTYPE
, p_xpath IN VARCHAR2
) RETURN VARCHAR2 

IS

BEGIN

    RETURN 
	    CASE WHEN P_XML.EXTRACT(P_XPATH) IS NOT NULL THEN
	      p_xml.extract(p_xpath || '/text()').getstringval()
	    ELSE 
	       NULL
	    END;

END XML_EXTRACT_NO_EXCEPTION;

FUNCTION REQUIRED_TABLE_CHECK
/**********************************************************
this function checks for the table to be excluded or included
by checking the excluded indicator and the table name from the 
'CCN_AUDIT_EXCLUDED_TABLES' table

created : 08/20/2012
**********************************************************/
(IN_TABLE_NAME   IN   VARCHAR2)
RETURN VARCHAR2
IS
  L_RETURN_VALUE VARCHAR2(1) := 'Y';
BEGIN

  SELECT CASE WHEN COUNT(*) > 0 THEN
                    'N'
                   ELSE
                    'Y'
                   END CASE
    INTO L_RETURN_VALUE
    FROM CCN_AUDIT_EXCLUDED_TABLES
   WHERE TABLE_NAME         = UPPER(IN_TABLE_NAME)
     AND EXCLUDED_INDICATOR = 'Y';

  RETURN L_RETURN_VALUE;

EXCEPTION
  WHEN OTHERS THEN
    RETURN L_RETURN_VALUE;
END REQUIRED_TABLE_CHECK;

PROCEDURE SELECT_AUDIT_LOG
/**********************************************************
Selects all rows from audit_log that have changed from
the last run of the backfeed process

created : 06/07/2012
**********************************************************/

IS

/*CURSOR SEL_AUDIT_LOG IS
SELECT 'COST_CENTER' AS TABLE_NAME --AL.TABLE_NAME
,'12345678'AS TRANSACTION_ID       --,AL.TRANSACTION_ID
FROM DUAL;
*/

CURSOR SEL_AUDIT_LOG IS
SELECT DISTINCT AL.TABLE_NAME,
                AL.TRANSACTION_ID
  FROM AUDIT_LOG AL,
       BATCH_JOB BATCH
 WHERE BATCH.BATCH_JOB_NAME = 'BACKFEED_AUDIT_LOG'
   AND AL.TRANSACTION_DATE  >= BATCH.BATCH_JOB_LAST_RUN_DATE
--and    TABLE_NAME IN ('COST_CENTER','TAXWARE') -- for testing only, remove after testing
   AND    BATCH.BATCH_JOB_LAST_RUN_DATE IN (SELECT MAX(B1.BATCH_JOB_LAST_RUN_DATE)
                                              FROM BATCH_JOB B1
                                             WHERE B1.BATCH_JOB_NAME = 'BACKFEED_AUDIT_LOG')
   AND AL.AUDIT_REC_FLAG IS NULL;

V_CONTEXT	VARCHAR2(200);
SQ		INTEGER;
SE		VARCHAR2(1000);

DIFF_XML            XMLTYPE;
v_code              NUMBER;
v_errm              varchar2(500);  
V_CC_CODE           COST_CENTER.COST_CENTER_CODE%TYPE;
V_BATCH_NUMBER      BATCH_JOB.BATCH_JOB_NUMBER%TYPE;
V_TRANS_STATUS      BATCH_JOB.TRANS_STATUS%TYPE := 'SUCCESSFUL';
V_BATCH_JOB_STATUS  BATCH_JOB.BATCH_JOB_STATUS%TYPE := 'PROCESSING';
v_change_type       varchar2(1) := 'A';
       
BEGIN

V_CONTEXT:='Inserting a record in the Batch_Job table with Status as PROCESSING';
CCN_BATCH_PKG.INSERT_BATCH_JOB('BACKFEED_AUDIT_LOG', V_BATCH_NUMBER);

FOR SEL_AUDIT_REC IN SEL_AUDIT_LOG LOOP
    BEGIN
  
            --Check if audit process is neede for the current table
            IF REQUIRED_TABLE_CHECK(SEL_AUDIT_REC.TABLE_NAME) = 'Y' THEN
              SAVEPOINT NEXT_AUDIT_REC;
                            
                  V_CONTEXT:='Call procedure PARSE_DIFFERENCE_XML for every combination of table_name,transaction_id';
                  PARSE_DIFFERENCE_XML( SEL_AUDIT_REC.TABLE_NAME
                                       ,SEL_AUDIT_REC.TRANSACTION_ID
                                       ,V_CC_CODE
  				                             ,V_CHANGE_TYPE
                                       ,DIFF_XML);

                  V_CONTEXT:='Call procedure Build_File_SP';
                  --DBMS_OUTPUT.PUT_LINE('DIFF XML ' || DIFF_XML.getCLOBVal());
                  BUILD_FILE_SP(V_CC_CODE
                                ,SEL_AUDIT_REC.TABLE_NAME	--in_TABLE_NAME IN VARCHAR2
                                ,SYSDATE			--in_ROW_DATE   IN DATE
                                ,DIFF_XML			--in_Row_data   IN sys.xmltype
                                ,V_CHANGE_TYPE);
            END IF;
      EXCEPTION
           WHEN OTHERS THEN
             ROLLBACK TO NEXT_AUDIT_REC;
             V_TRANS_STATUS := 'ERROR';
             v_code  := SQLCODE;
             v_errm  := substr(SQLERRM,1,500);
             --write to error log
             errpkg.INSERT_ERROR_LOG_SP(v_code, 'SELECT_AUDIT_LOG', v_errm, V_CC_CODE); 
      END;
     
END LOOP;  
      
      V_CONTEXT:='Updating the Status in batch_job table';
      CCN_BATCH_PKG.UPDATE_BATCH_JOB('BACKFEED_AUDIT_LOG', V_BATCH_NUMBER, V_TRANS_STATUS); 
      
EXCEPTION WHEN OTHERS THEN
         
	SQ := SQLCODE;
	SE := SQLERRM;
	
	V_CONTEXT := V_CONTEXT || ' ' || SQ || ' ' || SE; 
 
	ERRPKG.RAISE_ERR(-20003,'SELECT_AUDIT_LOG',V_CONTEXT);
 
END SELECT_AUDIT_LOG;

PROCEDURE PARSE_DIFFERENCE_XML

/*******************************************************
Procedure to Parse xmls from the audit_log table and 
create an output xml with the differences

Author   : 

versions : 02/22/2012
*******************************************************/

( IN_TABLE_NAME IN VARCHAR2
, IN_KEY        IN VARCHAR2
, OUT_CC_CODE 	OUT VARCHAR2
, OUT_CHANGE_TYPE OUT VARCHAR2
, OUT_DIFF OUT XMLTYPE
)

IS

ROW_CURR	 AUDIT_LOG.TABLE_ROW_DATA%TYPE;
V_LOG_ID_CURR    AUDIT_LOG.LOG_ID%TYPE;
ROW_PREV	 AUDIT_LOG.TABLE_ROW_DATA%TYPE;
V_LOG_ID_PREV    AUDIT_LOG.LOG_ID%TYPE;
V_CONTEXT	 VARCHAR2(200);
V_COSTCENTERCODE COST_CENTER.COST_CENTER_CODE%TYPE;
v_change_type    VARCHAR2(1);

COMP_CURR       VARCHAR2(1000);
COMP_PREV	VARCHAR2(1000);

XMLSTRING	VARCHAR2(30000):='';

SQ		INTEGER; 
SE		VARCHAR2(1000);

CURSOR GET_COLS (IN_TABLE IN VARCHAR2) IS
   SELECT COLUMN_NAME
     FROM ALL_TAB_COLUMNS
    WHERE TABLE_NAME = IN_TABLE
   --For Hierarchy_Detail table alone we need to append 2 more fields at the end - statement_type and emplyee_name
   UNION
   SELECT COLUMN_NAME
     FROM CCN_ADDITIONAL_AUDIT_FIELDS
    WHERE TABLE_NAME = IN_TABLE
    ORDER BY COLUMN_NAME;

BEGIN

	V_CONTEXT := 'Selecting Previous Row from Audit_Log';

	BEGIN

   SELECT TABLE_ROW_DATA,
          LOG_ID
     INTO ROW_PREV,
          V_LOG_ID_PREV
     FROM AUDIT_LOG AL,
          BATCH_JOB BATCH
    WHERE AL.TABLE_NAME        = IN_TABLE_NAME
      AND BATCH.BATCH_JOB_NAME = 'BACKFEED_AUDIT_LOG'
		  --AND TRUNC(BATCH.BATCH_JOB_LAST_RUN_DATE) = TRUNC(AL.AUDIT_REC_EFF_DATE)
      AND AL.AUDIT_REC_FLAG    = 'R'
      AND AL.TRANSACTION_ID    = IN_KEY
      AND AL.TRANSACTION_DATE IN (SELECT MAX(AL1.TRANSACTION_DATE)
                                    FROM AUDIT_LOG AL1
                                   WHERE AL1.TABLE_NAME     = AL.TABLE_NAME
                                     AND AL1.TRANSACTION_ID = IN_KEY
                                     AND AL1.AUDIT_REC_FLAG = 'R')
      AND BATCH.BATCH_JOB_LAST_RUN_DATE IN(SELECT MAX(B1.BATCH_JOB_LAST_RUN_DATE)
                                             FROM BATCH_JOB B1
                                            WHERE B1.BATCH_JOB_NAME= 'BACKFEED_AUDIT_LOG')
      AND ROWNUM < 2
    ORDER BY AL.LOG_ID DESC;
    
    V_CHANGE_TYPE := 'C';
       
	EXCEPTION

		WHEN NO_DATA_FOUND THEN
                     v_change_type := 'A';
	    --NULL;
	END;
	
	V_CONTEXT := 'Selecting Current Row from Audit_Log';
	
  SELECT TABLE_ROW_DATA,
         LOG_ID
    INTO ROW_CURR,
         V_LOG_ID_CURR
    FROM AUDIT_LOG AL
    WHERE TABLE_NAME        = IN_TABLE_NAME
      AND AL.TRANSACTION_ID = IN_KEY
      AND AL.TRANSACTION_DATE IN (SELECT MAX(AL1.TRANSACTION_DATE)
                                    FROM AUDIT_LOG AL1
                                   WHERE AL1.TABLE_NAME     = AL.TABLE_NAME
                                     AND AL1.TRANSACTION_ID = IN_KEY)
      AND AL.LOG_ID = (SELECT MAX( AL2.LOG_ID)
                         FROM	AUDIT_LOG AL2
                        WHERE AL2.TABLE_NAME = AL.TABLE_NAME
                          AND AL2.TRANSACTION_ID = IN_KEY);
        --dbms_output.put_line('The change type ' || v_change_type);	
	V_CONTEXT := 'Parsing the XMLType';
	
	--Start building the XML string
  
	XMLSTRING := '<' || IN_Table_name || ' xmlns:xsi="http://www.w3.org/2001/XMLSchema" xsi:nonamespaceSchemaLocation="http://www.oracle.com/Employee.xsd">';
	
	
  FOR GET_COLS_REC IN GET_COLS(IN_TABLE_NAME) LOOP

    /*The function XML_EXTRACT_NO_EXCEPTION is used, it uses the extract function on the xmltype like given below
    p_xml.extract(p_xpath || '/text()').getstringval() */

     IF V_CHANGE_TYPE = 'C' THEN
        COMP_PREV := XML_EXTRACT_NO_EXCEPTION(ROW_PREV,'//' || GET_COLS_REC.COLUMN_NAME);
     END IF; 
     
     COMP_CURR := XML_EXTRACT_NO_EXCEPTION(ROW_CURR,'//' || GET_COLS_REC.COLUMN_NAME);

     IF (COMP_CURR IS NULL) THEN
         COMP_CURR := '~';
     END IF;

     IF GET_COLS_REC.COLUMN_NAME = 'COST_CENTER_CODE' THEN
        v_CostCenterCode := COMP_CURR;
     END IF;

     --If the elements have changed OR new row, append them to the XML string
     IF v_change_type = 'A' THEN
        XMLSTRING := XMLSTRING || '<' || GET_COLS_REC.COLUMN_NAME || '>' || COMP_CURR || '</' || GET_COLS_REC.COLUMN_NAME || '>';
     ELSE
        IF NVL(COMP_CURR,'A') <> NVL(COMP_PREV,'A') THEN
           XMLSTRING := XMLSTRING || '<' || GET_COLS_REC.COLUMN_NAME || '>' || COMP_CURR || '</' || GET_COLS_REC.COLUMN_NAME || '>';
        END IF;
     END IF;

	END LOOP;
--dbms_output.put_line('Cost Center ' || v_CostCenterCode);

           V_CONTEXT := 'Updating the PREV AUDIT_REC_FLAG to C';
            UPDATE AUDIT_LOG
               SET AUDIT_REC_FLAG = 'C',
                   AUDIT_REC_EFF_DATE = SYSDATE
             WHERE TABLE_NAME = IN_TABLE_NAME
               AND LOG_ID = V_LOG_ID_PREV
               AND TRANSACTION_ID = IN_KEY
               AND AUDIT_REC_FLAG = 'R';
        
            V_CONTEXT := 'Updating the CURR AUDIT_REC_FLAG to R';
            UPDATE AUDIT_LOG
               SET AUDIT_REC_FLAG = 'R'
            WHERE TABLE_NAME = IN_TABLE_NAME
               AND LOG_ID = V_LOG_ID_CURR
               AND TRANSACTION_ID = IN_KEY
               AND AUDIT_REC_FLAG IS NULL;
               
	V_CONTEXT := 'Final value being set';
		
	XMLSTRING := XMLSTRING || '</' || IN_Table_name || '>';
		
	V_CONTEXT := 'Converting to XMLType';
	
  --Convert the final XML String to XMLType and set it to the OUT parameter
  
	OUT_DIFF  := XMLType(XMLSTRING);
	OUT_CC_CODE := v_CostCenterCode;
	OUT_CHANGE_TYPE := v_change_type;

EXCEPTION WHEN OTHERS THEN
	SQ := SQLCODE;
	SE := SQLERRM;
	V_CONTEXT := V_CONTEXT || ' ' || SQ || ' ' || SE; 
 
 	ERRPKG.RAISE_ERR(-20003,'PARSE_DIFFERENCE_XML for ' || IN_TABLE_NAME || ' ' || IN_KEY || 'at ', V_CONTEXT);
	
END PARSE_DIFFERENCE_XML; 

PROCEDURE Build_File_SP (
/**********************************************************
	Build_File_SP

	This procedure is intended to build a file based on the table layout
	in order to be consumed by the Mainframe to backfill Legacy MainFrame

	CostCenter - Cost Center that changed
	OracleTableName -Table name for row
	varible (based on the table that was updated)


created : 02/21/2012 kdp CCN Project....
**********************************************************/
IN_COST_CENTER IN COST_CENTER.COST_CENTER_CODE%TYPE
,in_TABLE_NAME IN VARCHAR2
,in_ROW_DATE   IN DATE
,in_Row_data    IN sys.XMLTYPE           
,in_CHANGE_TYPE in VARCHAR2
)
 is 
CURSOR table_fields_cur IS
   SELECT COLUMN_NAME,
          DECODE(DATA_TYPE, 'DATE', 8, DATA_LENGTH) COLUMN_SIZE,
          DATA_TYPE,
          COLUMN_ID
     FROM ALL_TAB_COLUMNS
    WHERE TABLE_NAME = IN_TABLE_NAME
   --For Hierarchy_Detail table alone we need to append 2 more fields at the end - statement_type and emplyee_name
   UNION
   SELECT COLUMN_NAME,
          DECODE(DATA_TYPE, 'DATE', 8, DATA_LENGTH) COLUMN_SIZE,
          DATA_TYPE,
          COLUMN_ID
     FROM CCN_ADDITIONAL_AUDIT_FIELDS
    WHERE TABLE_NAME = IN_TABLE_NAME
    ORDER BY COLUMN_ID ASC;
--;
--

  PATH        	        VARCHAR2(50) := 'CCN_DATAFILES'; -- directory created in Oracle database UNTIL NEW ONE CREATED
  filename  	          VARCHAR2(50) := in_TABLE_NAME || '_backfeed' ;
  stamp       		      VARCHAR2(50) := to_char(sysdate,'HH:MI:SS'); -- used to create timestamp for data file 
  v_cost_center		      VARCHAR2(6)  := '      '; --added for spaces with tables that don't use cost center
  output_file 		      UTL_FILE.FILE_TYPE;
-------------
  l_out_file            UTL_FILE.FILE_TYPE;
  l_buffer              RAW(32767);
  l_amount              BINARY_INTEGER := 32767;
  l_pos                 INTEGER        := 1;
  L_BLOB_LEN            INTEGER;
  v_out_clob            CLOB;
  V_CONTEXT	            VARCHAR2(200);
  SQ		                INTEGER; 
  SE		                VARCHAR2(1000);

BEGIN

   -- working just remove for debbuging un comment for writing file
   --dbms_output.put_line('start');
   V_CONTEXT := 'Creating the file on server';
   output_file := UTL_FILE.FOPEN (path
                                  ,filename|| stamp
                                  , 'w' --binary
                                  , 32767);
   --adding header information for the backload file
   --DBMS_OUTPUT.PUT_LINE('start v_out_clob');
   IF IN_COST_CENTER IS NOT NULL THEN
      V_COST_CENTER := IN_COST_CENTER; 
   END IF;

V_CONTEXT := 'Generating the CLOB Output';
   V_OUT_CLOB := TO_CHAR (TRUNC(SYSDATE),'YYYYMMDDHH24MISS') ||
                 V_COST_CENTER                               ||
                 RPAD(IN_TABLE_NAME,25)                      ||
                 TO_CHAR (TRUNC(SYSDATE),'YYYYMMDDHH24MISS') ||
                 IN_CHANGE_TYPE;
   FOR TABLE_FIELDS_REC IN TABLE_FIELDS_CUR LOOP
 
      IF (IN_ROW_DATA.EXISTSNODE('/'|| IN_TABLE_NAME|| '/' || TABLE_FIELDS_REC.COLUMN_NAME ||'/text()') = 1) THEN
         V_CONTEXT := 'Building by extracting the Existing Data';
         IF ((IN_TABLE_NAME||' - '|| TABLE_FIELDS_REC.COLUMN_NAME = 'COST_CENTER - POS_PROG_VER_NBR' )) THEN
            V_OUT_CLOB := V_OUT_CLOB ||
                          UPPER(LPAD(IN_ROW_DATA.EXTRACT('/'|| IN_TABLE_NAME|| '/' || TABLE_FIELDS_REC.COLUMN_NAME ||'/text()').GETSTRINGVAL(),
                                     TABLE_FIELDS_REC.COLUMN_SIZE, '0'));
         ELSE
            V_OUT_CLOB := V_OUT_CLOB ||
                           UPPER(RPAD(IN_ROW_DATA.EXTRACT('/'|| IN_TABLE_NAME|| '/' || TABLE_FIELDS_REC.COLUMN_NAME ||'/text()').GETSTRINGVAL(),
                                      TABLE_FIELDS_REC.COLUMN_SIZE));
         END IF;
 
      ELSE
         V_CONTEXT := 'Building by extracting the Non-Existing Data';
         --Setting Open_Date to '01012099' which have null open date so that we can pass it to main frame
         IF ((IN_TABLE_NAME||' - '|| TABLE_FIELDS_REC.COLUMN_NAME = 'COST_CENTER - OPEN_DATE' )) THEN
            V_OUT_CLOB := V_OUT_CLOB || UPPER(RPAD('01012099',TABLE_FIELDS_REC.COLUMN_SIZE));
            --Setting All 9's for Phone_Number, Merchant_Id, Quality_Code, Amex_SE_Id, Discover_Id
            --which have null values so that we can pass it to main frame
         ELSE
            IF ((IN_TABLE_NAME||' - '|| TABLE_FIELDS_REC.COLUMN_NAME IN ('BANK_CARD - MERCHANT_ID',
                                                                         'BANK_CARD - QUALITY_CODE',
                                                                         'BANK_CARD - AMEX_SE_ID',
                                                                         'BANK_CARD - DISCOVER_ID',
                                                                         'PHONE - PHONE_NUMBER',
                                                                         'PHONE - PHONE_AREA_CODE'))) THEN
               V_OUT_CLOB := V_OUT_CLOB || UPPER(LPAD('9',TABLE_FIELDS_REC.COLUMN_SIZE,'9'));	
            ELSE
               V_OUT_CLOB := V_OUT_CLOB || RPAD(' ',TABLE_FIELDS_REC.COLUMN_SIZE);
            END IF;
         END IF;
      END IF;
   END LOOP;
--dbms_output.put_line('clob output ' || v_out_clob);      
  --working just remove for debbuging un comment for writing file
     UTL_FILE.PUT_LINE(output_file, v_out_clob, TRUE);
     UTL_FILE.FCLOSE(output_file);
EXCEPTION WHEN OTHERS THEN
	SQ := SQLCODE;
	SE := SQLERRM;
	V_CONTEXT := V_CONTEXT || ' ' || SQ || ' ' || SE; 
 
 	ERRPKG.RAISE_ERR(-20003,'Build_File_SP in ' || IN_TABLE_NAME || ' for ' || IN_COST_CENTER || 'at ', V_CONTEXT);
END Build_File_SP;

END CCN_AUDIT_PKG;