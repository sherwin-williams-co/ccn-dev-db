create or replace PACKAGE BODY         DEPOSIT_TICKET_MAINTENANCE_PKG
AS
/**********************************************************
This Package contains all the procedures used in
bank deposit ticket maintenance window

Created : 07/09/2015 jxc517 CCN Project....
Changed :
**********************************************************/
PROCEDURE DELETE_STORE_MICR_FORMAT_DTLS(
/*******************************************************************************
This procedure is intended to get the STORE_MICR_FORMAT_DTLS record
and delete it from the table

Created : 08/18/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE     IN    VARCHAR2,
IN_BANK_ACCOUNT_NBR     IN    VARCHAR2,
IN_MICR_FORMAT_ID       IN    NUMBER)
IS
    CURSOR store_micr_format_dtls_cur1 IS 
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE;
    CURSOR bank_dep_tick_cur IS
        SELECT *
          FROM BANK_DEP_TICK
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE;
    CURSOR bank_dep_tickord_cur IS
        SELECT *
          FROM BANK_DEP_TICKORD
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE;
    CURSOR store_micr_format_dtls_cur IS 
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS
         WHERE BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
           AND MICR_FORMAT_ID   = IN_MICR_FORMAT_ID;
BEGIN
    IF IN_COST_CENTER_CODE IS NOT NULL THEN
        FOR rec IN store_micr_format_dtls_cur1 LOOP
            TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_D_SP(rec);
        END LOOP;
        FOR rec IN bank_dep_tick_cur LOOP
            TABLE_IU_PKG.BANK_DEP_TICK_D_SP(rec);
        END LOOP;
        FOR rec IN bank_dep_tickord_cur LOOP
            TABLE_IU_PKG.BANK_DEP_TICKORD_D_SP(rec);
        END LOOP;
    ELSE
        FOR rec IN store_micr_format_dtls_cur LOOP
            TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_D_SP(rec);
        END LOOP;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END DELETE_STORE_MICR_FORMAT_DTLS;

PROCEDURE EXPIRE_STORE_MICR_FORMAT_DTLS(
/*******************************************************************************
This procedure is intended to get the STORE_MICR_FORMAT_DTLS record
and expire it from the table

Created : 08/18/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE     IN    VARCHAR2,
IN_BANK_ACCOUNT_NBR     IN    VARCHAR2,
IN_MICR_FORMAT_ID       IN    NUMBER,
IN_EXPIRATION_DATE      IN    DATE)
IS
    CURSOR store_micr_format_dtls_cur1 IS 
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EXPIRATION_DATE IS NULL;
    CURSOR bank_dep_tick_cur IS
        SELECT *
          FROM BANK_DEP_TICK
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EXPIRATION_DATE IS NULL;
    CURSOR bank_dep_tickord_cur IS
        SELECT *
          FROM BANK_DEP_TICKORD
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EXPIRATION_DATE IS NULL;
    CURSOR store_micr_format_dtls_cur IS 
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS
         WHERE BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
           AND MICR_FORMAT_ID   = IN_MICR_FORMAT_ID
           AND EXPIRATION_DATE IS NULL;
BEGIN
    IF IN_COST_CENTER_CODE IS NOT NULL THEN
        FOR rec IN store_micr_format_dtls_cur1 LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_I_SP(rec);
        END LOOP;
        FOR rec IN bank_dep_tick_cur LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.BANK_DEP_TICK_I_SP(rec);
        END LOOP;
        FOR rec IN bank_dep_tickord_cur LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.BANK_DEP_TICKORD_I_SP(rec);
        END LOOP;
    ELSE
        FOR rec IN store_micr_format_dtls_cur LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_I_SP(rec);
        END LOOP;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END EXPIRE_STORE_MICR_FORMAT_DTLS;

PROCEDURE EXPR_STR_MICR_FRMT_DTLS_FTR(
/*******************************************************************************
This procedure is intended to get the STORE_MICR_FORMAT_DTLS record
and expire it from the table

Created : 08/18/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE     IN    VARCHAR2,
IN_BANK_ACCOUNT_NBR     IN    VARCHAR2,
IN_MICR_FORMAT_ID       IN    NUMBER,
IN_FUTURE_ID            IN    NUMBER,
IN_EXPIRATION_DATE      IN    DATE)
IS
    CURSOR store_micr_format_dtls_cur1 IS 
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND FUTURE_ID        = IN_FUTURE_ID
           AND EXPIRATION_DATE IS NULL;
    CURSOR bank_dep_tick_cur IS
        SELECT *
          FROM BANK_DEP_TICK_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND FUTURE_ID        = IN_FUTURE_ID
           AND EXPIRATION_DATE IS NULL;
    CURSOR bank_dep_tickord_cur IS
        SELECT *
          FROM BANK_DEP_TICKORD_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND FUTURE_ID        = IN_FUTURE_ID
           AND EXPIRATION_DATE IS NULL;
    CURSOR store_micr_format_dtls_cur IS 
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS_FUTURE
         WHERE BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
           AND MICR_FORMAT_ID   = IN_MICR_FORMAT_ID
           AND FUTURE_ID        = IN_FUTURE_ID
           AND EXPIRATION_DATE IS NULL;
BEGIN
    IF IN_COST_CENTER_CODE IS NOT NULL THEN
        FOR rec IN store_micr_format_dtls_cur1 LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.STR_MICR_FORMAT_DTLS_FTR_I_SP(rec);
        END LOOP;
        FOR rec IN bank_dep_tick_cur LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.BANK_DEP_TICK_FUTURE_I_SP(rec);
        END LOOP;
        FOR rec IN bank_dep_tickord_cur LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.BANK_DEP_TICKORD_FUTURE_I_SP(rec);
        END LOOP;
    ELSE
        FOR rec IN store_micr_format_dtls_cur LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.STR_MICR_FORMAT_DTLS_FTR_I_SP(rec);
        END LOOP;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END EXPR_STR_MICR_FRMT_DTLS_FTR;

FUNCTION CONVERT_FORMAT_TO_VALUE(
/*******************************************************************************
This function converts the format into actual value to be stored in STORE_MICR_FORMAT_DTLS

Created : 08/18/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_FORMAT     IN     VARCHAR2,
IN_VALUE      IN     VARCHAR2) RETURN VARCHAR2
IS
    V_VALUE         VARCHAR2(100) := REGEXP_REPLACE(IN_VALUE, '[^0-9]+');
    V_COUNT         NUMBER := 0;
    V_RETURN_VALUE  VARCHAR2(100);
BEGIN
    IF REGEXP_LIKE(IN_VALUE, '[0-9]+') THEN
        FOR i IN 1..LENGTH(IN_FORMAT) LOOP
            IF SUBSTR(IN_FORMAT,i ,1) = 'X' THEN
                V_COUNT := V_COUNT + 1;
                V_RETURN_VALUE := V_RETURN_VALUE || SUBSTR(V_VALUE, V_COUNT, 1);
            ELSE
                V_RETURN_VALUE := V_RETURN_VALUE || SUBSTR(IN_FORMAT,i ,1);
            END IF;
        END LOOP;
    ELSE
        V_RETURN_VALUE := NVL(IN_VALUE, IN_FORMAT);
    END IF;
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END CONVERT_FORMAT_TO_VALUE;

PROCEDURE DEPOSIT_TICKET_MNTNC_UI_SP (
/*******************************************************************************
This procedure is intended to RETURN a ref cursor with data from 
tables based on passed input cost center code

Created : 08/21/2015 jxc517 CCN Project....
Changed : 10/22/2015 sxt410 CCN Project....
          Modified Signature To Pass Current Order Date And Future Order Date. 
Changed : 10/29/2015 jxc517 CCN Project....
          Modified code to include order by clause for bank MICR formats based on FORMAT_NAME
*******************************************************************************/
IN_COST_CENTER_CODE                IN     VARCHAR2
,OUT_BANK_DEP_TICK_REF_CUR            OUT REF_CURSOR
,OUT_BANK_ACCOUNT_REF_CUR             OUT REF_CURSOR
,OUT_BANK_MICR_FORMAT_REF_CUR         OUT REF_CURSOR
,OUT_BANK_DEP_TICK_FTR_REF_CUR        OUT REF_CURSOR
,OUT_BANK_ACCOUNT_FTR_REF_CUR         OUT REF_CURSOR
,OUT_BANK_MICR_FRMT_FTR_REF_CUR       OUT REF_CURSOR
,OUT_BANK_DEP_TICKORD_REF_CUR         OUT REF_CURSOR
,OUT_BANK_DEP_TKORD_FTR_REF_CUR       OUT REF_CURSOR)
IS
    V_STORE_MICR_FORMAT_DTLS_REC   STORE_MICR_FORMAT_DTLS%ROWTYPE;
    V_BANK_MICR_FORMAT_REC         BANK_MICR_FORMAT%ROWTYPE;
    V_BANK_ACCOUNT_NBR             BANK_ACCOUNT.BANK_ACCOUNT_NBR%TYPE;
    V_BANK_TYPE_CODE               LEAD_BANK_CC.BANK_TYPE_CODE%TYPE;
BEGIN
    --Below call is needed to get the store MICR format details for the store passed in
    --If the passed store is a member without a default store MICR, we need to get it's leads store MICR details
    V_STORE_MICR_FORMAT_DTLS_REC := BANKING_COMMON_TOOLS.GET_STORE_MICR_FORMAT_DTLS_REC(IN_COST_CENTER_CODE);

    --The above call just returns the bank MICR format id, but not the actual details
    --so we invoke below procedure to get the actual details associated with that bank account number and format id
    V_BANK_MICR_FORMAT_REC := BANKING_COMMON_TOOLS.GET_STORE_BANK_MICR_FORMAT_REC(V_STORE_MICR_FORMAT_DTLS_REC.BANK_ACCOUNT_NBR,
                                                                                  V_STORE_MICR_FORMAT_DTLS_REC.MICR_FORMAT_ID);

    --Since we don't want to change anything from UI because of the change in store MICR format
    --we need to pass the above obtained store MICR format details along with the actual Bank Deposit Ticket details
    --Also anything that got expired even a second before should not be returned back to UI
    OPEN OUT_BANK_DEP_TICK_REF_CUR FOR
        SELECT A.*,
               V_BANK_MICR_FORMAT_REC.FORMAT_NAME AS FORMAT_NAME,
               V_BANK_MICR_FORMAT_REC.DJDE_FORM_PARM AS DJDE_FORM_PARM,
               V_BANK_MICR_FORMAT_REC.DJDE_FEED_PARM AS DJDE_FEED_PARM,
               V_STORE_MICR_FORMAT_DTLS_REC.MICR_COST_CNTR AS MICR_COST_CNTR,
               V_STORE_MICR_FORMAT_DTLS_REC.MICR_ROUTING_NBR AS MICR_ROUTING_NBR,
               V_STORE_MICR_FORMAT_DTLS_REC.MICR_FORMAT_ACCT_NBR AS MICR_FORMAT_ACTNBR
          FROM BANK_DEP_TICK A
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND NVL(EXPIRATION_DATE, SYSDATE + 1) > SYSDATE;

    --Below query will return the current bank account number and the bank type code for the store passed in
    --To get to the bank account, we are fetching the lead store first if the store passed in is a member
    --Also anything that got expired even a second before should not be returned back to UI
    SELECT LEAD_BANK_ACCOUNT_NBR,
           BANK_TYPE_CODE
      INTO V_BANK_ACCOUNT_NBR,
           V_BANK_TYPE_CODE
      FROM (SELECT LEAD_BANK_ACCOUNT_NBR,
                   BANK_TYPE_CODE,
                   EFFECTIVE_DATE
              FROM LEAD_BANK_CC
             WHERE LEAD_STORE_NBR = IN_COST_CENTER_CODE
               AND NVL(EXPIRATION_DATE, SYSDATE + 1) > SYSDATE
             UNION
            SELECT LEAD_BANK_ACCOUNT_NBR,
                   'M' AS BANK_TYPE_CODE,
                   EFFECTIVE_DATE
             FROM MEMBER_BANK_CC
            WHERE MEMBER_STORE_NBR = IN_COST_CENTER_CODE
              AND NVL(EXPIRATION_DATE, SYSDATE + 1) > SYSDATE
            ORDER BY EFFECTIVE_DATE DESC)
     WHERE ROWNUM < 2;

    --Below cursor will provide all the current bank account details for the store number passed
    OPEN OUT_BANK_ACCOUNT_REF_CUR FOR
        SELECT BA.*,
               V_BANK_TYPE_CODE AS BANK_TYPE_CODE
          FROM BANK_ACCOUNT BA
         WHERE BA.BANK_ACCOUNT_NBR = V_BANK_ACCOUNT_NBR;

    --Below cursor will provide all the current bank MICR format details for the store number passed
    --ordered by FORMAT_NAME
    OPEN OUT_BANK_MICR_FORMAT_REF_CUR FOR
        SELECT BMF.*
          FROM BANK_MICR_FORMAT BMF
         WHERE BMF.BANK_ACCOUNT_NBR = V_BANK_ACCOUNT_NBR
         ORDER BY FORMAT_NAME;

    --Below cursor will provide all the current bank deposit ticket order details for the store number passed
    OPEN OUT_BANK_DEP_TICKORD_REF_CUR FOR 
        SELECT *
          FROM BANK_DEP_TICKORD
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE;

    --Since we don't want to change anything from UI because of the change in store MICR format
    --we need to pass the store MICR format details along with the actual Bank Deposit Ticket details
    --The inner most query fetches the format id and bank account number for the store based on STORE_MICR_FORMAT_DTLS_FUTURE table
    OPEN OUT_BANK_DEP_TICK_FTR_REF_CUR FOR
        SELECT A.*,
               B.FORMAT_NAME AS FORMAT_NAME,
               B.DJDE_FORM_PARM AS DJDE_FORM_PARM,
               B.DJDE_FEED_PARM AS DJDE_FEED_PARM,
               B.MICR_COST_CNTR AS MICR_COST_CNTR,
               B.MICR_ROUTING_NBR AS MICR_ROUTING_NBR,
               B.MICR_FORMAT_ACCT_NBR AS MICR_FORMAT_ACTNBR
          FROM BANK_DEP_TICK_FUTURE A,
               (SELECT BMFF.FORMAT_NAME,
                       BMFF.DJDE_FORM_PARM,
                       BMFF.DJDE_FEED_PARM,
                       SMFDF.MICR_COST_CNTR,
                       SMFDF.MICR_ROUTING_NBR,
                       SMFDF.MICR_FORMAT_ACCT_NBR,
                       SMFDF.FUTURE_ID
                  FROM (SELECT *
                        --This top-N query was used to get member store MICR details if it has a default MICR assigned
                           FROM (SELECT *
                                   FROM STORE_MICR_FORMAT_DTLS_FUTURE
                                  --IN clause below makes sure we always get the passed stores MICR details
                                  --as well as it's leads storer MICR format details
                                  WHERE COST_CENTER_CODE IN (IN_COST_CENTER_CODE,
                                                             BANKING_COMMON_TOOLS.GET_FTR_LD_STR_NBR_FOR_MBR_STR(IN_COST_CENTER_CODE, NULL))
                                  --below order by clause is to make sure we get store MICR details even for
                                  --a member that doesn't have any default store MICR assigned to it in future
                                  --if member got it's own store MICR that takes precedence
                                  ORDER BY DECODE(COST_CENTER_CODE, IN_COST_CENTER_CODE, 1, 2))
                            WHERE ROWNUM < 2) SMFDF,
                       BANK_MICR_FORMAT_FUTURE BMFF
                 WHERE SMFDF.BANK_ACCOUNT_NBR = BMFF.BANK_ACCOUNT_NBR
                   AND SMFDF.MICR_FORMAT_ID   = BMFF.MICR_FORMAT_ID
                   AND SMFDF.FUTURE_ID        = BMFF.FUTURE_ID) B
         WHERE A.COST_CENTER_CODE     = IN_COST_CENTER_CODE
           AND A.FUTURE_ID            = B.FUTURE_ID(+)
         ORDER BY A.FUTURE_ID;

    --Below cursor will provide the future bank account details and store type for the store number passed
    --ordered by FUTURE_ID
    --To get to the bank account, we are fetching the lead store first if the store passed in is a member
    OPEN OUT_BANK_ACCOUNT_FTR_REF_CUR FOR
        SELECT BAF.*,
               BANK_TYPE_CODE
          FROM BANK_ACCOUNT_FUTURE BAF,
               (SELECT LEAD_BANK_ACCOUNT_NBR,
                       BANK_TYPE_CODE,
                       FUTURE_ID
                  FROM LEAD_BANK_CC_FUTURE
                 WHERE LEAD_STORE_NBR = IN_COST_CENTER_CODE
                 UNION
                SELECT LEAD_BANK_ACCOUNT_NBR,
                       'M' AS BANK_TYPE_CODE,
                       FUTURE_ID
                  FROM MEMBER_BANK_CC_FUTURE
                 WHERE MEMBER_STORE_NBR = IN_COST_CENTER_CODE) S
         WHERE BAF.BANK_ACCOUNT_NBR = S.LEAD_BANK_ACCOUNT_NBR
           AND BAF.FUTURE_ID        = S.FUTURE_ID
         ORDER BY BAF.FUTURE_ID;

    --Below cursor will provide all the future bank MICR format details for the store number passed
    --ordered by FUTURE_ID and FORMAT_NAME
    --To get to the bank account, we are fetching the lead store first if the store passed in is a member
    OPEN OUT_BANK_MICR_FRMT_FTR_REF_CUR FOR
        SELECT BMFF.*
          FROM BANK_MICR_FORMAT_FUTURE BMFF,
               (SELECT LEAD_BANK_ACCOUNT_NBR,
                       FUTURE_ID
                  FROM LEAD_BANK_CC_FUTURE
                 WHERE LEAD_STORE_NBR = IN_COST_CENTER_CODE
                 UNION
                SELECT LEAD_BANK_ACCOUNT_NBR,
                       FUTURE_ID
                  FROM MEMBER_BANK_CC_FUTURE
                 WHERE MEMBER_STORE_NBR = IN_COST_CENTER_CODE) S
         WHERE BMFF.BANK_ACCOUNT_NBR = S.LEAD_BANK_ACCOUNT_NBR
           AND BMFF.FUTURE_ID        = S.FUTURE_ID
         ORDER BY BMFF.FUTURE_ID, BMFF.FORMAT_NAME;

    --Below cursor will provide all the future bank deposit ticket order details for the store number passed
    --ordered by FUTURE_ID
    OPEN OUT_BANK_DEP_TKORD_FTR_REF_CUR FOR
        SELECT *
          FROM BANK_DEP_TICKORD_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
         ORDER BY FUTURE_ID;
END DEPOSIT_TICKET_MNTNC_UI_SP;

PROCEDURE BUILD_TABLE_TYPES(
/******************************************************************************
This procedure is intended to build all the table types from input xml
for this process

Created : 07/17/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
    IN_XML                         IN     CLOB,
    O_BANK_DEP_TICK_REC               OUT BANK_DEP_TICK%ROWTYPE,
    O_BANK_DEP_TICK_FUTURE_REC        OUT BANK_DEP_TICK_FUTURE%ROWTYPE,
    O_MICR_FORMAT_ID                  OUT NUMBER)
IS
    V_XML_BANK_DEP_TICK_FRAG        CLOB;
    V_ROW_DATA                      XMLTYPE := SYS.XMLTYPE(IN_XML);
BEGIN
    IF (V_ROW_DATA.EXISTSNODE('/BANK_DEP_TICK_UI/BANK_DEP_TICK') = 1) THEN --Single Record
        V_XML_BANK_DEP_TICK_FRAG := V_ROW_DATA.EXTRACT('/BANK_DEP_TICK_UI/BANK_DEP_TICK').GETCLOBVAL();
    END IF;
    IF V_XML_BANK_DEP_TICK_FRAG IS NOT NULL  THEN
        IF SYS.XMLTYPE(V_XML_BANK_DEP_TICK_FRAG).EXISTSNODE('/BANK_DEP_TICK/FUTURE_ID/text()') = 1 THEN
            TABLE_IU_PKG.BANK_DEP_TICK_FTR_ROWTYPE_SP('BANK_DEP_TICK_FUTURE',
                                                      REPLACE(V_XML_BANK_DEP_TICK_FRAG,'BANK_DEP_TICK>','BANK_DEP_TICK_FUTURE>'),
                                                      O_BANK_DEP_TICK_FUTURE_REC);
        ELSE
            TABLE_IU_PKG.BANK_DEP_TICK_ROWTYPE_SP('BANK_DEP_TICK',
                                                  V_XML_BANK_DEP_TICK_FRAG,
                                                  O_BANK_DEP_TICK_REC);
        END IF;
        IF (V_ROW_DATA.EXISTSNODE('/BANK_DEP_TICK_UI/BANK_DEP_TICK/MICR_FORMAT_ID/text()') = 1) THEN
            O_MICR_FORMAT_ID := TO_NUMBER(V_ROW_DATA.EXTRACT('/BANK_DEP_TICK_UI/BANK_DEP_TICK/MICR_FORMAT_ID/text()').GETCLOBVAL());
        END IF;
    END IF;
EXCEPTION
    WHEN OTHERS THEN                        
        ERRPKG.RAISE_ERR(SQLCODE, 'BUILD_TABLE_TYPES ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END BUILD_TABLE_TYPES;

FUNCTION IS_FORMAT_CHANGED(
/******************************************************************************
This function will check if the format is changed or not and return Y/N accordingly

Created : 08/21/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE      IN     VARCHAR2,
IN_BANK_ACCOUNT_NBR      IN     VARCHAR2,
IN_FUTURE_ID             IN     NUMBER,
IN_MICR_FORMAT_ID        IN     NUMBER) RETURN VARCHAR2
IS
    V_STORE_MICR_FORMAT_DTLS_REC   STORE_MICR_FORMAT_DTLS%ROWTYPE;
    V_STR_MICR_FORMAT_DTLS_FTR_REC STORE_MICR_FORMAT_DTLS_FUTURE%ROWTYPE;
    V_MICR_FORMAT_ID               NUMBER;
    V_BANK_ACCOUNT_NBR             VARCHAR2(20);
    V_RETURN_VAL                   VARCHAR2(1) := 'N';
BEGIN
    IF IN_FUTURE_ID IS NULL THEN
        V_STORE_MICR_FORMAT_DTLS_REC := BANKING_COMMON_TOOLS.GET_STORE_MICR_FORMAT_DTLS_REC(IN_COST_CENTER_CODE);
        V_BANK_ACCOUNT_NBR := V_STORE_MICR_FORMAT_DTLS_REC.BANK_ACCOUNT_NBR;
        V_MICR_FORMAT_ID   := NVL(V_STORE_MICR_FORMAT_DTLS_REC.MICR_FORMAT_ID, 0);
    ELSE
        V_STR_MICR_FORMAT_DTLS_FTR_REC := BANKING_COMMON_TOOLS.GET_STR_MICR_FRMT_DTLS_FTR_REC(IN_COST_CENTER_CODE, IN_FUTURE_ID);
        V_BANK_ACCOUNT_NBR := V_STR_MICR_FORMAT_DTLS_FTR_REC.BANK_ACCOUNT_NBR;
        V_MICR_FORMAT_ID   := NVL(V_STR_MICR_FORMAT_DTLS_FTR_REC.MICR_FORMAT_ID, 0);
    END IF;
    IF NVL(IN_MICR_FORMAT_ID, -1) <> V_MICR_FORMAT_ID
       OR IN_BANK_ACCOUNT_NBR <> V_BANK_ACCOUNT_NBR THEN
        V_RETURN_VAL := 'Y';
    END IF;
    RETURN V_RETURN_VAL;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VAL;
END IS_FORMAT_CHANGED;

PROCEDURE VALIDATE_AND_GET_FORMAT_VALUES(
/******************************************************************************
This procedure will check if the format passed and the actual values support
each other and throw error (or) return calcualted values

Created : 08/21/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_BANK_ACCOUNT_NBR   IN     VARCHAR2,
IN_ROUTING_NBR        IN     VARCHAR2,
IN_COST_CENTER_CODE   IN     VARCHAR2,
IN_MICR_FORMAT_ACTNBR IN     VARCHAR2,
IN_MICR_ROUTING_NBR   IN     VARCHAR2,
IN_MICR_COST_CNTR     IN     VARCHAR2,
OUT_MICR_FORMAT_ACTNBR   OUT VARCHAR2,
OUT_MICR_ROUTING_NBR     OUT VARCHAR2,
OUT_MICR_COST_CNTR       OUT VARCHAR2)
IS
    micr_format_conversion         EXCEPTION;
BEGIN
    IF (IN_ROUTING_NBR IS NOT NULL AND LENGTH(REGEXP_REPLACE(IN_ROUTING_NBR, '[^0-9]+')) <> LENGTH(REGEXP_REPLACE(IN_MICR_ROUTING_NBR, '[^X]+')))
       OR LENGTH(REGEXP_REPLACE(IN_BANK_ACCOUNT_NBR, '[^0-9]+')) <> LENGTH(REGEXP_REPLACE(IN_MICR_FORMAT_ACTNBR, '[^X]+'))
       OR LENGTH(REGEXP_REPLACE(IN_MICR_COST_CNTR, '[^X]+')) <> 4 THEN
        RAISE micr_format_conversion;
    END IF;
    OUT_MICR_FORMAT_ACTNBR := CONVERT_FORMAT_TO_VALUE(IN_MICR_FORMAT_ACTNBR, REGEXP_REPLACE(IN_BANK_ACCOUNT_NBR, '[^0-9]+'));
    OUT_MICR_ROUTING_NBR   := CONVERT_FORMAT_TO_VALUE(IN_MICR_ROUTING_NBR, REGEXP_REPLACE(IN_ROUTING_NBR, '[^0-9]+'));
    OUT_MICR_COST_CNTR     := CONVERT_FORMAT_TO_VALUE(IN_MICR_COST_CNTR, SUBSTR(IN_COST_CENTER_CODE, 3));
EXCEPTION
    WHEN micr_format_conversion THEN
        ERRPKG.RAISE_ERR(errnums.en_micr_format_conversion,
                         'VALIDATE_AND_GET_FORMAT_VALUES',
                         'Format selected does not support the actual bank account/routing number values');
    WHEN OTHERS THEN
        NULL;
END VALIDATE_AND_GET_FORMAT_VALUES;

PROCEDURE DEPOSIT_TKT_CURRENT_UPSERT_SP( 
/******************************************************************************
This procedure is intended to update following table used in the
Deposit Ticket Maintenance Window that are current records
    Tables: 
       BANK_DEP_TICK

Created : 08/21/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
    IN_BANK_DEP_TICK_REC  IN     BANK_DEP_TICK%ROWTYPE,
    IN_MICR_FORMAT_ID     IN     NUMBER)
IS
    V_STORE_MICR_FORMAT_DTLS_REC STORE_MICR_FORMAT_DTLS%ROWTYPE;
    V_BANK_MICR_FORMAT_REC       BANK_MICR_FORMAT%ROWTYPE;
    V_BANK_DEP_TICK_HIST_REC     BANK_DEP_TICK%ROWTYPE;
    V_BANK_DEP_TICK_REC          BANK_DEP_TICK%ROWTYPE := IN_BANK_DEP_TICK_REC;    
    V_BANK_ACCOUNT_REC           BANK_ACCOUNT%ROWTYPE;
    V_EXPIRATION_DATE            DATE;
    V_PROC_NAME                  VARCHAR2(30) := 'DEPOSIT_TKT_CURRENT_UPSERT_SP';
BEGIN
    BEGIN
        SELECT *
          INTO V_BANK_DEP_TICK_HIST_REC
          FROM BANK_DEP_TICK
         WHERE COST_CENTER_CODE = V_BANK_DEP_TICK_REC.COST_CENTER_CODE;
        TABLE_IU_PKG.BANK_DEP_TICK_HIST_I_SP(V_BANK_DEP_TICK_HIST_REC);
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    V_BANK_DEP_TICK_REC.EFFECTIVE_DATE  := LEAST(NVL(V_BANK_DEP_TICK_REC.EXPIRATION_DATE, SYSDATE), SYSDATE);
    TABLE_IU_PKG.BANK_DEP_TICK_I_SP(V_BANK_DEP_TICK_REC);
    IF IS_FORMAT_CHANGED(V_BANK_DEP_TICK_REC.COST_CENTER_CODE,
                         V_BANK_DEP_TICK_REC.BANK_ACCOUNT_NBR,
                         NULL,
                         IN_MICR_FORMAT_ID) = 'Y' THEN
        BEGIN
            SELECT *
              INTO V_STORE_MICR_FORMAT_DTLS_REC
              FROM STORE_MICR_FORMAT_DTLS
             WHERE COST_CENTER_CODE = V_BANK_DEP_TICK_REC.COST_CENTER_CODE;
            V_EXPIRATION_DATE := V_STORE_MICR_FORMAT_DTLS_REC.EXPIRATION_DATE;
            TABLE_IU_PKG.STR_MICR_FRMT_DTLS_HIST_I_SP(V_STORE_MICR_FORMAT_DTLS_REC);
        EXCEPTION
            WHEN OTHERS THEN
                NULL;
        END;
        IF IN_MICR_FORMAT_ID IS NOT NULL THEN --there is no new format, expire the old record and don't update anything else
            V_BANK_MICR_FORMAT_REC := BANKING_COMMON_TOOLS.GET_STORE_BANK_MICR_FORMAT_REC(V_BANK_DEP_TICK_REC.BANK_ACCOUNT_NBR,
                                                                                          IN_MICR_FORMAT_ID);
            V_BANK_ACCOUNT_REC := BANKING_COMMON_TOOLS.GET_BANK_ACCOUNT_REC(V_BANK_DEP_TICK_REC.BANK_ACCOUNT_NBR);
            V_STORE_MICR_FORMAT_DTLS_REC.COST_CENTER_CODE := V_BANK_DEP_TICK_REC.COST_CENTER_CODE;
            V_STORE_MICR_FORMAT_DTLS_REC.BANK_ACCOUNT_NBR := V_BANK_DEP_TICK_REC.BANK_ACCOUNT_NBR;
            VALIDATE_AND_GET_FORMAT_VALUES(V_BANK_DEP_TICK_REC.BANK_ACCOUNT_NBR,
                                           V_BANK_ACCOUNT_REC.ROUTING_NBR,
                                           V_BANK_DEP_TICK_REC.COST_CENTER_CODE,
                                           V_BANK_MICR_FORMAT_REC.MICR_FORMAT_ACTNBR,
                                           V_BANK_MICR_FORMAT_REC.MICR_ROUTING_NBR,
                                           V_BANK_MICR_FORMAT_REC.MICR_COST_CNTR,
                                           V_STORE_MICR_FORMAT_DTLS_REC.MICR_FORMAT_ACCT_NBR, --out
                                           V_STORE_MICR_FORMAT_DTLS_REC.MICR_ROUTING_NBR, --out
                                           V_STORE_MICR_FORMAT_DTLS_REC.MICR_COST_CNTR); --out
            V_STORE_MICR_FORMAT_DTLS_REC.MICR_FORMAT_ID  := IN_MICR_FORMAT_ID;
            V_STORE_MICR_FORMAT_DTLS_REC.EFFECTIVE_DATE  := SYSDATE;
            V_STORE_MICR_FORMAT_DTLS_REC.EXPIRATION_DATE := V_EXPIRATION_DATE;
            TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_I_SP(V_STORE_MICR_FORMAT_DTLS_REC);
        ELSE
            IF V_STORE_MICR_FORMAT_DTLS_REC.COST_CENTER_CODE IS NOT NULL THEN
                TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_D_SP(V_STORE_MICR_FORMAT_DTLS_REC);
            END IF;
        END IF;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME || ' ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END DEPOSIT_TKT_CURRENT_UPSERT_SP;

PROCEDURE EXPIRE_PREV_CUR_DEPOSIT_DTLS(
/*******************************************************************************
    This procedure is intended to check and expire previous current deposit details records
    before inserting new record

Created : 08/24/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE IN     VARCHAR2,
IN_EFFECTIVE_DATE   IN     DATE)
IS
    CURSOR bank_dep_tick_cur IS
        SELECT *
          FROM BANK_DEP_TICK
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EFFECTIVE_DATE  <  IN_EFFECTIVE_DATE
           AND EXPIRATION_DATE IS NULL;
    CURSOR bank_dep_tickord_cur IS
        SELECT *
          FROM BANK_DEP_TICKORD
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EFFECTIVE_DATE  <  IN_EFFECTIVE_DATE
           AND EXPIRATION_DATE IS NULL;
    CURSOR str_micr_format_dtls_cur IS
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EFFECTIVE_DATE  <  IN_EFFECTIVE_DATE
           AND EXPIRATION_DATE IS NULL;
    V_PROC_NAME                VARCHAR2(30) := 'EXPIRE_PREV_CUR_DEPOSIT_DTLS';
    V_EXPIRE_DATE              DATE := IN_EFFECTIVE_DATE - INTERVAL '1' SECOND;
BEGIN
    FOR rec IN bank_dep_tick_cur LOOP
        rec.EXPIRATION_DATE := GREATEST(rec.EFFECTIVE_DATE, V_EXPIRE_DATE);
        TABLE_IU_PKG.BANK_DEP_TICK_I_SP(rec);
    END LOOP;
    FOR rec IN bank_dep_tickord_cur LOOP
        rec.EXPIRATION_DATE := GREATEST(rec.EFFECTIVE_DATE, V_EXPIRE_DATE);
        TABLE_IU_PKG.BANK_DEP_TICKORD_I_SP(rec);
    END LOOP;    
    FOR rec IN str_micr_format_dtls_cur LOOP
        rec.EXPIRATION_DATE := GREATEST(rec.EFFECTIVE_DATE, V_EXPIRE_DATE);
        TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_I_SP(rec);
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME, SUBSTR(SQLERRM,1,500));
END EXPIRE_PREV_CUR_DEPOSIT_DTLS;

PROCEDURE EXPIRE_PREV_FTR_DEPOSIT_DTLS(
/*******************************************************************************
    This procedure is intended to check and expire previous future deposit details records
    before inserting new record

Created : 08/24/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE IN     VARCHAR2,
IN_EFFECTIVE_DATE   IN     DATE)
IS
    CURSOR bank_dep_tick_future_cur IS
        SELECT *
          FROM BANK_DEP_TICK_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EFFECTIVE_DATE  <  IN_EFFECTIVE_DATE
           AND EXPIRATION_DATE IS NULL;
    CURSOR bank_dep_tickord_future_cur IS
        SELECT *
          FROM BANK_DEP_TICKORD_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EFFECTIVE_DATE  <  IN_EFFECTIVE_DATE
           AND EXPIRATION_DATE IS NULL;           
    CURSOR str_micr_format_dtls_ftr_cur IS
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EFFECTIVE_DATE  <  IN_EFFECTIVE_DATE
           AND EXPIRATION_DATE IS NULL;
    V_PROC_NAME                VARCHAR2(30) := 'EXPIRE_PREV_FTR_DEPOSIT_DTLS';
    V_EXPIRE_DATE              DATE := IN_EFFECTIVE_DATE - INTERVAL '1' SECOND;
BEGIN
    FOR rec IN bank_dep_tick_future_cur LOOP
        rec.EXPIRATION_DATE := GREATEST(rec.EFFECTIVE_DATE, V_EXPIRE_DATE);
        TABLE_IU_PKG.BANK_DEP_TICK_FUTURE_I_SP(rec);
    END LOOP;
    FOR rec IN bank_dep_tickord_future_cur LOOP
        rec.EXPIRATION_DATE := GREATEST(rec.EFFECTIVE_DATE, V_EXPIRE_DATE);
        TABLE_IU_PKG.BANK_DEP_TICKORD_FUTURE_I_SP(rec);
    END LOOP;
    FOR rec IN str_micr_format_dtls_ftr_cur LOOP
        rec.EXPIRATION_DATE := GREATEST(rec.EFFECTIVE_DATE, V_EXPIRE_DATE);
        TABLE_IU_PKG.STR_MICR_FORMAT_DTLS_FTR_I_SP(rec);
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME, SUBSTR(SQLERRM,1,500));
END EXPIRE_PREV_FTR_DEPOSIT_DTLS;

PROCEDURE EXPIRE_PREVIOUS_DEP_TICK_DTLS(
/*******************************************************************************
    This procedure is intended to check and expire previous deposit details records
    before inserting new record

Created : 08/24/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE IN     VARCHAR2,
IN_EFFECTIVE_DATE   IN     DATE)
IS
    V_PROC_NAME                VARCHAR2(30) := 'EXPIRE_PREVIOUS_DEP_TICK_DTLS';
BEGIN
    EXPIRE_PREV_CUR_DEPOSIT_DTLS(IN_COST_CENTER_CODE, IN_EFFECTIVE_DATE);
    EXPIRE_PREV_FTR_DEPOSIT_DTLS(IN_COST_CENTER_CODE, IN_EFFECTIVE_DATE);
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME, SUBSTR(SQLERRM,1,500));
END EXPIRE_PREVIOUS_DEP_TICK_DTLS;

PROCEDURE DEPOSIT_TKT_FUTURE_UPSERT_SP( 
/******************************************************************************
This procedure is intended to update following table used in the
Deposit Ticket Maintenance Window that are future records
    Tables: 
       BANK_DEP_TICK

Created : 08/24/2015 jxc517 CCN Project....
Changed : 10/29/2015 nxk927 CCN Project.... 
          DEP_TKTS_ONHAND_QTY start with 0
          YTD_DEP_TKTS_ORDERED_QTY start with 0
*******************************************************************************/
    IN_BANK_DEP_TICK_FUTURE_REC  IN     BANK_DEP_TICK_FUTURE%ROWTYPE,
    IN_MICR_FORMAT_ID            IN     NUMBER)
IS
    V_STR_MICR_FORMAT_DTLS_FTR_REC STORE_MICR_FORMAT_DTLS_FUTURE%ROWTYPE;
    V_BANK_MICR_FORMAT_FUTURE_REC  BANK_MICR_FORMAT_FUTURE%ROWTYPE;
    V_BANK_ACCOUNT_FUTURE_REC      BANK_ACCOUNT_FUTURE%ROWTYPE;
    V_BANK_DEP_TICK_FUTURE_REC     BANK_DEP_TICK_FUTURE%ROWTYPE := IN_BANK_DEP_TICK_FUTURE_REC;
    V_PROC_NAME                    VARCHAR2(30) := 'DEPOSIT_TKT_FUTURE_UPSERT_SP';
BEGIN
   EXPIRE_PREVIOUS_DEP_TICK_DTLS(V_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE, V_BANK_DEP_TICK_FUTURE_REC.EFFECTIVE_DATE);
   --Future DEP_TKTS_ONHAND_QTY and YTD_DEP_TKTS_ORDERED_QTY always reset to zero.
   V_BANK_DEP_TICK_FUTURE_REC.DEP_TKTS_ONHAND_QTY       := '0'; 
   V_BANK_DEP_TICK_FUTURE_REC.YTD_DEP_TKTS_ORDERED_QTY  := '0';
    TABLE_IU_PKG.BANK_DEP_TICK_FUTURE_I_SP(V_BANK_DEP_TICK_FUTURE_REC);
    IF IS_FORMAT_CHANGED(V_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE,
                         V_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR,
                         V_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID,
                         IN_MICR_FORMAT_ID) = 'Y' THEN
        IF IN_MICR_FORMAT_ID IS NOT NULL THEN
            V_BANK_MICR_FORMAT_FUTURE_REC := BANKING_COMMON_TOOLS.GET_STR_BANK_MICR_FRMT_FTR_REC(V_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR,
                                                                                                 IN_MICR_FORMAT_ID,
                                                                                                 V_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID);
            BEGIN
                SELECT *
                  INTO V_BANK_ACCOUNT_FUTURE_REC
                  FROM BANK_ACCOUNT_FUTURE
                 WHERE BANK_ACCOUNT_NBR = V_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR
                   AND FUTURE_ID        = V_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID;
            EXCEPTION
                WHEN OTHERS THEN
                    NULL;
            END;
            V_STR_MICR_FORMAT_DTLS_FTR_REC.COST_CENTER_CODE := V_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE;
            V_STR_MICR_FORMAT_DTLS_FTR_REC.BANK_ACCOUNT_NBR := V_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR;
            VALIDATE_AND_GET_FORMAT_VALUES(V_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR,
                                           V_BANK_ACCOUNT_FUTURE_REC.ROUTING_NBR,
                                           V_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE,
                                           V_BANK_MICR_FORMAT_FUTURE_REC.MICR_FORMAT_ACTNBR,
                                           V_BANK_MICR_FORMAT_FUTURE_REC.MICR_ROUTING_NBR,
                                           V_BANK_MICR_FORMAT_FUTURE_REC.MICR_COST_CNTR,
                                           V_STR_MICR_FORMAT_DTLS_FTR_REC.MICR_FORMAT_ACCT_NBR, --out
                                           V_STR_MICR_FORMAT_DTLS_FTR_REC.MICR_ROUTING_NBR, --out
                                           V_STR_MICR_FORMAT_DTLS_FTR_REC.MICR_COST_CNTR); --out
            V_STR_MICR_FORMAT_DTLS_FTR_REC.EFFECTIVE_DATE   := V_BANK_DEP_TICK_FUTURE_REC.EFFECTIVE_DATE;
            V_STR_MICR_FORMAT_DTLS_FTR_REC.EXPIRATION_DATE  := V_BANK_DEP_TICK_FUTURE_REC.EXPIRATION_DATE;
            V_STR_MICR_FORMAT_DTLS_FTR_REC.MICR_FORMAT_ID   := IN_MICR_FORMAT_ID;
            V_STR_MICR_FORMAT_DTLS_FTR_REC.FUTURE_ID        := V_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID;
            TABLE_IU_PKG.STR_MICR_FORMAT_DTLS_FTR_I_SP(V_STR_MICR_FORMAT_DTLS_FTR_REC);
        ELSE
            BEGIN
                SELECT *
                  INTO V_STR_MICR_FORMAT_DTLS_FTR_REC
                  FROM STORE_MICR_FORMAT_DTLS_FUTURE
                 WHERE COST_CENTER_CODE = V_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE
                   AND FUTURE_ID        = V_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID;
            EXCEPTION
                WHEN OTHERS THEN
                    NULL;
            END;
            IF V_STR_MICR_FORMAT_DTLS_FTR_REC.COST_CENTER_CODE IS NOT NULL THEN
                TABLE_IU_PKG.STR_MICR_FORMAT_DTLS_FTR_D_SP(V_STR_MICR_FORMAT_DTLS_FTR_REC);
            END IF;
        END IF;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME || ' ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END DEPOSIT_TKT_FUTURE_UPSERT_SP;

PROCEDURE DEPOSIT_TKT_MNTNC_UI_UPSERT_SP( 
/******************************************************************************
	This procedure performs the core process for Deposit Ticket Maintenance Window

Created : 07/14/2015 jxc517 CCN Project....
Changed : 08/13/2015 nxk927 CCN Project....
          Removed trunc to accept the time stamp
Changed : 10/27/2015 jxc517 CCN Project....
          For current records we need to push current into history and insert a new
          record with SYSDATE
          For future records we need to use the data that is passed back from UI
*******************************************************************************/
    IN_ROW_DATA  IN  CLOB)
IS
    V_BANK_DEP_TICK_FUTURE_REC      BANK_DEP_TICK_FUTURE%ROWTYPE;
    V_BANK_DEP_TICK_REC             BANK_DEP_TICK%ROWTYPE;
    V_MICR_FORMAT_ID                NUMBER := NULL;
BEGIN
    
    BUILD_TABLE_TYPES(IN_ROW_DATA,
                      V_BANK_DEP_TICK_REC,
                      V_BANK_DEP_TICK_FUTURE_REC,
                      V_MICR_FORMAT_ID);
    V_BANK_DEP_TICK_REC.EFFECTIVE_DATE := SYSDATE;
    BUSINESS_RULES_PKG.DEPOSIT_TICKET_MNTNC_BR_SP(V_BANK_DEP_TICK_REC,
                                                  V_BANK_DEP_TICK_FUTURE_REC);
    IF V_BANK_DEP_TICK_REC.COST_CENTER_CODE IS NOT NULL THEN --Current Details
        DEPOSIT_TKT_CURRENT_UPSERT_SP(V_BANK_DEP_TICK_REC, V_MICR_FORMAT_ID);
    END IF;
    IF V_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE IS NOT NULL THEN --Future Details
        DEPOSIT_TKT_FUTURE_UPSERT_SP(V_BANK_DEP_TICK_FUTURE_REC, V_MICR_FORMAT_ID);
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, 'DEPOSIT_TKT_MNTNC_UI_UPSERT_SP ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END DEPOSIT_TKT_MNTNC_UI_UPSERT_SP;

PROCEDURE GET_BANK_MICR_FORMAT_FTR_REC(
/*******************************************************************************
This procedure is get the bank micr format future recrod based on previous bank account
and format id combinatin. If it is not found it builds one

Created : 08/25/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE          IN     VARCHAR2,
IN_BANK_ACCOUNT_NBR          IN     VARCHAR2,
IN_FUTURE_ID                 IN     NUMBER,
IN_EFFECTIVE_DATE            IN     DATE,
OUT_BANK_MICR_FORMAT_FTR_REC    OUT BANK_MICR_FORMAT_FUTURE%ROWTYPE)
IS
    V_STR_MICR_FRMT_DTLS_PREV_REC  STORE_MICR_FORMAT_DTLS%ROWTYPE;
    V_BANK_MICR_FRMT_FTR_PREV_REC  BANK_MICR_FORMAT_FUTURE%ROWTYPE;
    V_BANK_MICR_FORMAT_FUTURE_REC  BANK_MICR_FORMAT_FUTURE%ROWTYPE;
    V_BANK_ACCOUNT_FUTURE_REC      BANK_ACCOUNT_FUTURE%ROWTYPE;
    V_MICR_FORMAT_ID               NUMBER := NULL;
BEGIN
    V_STR_MICR_FRMT_DTLS_PREV_REC := BANKING_COMMON_TOOLS.GET_STORE_MICR_FORMAT_DTLS_REC(IN_COST_CENTER_CODE);
    IF V_STR_MICR_FRMT_DTLS_PREV_REC.COST_CENTER_CODE IS NOT NULL THEN
        BEGIN
            SELECT BANK_ACCOUNT_NBR,
                   FORMAT_NAME,
                   DJDE_FORM_PARM,
                   DJDE_FEED_PARM,
                   MICR_COST_CNTR,
                   MICR_ROUTING_NBR,
                   MICR_FORMAT_ACTNBR,
                   EFFECTIVE_DATE,
                   EXPIRATION_DATE,
                   LAST_MAINTENANCE_DATE,
                   LAST_MAINT_USER_ID,
                   UPDATE_DATE,
                   LAST_UPD_USER_ID,
                   NULL FUTURE_ID,
                   MICR_FORMAT_ID
              INTO V_BANK_MICR_FRMT_FTR_PREV_REC
              FROM BANK_MICR_FORMAT
             WHERE BANK_ACCOUNT_NBR = V_STR_MICR_FRMT_DTLS_PREV_REC.BANK_ACCOUNT_NBR
               AND MICR_FORMAT_ID   = V_STR_MICR_FRMT_DTLS_PREV_REC.MICR_FORMAT_ID;
        EXCEPTION
            WHEN OTHERS THEN
                NULL;
        END;
        V_MICR_FORMAT_ID := BANKING_COMMON_TOOLS.GET_MICR_FRMT_ID_FR_BA_FRMT_NM(IN_BANK_ACCOUNT_NBR,
                                                                                V_BANK_MICR_FRMT_FTR_PREV_REC.FORMAT_NAME,
                                                                                IN_FUTURE_ID);
        IF V_MICR_FORMAT_ID IS NOT NULL THEN --a MICR with that format name already exists for this new bank account number
            V_BANK_MICR_FORMAT_FUTURE_REC := BANKING_COMMON_TOOLS.GET_STR_BANK_MICR_FRMT_FTR_REC(IN_BANK_ACCOUNT_NBR,
                                                                                                 V_MICR_FORMAT_ID,
                                                                                                 IN_FUTURE_ID);
        ELSE --a MICR with that format name does not exist for this new bank account number, so build and insert one
            V_BANK_MICR_FORMAT_FUTURE_REC := V_BANK_MICR_FRMT_FTR_PREV_REC;
            V_BANK_MICR_FORMAT_FUTURE_REC.BANK_ACCOUNT_NBR      := IN_BANK_ACCOUNT_NBR;
            V_BANK_MICR_FORMAT_FUTURE_REC.FUTURE_ID             := IN_FUTURE_ID;
            V_BANK_MICR_FORMAT_FUTURE_REC.MICR_FORMAT_ID        := BANKING_COMMON_TOOLS.GET_NEXT_MICR_FORMAT_ID(IN_BANK_ACCOUNT_NBR, 'F');
            V_BANK_MICR_FORMAT_FUTURE_REC.EFFECTIVE_DATE        := IN_EFFECTIVE_DATE;
            V_BANK_ACCOUNT_FUTURE_REC := BANKING_COMMON_TOOLS.GET_BANK_ACCOUNT_FUTURE_REC(IN_BANK_ACCOUNT_NBR, IN_FUTURE_ID);
            V_BANK_MICR_FORMAT_FUTURE_REC.EXPIRATION_DATE       := V_BANK_ACCOUNT_FUTURE_REC.EXPIRATION_DATE;
            V_BANK_MICR_FORMAT_FUTURE_REC.LAST_MAINTENANCE_DATE := TRUNC(SYSDATE);
            --V_BANK_MICR_FORMAT_FUTURE_REC.LAST_MAINT_USER_ID    := 'CODBLT';
            V_BANK_MICR_FORMAT_FUTURE_REC.UPDATE_DATE           := TRUNC(SYSDATE);
            --V_BANK_MICR_FORMAT_FUTURE_REC.LAST_UPD_USER_ID      := 'CODEBLT';
            INSERT INTO BANK_MICR_FORMAT_FUTURE VALUES V_BANK_MICR_FORMAT_FUTURE_REC;
        END IF;
        OUT_BANK_MICR_FORMAT_FTR_REC := V_BANK_MICR_FORMAT_FUTURE_REC;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END GET_BANK_MICR_FORMAT_FTR_REC;

PROCEDURE INSERT_BANK_DEPOSIT_DTLS_FTR(
/*******************************************************************************
This procedure is intended to build the STORE_MICR_FORMAT_DTLS_FUTURE, 
BANK_DEP_TICK_FUTURE records and insert the same

Created : 08/25/2015 jxc517 CCN Project....
Changed : 11/02/2015 nxk927 CCN Project....
          Future DEP_TKTS_ONHAND_QTY and YTD_DEP_TKTS_ORDERED_QTY always reset to zero.
*******************************************************************************/
IN_COST_CENTER_CODE     IN    VARCHAR2,
IN_BANK_ACCOUNT_NBR     IN    VARCHAR2,
IN_FUTURE_ID            IN    NUMBER,
IN_EFFECTIVE_DATE       IN    DATE,
IN_EXPIRATION_DATE      IN    DATE,
IN_BANK_TYPE_CODE       IN    VARCHAR2)
IS
    V_BANK_DEP_TICK_FTR_PREV_REC   BANK_DEP_TICK_FUTURE%ROWTYPE;
    V_BANK_MICR_FORMAT_FUTURE_REC  BANK_MICR_FORMAT_FUTURE%ROWTYPE;
    V_BANK_DEP_TICK_FUTURE_REC     BANK_DEP_TICK_FUTURE%ROWTYPE;
    V_STR_MICR_FRMT_DTLS_FTR_REC   STORE_MICR_FORMAT_DTLS_FUTURE%ROWTYPE;
    V_BANK_ACCOUNT_FUTURE_REC      BANK_ACCOUNT_FUTURE%ROWTYPE;
BEGIN
    BEGIN
        SELECT A.*,
               NULL FUTURE_ID
          INTO V_BANK_DEP_TICK_FTR_PREV_REC
          FROM BANK_DEP_TICK A
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE;
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    IF V_BANK_DEP_TICK_FTR_PREV_REC.COST_CENTER_CODE IS NOT NULL THEN
        V_BANK_DEP_TICK_FUTURE_REC := V_BANK_DEP_TICK_FTR_PREV_REC;
        V_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR          := IN_BANK_ACCOUNT_NBR;
        V_BANK_DEP_TICK_FUTURE_REC.EFFECTIVE_DATE            := IN_EFFECTIVE_DATE;
        V_BANK_DEP_TICK_FUTURE_REC.EXPIRATION_DATE           := IN_EXPIRATION_DATE;
        V_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID                 := IN_FUTURE_ID;
        V_BANK_DEP_TICK_FUTURE_REC.LAST_MAINTENANCE_DATE     := SYSDATE;
        V_BANK_DEP_TICK_FUTURE_REC.LAST_MAINT_USER_ID        := 'CODBLT';
        --Future DEP_TKTS_ONHAND_QTY and YTD_DEP_TKTS_ORDERED_QTY always reset to zero.
        V_BANK_DEP_TICK_FUTURE_REC.DEP_TKTS_ONHAND_QTY       := '0';
        V_BANK_DEP_TICK_FUTURE_REC.YTD_DEP_TKTS_ORDERED_QTY  := '0';
        TABLE_IU_PKG.BANK_DEP_TICK_FUTURE_I_SP(V_BANK_DEP_TICK_FUTURE_REC);
    END IF;
    IF NVL(IN_BANK_TYPE_CODE, 'X') <> 'M' THEN
        GET_BANK_MICR_FORMAT_FTR_REC(IN_COST_CENTER_CODE,
                                     IN_BANK_ACCOUNT_NBR,
                                     IN_FUTURE_ID,
                                     IN_EFFECTIVE_DATE,
                                     V_BANK_MICR_FORMAT_FUTURE_REC);
       IF V_BANK_MICR_FORMAT_FUTURE_REC.MICR_FORMAT_ID IS NOT NULL THEN
            V_BANK_ACCOUNT_FUTURE_REC := BANKING_COMMON_TOOLS.GET_BANK_ACCOUNT_FUTURE_REC(IN_BANK_ACCOUNT_NBR, IN_FUTURE_ID);
            V_STR_MICR_FRMT_DTLS_FTR_REC.BANK_ACCOUNT_NBR := IN_BANK_ACCOUNT_NBR;
            V_STR_MICR_FRMT_DTLS_FTR_REC.MICR_FORMAT_ID   := V_BANK_MICR_FORMAT_FUTURE_REC.MICR_FORMAT_ID;
            V_STR_MICR_FRMT_DTLS_FTR_REC.COST_CENTER_CODE := IN_COST_CENTER_CODE;
            V_STR_MICR_FRMT_DTLS_FTR_REC.EFFECTIVE_DATE   := IN_EFFECTIVE_DATE;
            V_STR_MICR_FRMT_DTLS_FTR_REC.EXPIRATION_DATE  := IN_EXPIRATION_DATE;
            V_STR_MICR_FRMT_DTLS_FTR_REC.FUTURE_ID        := IN_FUTURE_ID;
            VALIDATE_AND_GET_FORMAT_VALUES(IN_BANK_ACCOUNT_NBR,
                                           V_BANK_ACCOUNT_FUTURE_REC.ROUTING_NBR,
                                           IN_COST_CENTER_CODE,
                                           V_BANK_MICR_FORMAT_FUTURE_REC.MICR_FORMAT_ACTNBR,
                                           V_BANK_MICR_FORMAT_FUTURE_REC.MICR_ROUTING_NBR,
                                           V_BANK_MICR_FORMAT_FUTURE_REC.MICR_COST_CNTR,
                                           V_STR_MICR_FRMT_DTLS_FTR_REC.MICR_FORMAT_ACCT_NBR, --out
                                           V_STR_MICR_FRMT_DTLS_FTR_REC.MICR_ROUTING_NBR, --out
                                           V_STR_MICR_FRMT_DTLS_FTR_REC.MICR_COST_CNTR); --out
            TABLE_IU_PKG.STR_MICR_FORMAT_DTLS_FTR_I_SP(V_STR_MICR_FRMT_DTLS_FTR_REC);
        END IF;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END INSERT_BANK_DEPOSIT_DTLS_FTR;

FUNCTION GET_DEPOSIT_ORDER_SEQ_NBR(
/*******************************************************************************
This fucntion is intended to return the deposit ticket sequence for the cost center passed in

Created : 09/08/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE    IN      VARCHAR2) RETURN VARCHAR2
IS
    V_RETURN_VAL VARCHAR2(10);
BEGIN
    SELECT MAX(DEPOSIT_ORDER_SEQ_NBR)
      INTO V_RETURN_VAL
      FROM (SELECT DEPOSIT_ORDER_SEQ_NBR
              FROM BANK_DEP_TICKORD_HIST
             WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
             UNION
            SELECT DEPOSIT_ORDER_SEQ_NBR
              FROM BANK_DEP_TICKORD
             WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
             UNION
            SELECT DEPOSIT_ORDER_SEQ_NBR
              FROM BANK_DEP_TICKORD_FUTURE
             WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE);
    RETURN V_RETURN_VAL;
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END GET_DEPOSIT_ORDER_SEQ_NBR;

FUNCTION GET_DEPOSIT_TKT_FUT_ID_NBR(
/*******************************************************************************
This fucntion is intended to return the deposit ticket future id
for the cost center that has been passed in

Created : 11/03/2015 nxk927 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE    IN      VARCHAR2,
IN_FLAG                IN      VARCHAR2) RETURN VARCHAR2
IS
    V_RETURN_VAL VARCHAR2(10);
BEGIN
    IF IN_FLAG = 'C' THEN
       SELECT MAX(BANK_DEP_TICK_FTR_ID)
         INTO V_RETURN_VAL
         FROM BANK_DEP_TICKORD
        WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE;
    ELSE
       SELECT MAX(BANK_DEP_TICK_FTR_ID)
         INTO V_RETURN_VAL
         FROM BANK_DEP_TICKORD_FUTURE
        WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE;
    END IF;
    RETURN V_RETURN_VAL;
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END GET_DEPOSIT_TKT_FUT_ID_NBR;

PROCEDURE CREATE_DEPOSIT_TKT_INPUT_FILE(
/******************************************************************************
This procedure is intended to create the input deposit ticket file.
Corporate Treasury will then send the bank deposit ticket information to Linda. 
Depending on the request, either of the following will be done:
    1) Add a brand new bank account/routing number and attach store(s) to it
    2) Add a new store to an existing bank account/routing number
    3) Update existing bank account/routing number.  For example, a bank gets bought out and accounts are renumbered and/or routing number changes. 
      (Note, all of these events trigger printing of deposit tickets).

Created : 08/19/2015 jxc517 CCN Project....
Changed : 10/21/2015 nxk927 CCN Project...
          Added call to create the deposit order for future 
*******************************************************************************/
    IN_COST_CENTER IN VARCHAR2,
    IN_FUTURE_ID   IN VARCHAR2)
IS
    CURSOR main_cur IS
        SELECT BDTO.BANK_ACCOUNT_NBR,
               BDTO.COST_CENTER_CODE,
               'BDCVSW' FORM_COVER, --hard coded?
               'SHERWIN-WILLIAMS' COMPANY, --hard coded?
               ADDRESS_LINE_1 ADDRESS,
               CITY,
               STATE_CODE,
               ZIP_CODE||'-'||A.ZIP_CODE_4 ZIP,
               B.MICR_ROUTING_NBR ROUTING_NUMBER,
               B.MICR_FORMAT_ACCT_NBR ACCOUNT_NUMBER,
               B.DJDE_FORM_PARM FORM_TICKET,
               B.DJDE_FEED_PARM FEED_TICKET,
               'DEPOSIT_TICKET_'||BDTO.COST_CENTER_CODE HTML_NAME
          FROM BANK_DEP_TICKORD BDTO,
               ADDRESS_VW A,
               (SELECT SMFD.MICR_ROUTING_NBR,
                       SMFD.MICR_FORMAT_ACCT_NBR,
                       SMFD.COST_CENTER_CODE,
                       --NVL(SMFD.COST_CENTER_CODE, BANKING_COMMON_TOOLS.GET_LEAD_STORE_NBR_FOR_MBR_STR(SMFD.COST_CENTER_CODE)) COST_CENTER_CODE,
                       BMF.DJDE_FORM_PARM ,
                       BMF.DJDE_FEED_PARM 
                  FROM STORE_MICR_FORMAT_DTLS SMFD,
                       BANK_MICR_FORMAT BMF
                 WHERE SMFD.BANK_ACCOUNT_NBR = BMF.BANK_ACCOUNT_NBR
                   AND SMFD.MICR_FORMAT_ID   = BMF.MICR_FORMAT_ID) B
        WHERE BDTO.COST_CENTER_CODE          = A.COST_CENTER_CODE(+)
          AND (B.COST_CENTER_CODE            = BDTO.COST_CENTER_CODE        
             OR B.COST_CENTER_CODE           = BANKING_COMMON_TOOLS.GET_LEAD_STORE_NBR_FOR_MBR_STR(IN_COST_CENTER))
          --AND BDTO.COST_CENTER_CODE         = NVL(B.COST_CENTER_CODE, BANKING_COMMON_TOOLS.GET_LEAD_STORE_NBR_FOR_MBR_STR(B.COST_CENTER_CODE))
          AND BDTO.COST_CENTER_CODE          = IN_COST_CENTER
          AND A.EXPIRATION_DATE IS NULL;

    CURSOR main_cur_future IS
        SELECT BDTO.BANK_ACCOUNT_NBR,
               BDTO.COST_CENTER_CODE,
               'BDCVSW' FORM_COVER, --hard coded?
               'SHERWIN-WILLIAMS' COMPANY, --hard coded?
               ADDRESS_LINE_1 ADDRESS,
               CITY,
               STATE_CODE,
               ZIP_CODE||'-'||A.ZIP_CODE_4 ZIP,
               B.MICR_ROUTING_NBR ROUTING_NUMBER,
               B.MICR_FORMAT_ACCT_NBR ACCOUNT_NUMBER,
               B.DJDE_FORM_PARM FORM_TICKET,
               B.DJDE_FEED_PARM FEED_TICKET,
               'DEPOSIT_TICKET_'||BDTO.COST_CENTER_CODE HTML_NAME
          FROM BANK_DEP_TICKORD_FUTURE BDTO,
               ADDRESS_VW A,
               (SELECT SMFD.MICR_ROUTING_NBR,
                       SMFD.MICR_FORMAT_ACCT_NBR,
                       SMFD.COST_CENTER_CODE,
                       --NVL(SMFD.COST_CENTER_CODE, BANKING_COMMON_TOOLS.GET_LEAD_STORE_NBR_FOR_MBR_STR(SMFD.COST_CENTER_CODE)) COST_CENTER_CODE,
                       BMF.DJDE_FORM_PARM ,
                       BMF.DJDE_FEED_PARM 
                  FROM STORE_MICR_FORMAT_DTLS_FUTURE SMFD,
                       BANK_MICR_FORMAT_FUTURE BMF
                 WHERE SMFD.BANK_ACCOUNT_NBR = BMF.BANK_ACCOUNT_NBR
                   AND SMFD.MICR_FORMAT_ID   = BMF.MICR_FORMAT_ID
                   AND SMFD.FUTURE_ID        = BMF.FUTURE_ID) B
         WHERE BDTO.COST_CENTER_CODE         = A.COST_CENTER_CODE(+)
           AND (B.COST_CENTER_CODE           = BDTO.COST_CENTER_CODE        
             OR B.COST_CENTER_CODE           = BANKING_COMMON_TOOLS.GET_LEAD_STORE_NBR_FOR_MBR_STR(IN_COST_CENTER))
           AND BDTO.COST_CENTER_CODE         = IN_COST_CENTER
           AND BDTO.FUTURE_ID                = IN_FUTURE_ID
           AND A.EXPIRATION_DATE IS NULL;    
        
       
    PATH        	           VARCHAR2(50) := 'BANKING_DATA_FILES';
    BANK_DEPOSIT_IP_FILE_NM  VARCHAR2(50) := 'DEPOSIT_TICKET_';
                                             --||TO_CHAR(IN_DATE,'DDMONRRRR');--|| '_' ||TO_CHAR(SYSDATE,'HH24MISS');
    BANK_DEPOSIT_INPUT_FILE  UTL_FILE.FILE_TYPE;

	  V_OUT_CLOB         CLOB;
    V_COUNT            NUMBER := 0;
BEGIN
  IF IN_FUTURE_ID IS NULL THEN
    FOR rec IN main_cur LOOP
       IF rec.COST_CENTER_CODE is not null then
        BANK_DEPOSIT_INPUT_FILE := UTL_FILE.FOPEN (PATH
                                            ,BANK_DEPOSIT_IP_FILE_NM ||rec.COST_CENTER_CODE||'.txt'
                                            ,'W' --BINARY
                                            ,32767);
        V_OUT_CLOB := V_OUT_CLOB ||
                    RPAD(NVL(SUBSTR(rec.COST_CENTER_CODE, 3), ' '), 4, ' ') || --STORE-NBR (4)
                    RPAD(NVL(rec.FORM_COVER, ' '), 6, ' ') ||                  --FORM_COVER (6)
                    RPAD(NVL(rec.FORM_TICKET, ' '), 6, ' ') ||                 --FORM_TICKET (6)
                    RPAD(NVL(rec.FEED_TICKET, ' '), 5, ' ') ||                 --FEED_TICKET (5)
                    RPAD(NVL(rec.COMPANY, ' '), 26, ' ') ||                    --COMPANY (26)
                    RPAD(NVL(rec.ADDRESS, ' '), 30, ' ') ||                    --ADDRESS (30)
                    RPAD(NVL(rec.CITY, ' '), 30, ' ') ||                       --CITY (30)
                    RPAD(NVL(rec.STATE_CODE, ' '), 2, ' ') ||                  --STATE_CODE (2)
                    RPAD(NVL(rec.ZIP, ' '), 10, ' ') ||                        --ZIP (10)
                    RPAD(NVL(rec.ROUTING_NUMBER, ' '), 11, ' ') ||             --ROUTING_NUMBER (11)
                    RPAD(NVL(rec.ACCOUNT_NUMBER, ' '), 19, ' ') ||             --ACCOUNT_NUMBER (15)
                    RPAD(NVL(rec.HTML_NAME, ' '), 50, ' ')                   --HTML_NAME (50)
                    ;
       UTL_FILE.PUT_LINE(BANK_DEPOSIT_INPUT_FILE, V_OUT_CLOB, TRUE);
       UTL_FILE.FCLOSE(BANK_DEPOSIT_INPUT_FILE);
       V_OUT_CLOB := NULL;
       END IF;
    END LOOP;
  ELSE
    FOR rec IN main_cur_future LOOP
       IF rec.COST_CENTER_CODE is not null then
        BANK_DEPOSIT_INPUT_FILE := UTL_FILE.FOPEN (PATH
                                            ,BANK_DEPOSIT_IP_FILE_NM ||rec.COST_CENTER_CODE||'.txt'
                                            ,'W' --BINARY
                                            ,32767);
        V_OUT_CLOB := V_OUT_CLOB ||
                    RPAD(NVL(SUBSTR(rec.COST_CENTER_CODE, 3), ' '), 4, ' ') || --STORE-NBR (4)
                    RPAD(NVL(rec.FORM_COVER, ' '), 6, ' ') ||                  --FORM_COVER (6)
                    RPAD(NVL(rec.FORM_TICKET, ' '), 6, ' ') ||                 --FORM_TICKET (6)
                    RPAD(NVL(rec.FEED_TICKET, ' '), 5, ' ') ||                 --FEED_TICKET (5)
                    RPAD(NVL(rec.COMPANY, ' '), 26, ' ') ||                    --COMPANY (26)
                    RPAD(NVL(rec.ADDRESS, ' '), 30, ' ') ||                    --ADDRESS (30)
                    RPAD(NVL(rec.CITY, ' '), 30, ' ') ||                       --CITY (30)
                    RPAD(NVL(rec.STATE_CODE, ' '), 2, ' ') ||                  --STATE_CODE (2)
                    RPAD(NVL(rec.ZIP, ' '), 10, ' ') ||                        --ZIP (10)
                    RPAD(NVL(rec.ROUTING_NUMBER, ' '), 11, ' ') ||             --ROUTING_NUMBER (11)
                    RPAD(NVL(rec.ACCOUNT_NUMBER, ' '), 19, ' ') ||             --ACCOUNT_NUMBER (15)
                    RPAD(NVL(rec.HTML_NAME, ' '), 50, ' ')                   --HTML_NAME (50)
                    ;
       UTL_FILE.PUT_LINE(BANK_DEPOSIT_INPUT_FILE, V_OUT_CLOB, TRUE);
       UTL_FILE.FCLOSE(BANK_DEPOSIT_INPUT_FILE);
       V_OUT_CLOB := NULL;
       END IF;
    END LOOP;
END IF;    
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, 'CREATE_DEPOSIT_TKT_INPUT_FILE ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END CREATE_DEPOSIT_TKT_INPUT_FILE;

PROCEDURE PLACE_DEPOSIT_TICKET_ORDER(
/*******************************************************************************
This procedure is intended to place a deposit ticket order for the store passed in

Created : 08/31/2015 jxc517 CCN Project....
Changed : 10/20/2015 sxt410 CCN Project....
          Changed Column Name From Extract_Date To Order_Date
Changed : 10/21/2015 jxc517 CCN Project....
          Added code to re-calculate the onhand, ytd deposit tickets
        : 10/21/2015 nxk927 CCN Project...
          Added call to create the deposit order for future 
          Future DEP_TKTS_ONHAND_QTY and YTD_DEP_TKTS_ORDERED_QTY always reset to zero.
        : 11/04/2015 nxk927 CCN Project...
          Added condition to not to update the on hand quantity if the date is not current
          Removed the business rule that was not allowing order to be placed in current if future is present
          ADDED to take the standard value from bank_dep_tickoak table if sent as null
*******************************************************************************/
IN_COST_CENTER_CODE     IN     VARCHAR2,
IN_ORDERED_DATE         IN     DATE,
IN_FUTURE_ID            IN     NUMBER,
IN_USER_ID              IN     VARCHAR2)
IS
    CURSOR bank_dep_tickord_ftr_cur IS
        SELECT *
          FROM BANK_DEP_TICKORD_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND FUTURE_ID        > NVL(IN_FUTURE_ID, 0);
    V_BANK_DEP_TICKORD                 BANK_DEP_TICKORD%ROWTYPE;
    V_BANK_DEP_TICKORD_FUTURE          BANK_DEP_TICKORD_FUTURE%ROWTYPE;
    V_BANK_DEP_TICK                    BANK_DEP_TICK%ROWTYPE;
    V_BANK_DEP_TICK_FUTURE             BANK_DEP_TICK_FUTURE%ROWTYPE;
    V_NBR_DEP_TICKETS_PER_BK           BANK_DEP_TICK.NBR_DEP_TICKETS_PER_BK%TYPE;
    V_REORDER_NUMBER_BKS               BANK_DEP_TICK.REORDER_NUMBER_BKS%TYPE;
BEGIN
    IF IN_FUTURE_ID IS NULL THEN
        BEGIN
            SELECT *
              INTO V_BANK_DEP_TICK
              FROM BANK_DEP_TICK
             WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE;
        EXCEPTION
            WHEN OTHERS THEN
                NULL;
        END;
        IF V_BANK_DEP_TICK.COST_CENTER_CODE IS NOT NULL THEN
            V_BANK_DEP_TICKORD.BANK_ACCOUNT_NBR        := V_BANK_DEP_TICK.BANK_ACCOUNT_NBR;
            V_BANK_DEP_TICKORD.COST_CENTER_CODE        := V_BANK_DEP_TICK.COST_CENTER_CODE;
            V_BANK_DEP_TICKORD.BANK_DEP_TICK_FTR_ID    := NVL(GET_DEPOSIT_TKT_FUT_ID_NBR(V_BANK_DEP_TICK.COST_CENTER_CODE, 'C'),0) + 1;
            V_BANK_DEP_TICKORD.DEPOSIT_ORDER_PRIORITY  := '100';
            V_BANK_DEP_TICKORD.DEPOSIT_ORDER_STATUS    := 'P';
            V_BANK_DEP_TICKORD.DEPOSIT_ORDER_SEQ_NBR   := NVL(GET_DEPOSIT_ORDER_SEQ_NBR(V_BANK_DEP_TICK.COST_CENTER_CODE),0);
            V_BANK_DEP_TICKORD.DEPOSIT_ORDER_SEQ_NBR   := V_BANK_DEP_TICKORD.DEPOSIT_ORDER_SEQ_NBR + 1;
            V_BANK_DEP_TICKORD.EFFECTIVE_DATE          := V_BANK_DEP_TICK.EFFECTIVE_DATE;
            V_BANK_DEP_TICKORD.EXPIRATION_DATE         := V_BANK_DEP_TICK.EXPIRATION_DATE;
            V_BANK_DEP_TICKORD.LAST_MAINTENANCE_DATE   := TRUNC(SYSDATE);
            V_BANK_DEP_TICKORD.LAST_MAINT_USER_ID      := IN_USER_ID;
            V_BANK_DEP_TICKORD.ORDER_DATE              := IN_ORDERED_DATE;
            V_BANK_DEP_TICKORD.EXTRACTED_USER_ID       := IN_USER_ID;
            TABLE_IU_PKG.BANK_DEP_TICKORD_I_SP(V_BANK_DEP_TICKORD);
            CREATE_DEPOSIT_TKT_INPUT_FILE(IN_COST_CENTER_CODE,NULL);
            RSA_WEB_SERVICES_PKG.CREATE_DEPOSIT_TICKET_ORDER(V_BANK_DEP_TICK);
            TABLE_IU_PKG.BANK_DEP_TICK_HIST_I_SP(V_BANK_DEP_TICK);
            V_NBR_DEP_TICKETS_PER_BK                   := BANKING_COMMON_TOOLS.GET_STANDARD_VAL_DEPOSIT_ORD('NBR_DEP_TICKETS_PER_BK');
            V_REORDER_NUMBER_BKS                       := BANKING_COMMON_TOOLS.GET_STANDARD_VAL_DEPOSIT_ORD('REORDER_NUMBER_BKS');
            V_BANK_DEP_TICK.NBR_DEP_TICKETS_PER_BK     := NVL(V_BANK_DEP_TICK.NBR_DEP_TICKETS_PER_BK,V_NBR_DEP_TICKETS_PER_BK);
            V_BANK_DEP_TICK.REORDER_NUMBER_BKS         := NVL(V_BANK_DEP_TICK.REORDER_NUMBER_BKS,V_REORDER_NUMBER_BKS);
            --DEP_TKTS_ONHAND_QTY will depend on book quantity. If we need different quantity we have to update the book quantity first and save it. Then place the order.
            IF IN_ORDERED_DATE > TRUNC(SYSDATE) THEN
               V_BANK_DEP_TICK.DEP_TKTS_ONHAND_QTY      := V_BANK_DEP_TICK.DEP_TKTS_ONHAND_QTY;
               V_BANK_DEP_TICK.YTD_DEP_TKTS_ORDERED_QTY := V_BANK_DEP_TICK.YTD_DEP_TKTS_ORDERED_QTY;
            ELSE
               --if the order date is current then we will update the DEP_TKTS_ONHAND_QTY and YTD_DEP_TKTS_ORDERED_QTY
               --if not the batch process will update the qauntity when it hits the date
               V_BANK_DEP_TICK.DEP_TKTS_ONHAND_QTY      := NVL(V_BANK_DEP_TICK.DEP_TKTS_ONHAND_QTY,0) + V_BANK_DEP_TICK.NBR_DEP_TICKETS_PER_BK * V_BANK_DEP_TICK.REORDER_NUMBER_BKS;
               V_BANK_DEP_TICK.YTD_DEP_TKTS_ORDERED_QTY := NVL(V_BANK_DEP_TICK.YTD_DEP_TKTS_ORDERED_QTY,0) + V_BANK_DEP_TICK.NBR_DEP_TICKETS_PER_BK * V_BANK_DEP_TICK.REORDER_NUMBER_BKS;
            END IF;
            V_BANK_DEP_TICK.EFFECTIVE_DATE  := LEAST(NVL(V_BANK_DEP_TICK.EXPIRATION_DATE, SYSDATE), SYSDATE);
            TABLE_IU_PKG.BANK_DEP_TICK_I_SP(V_BANK_DEP_TICK);
        END IF;
    ELSE
        BEGIN
            SELECT *      
              INTO V_BANK_DEP_TICK_FUTURE
              FROM BANK_DEP_TICK_FUTURE
             WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
               AND FUTURE_ID        = IN_FUTURE_ID;
        EXCEPTION
            WHEN OTHERS THEN
                NULL;
        END;
        IF V_BANK_DEP_TICK_FUTURE.COST_CENTER_CODE IS NOT NULL THEN
            V_BANK_DEP_TICKORD_FUTURE.BANK_ACCOUNT_NBR        := V_BANK_DEP_TICK_FUTURE.BANK_ACCOUNT_NBR;
            V_BANK_DEP_TICKORD_FUTURE.COST_CENTER_CODE        := V_BANK_DEP_TICK_FUTURE.COST_CENTER_CODE;
            V_BANK_DEP_TICKORD_FUTURE.BANK_DEP_TICK_FTR_ID    := NVL(GET_DEPOSIT_TKT_FUT_ID_NBR(V_BANK_DEP_TICK_FUTURE.COST_CENTER_CODE, 'F'),0) + 1;
            V_BANK_DEP_TICKORD_FUTURE.DEPOSIT_ORDER_PRIORITY  := '100';
            V_BANK_DEP_TICKORD_FUTURE.DEPOSIT_ORDER_STATUS    := 'P';
            V_BANK_DEP_TICKORD_FUTURE.DEPOSIT_ORDER_SEQ_NBR   := NVL(GET_DEPOSIT_ORDER_SEQ_NBR(V_BANK_DEP_TICK_FUTURE.COST_CENTER_CODE),0);
            V_BANK_DEP_TICKORD_FUTURE.DEPOSIT_ORDER_SEQ_NBR   := V_BANK_DEP_TICKORD_FUTURE.DEPOSIT_ORDER_SEQ_NBR + 1;
            V_BANK_DEP_TICKORD_FUTURE.EFFECTIVE_DATE          := V_BANK_DEP_TICK_FUTURE.EFFECTIVE_DATE;
            V_BANK_DEP_TICKORD_FUTURE.EXPIRATION_DATE         := V_BANK_DEP_TICK_FUTURE.EXPIRATION_DATE;
            V_BANK_DEP_TICKORD_FUTURE.LAST_MAINTENANCE_DATE   := TRUNC(SYSDATE);
            V_BANK_DEP_TICKORD_FUTURE.LAST_MAINT_USER_ID      := IN_USER_ID;
            V_BANK_DEP_TICKORD_FUTURE.ORDER_DATE              := IN_ORDERED_DATE;
            V_BANK_DEP_TICKORD_FUTURE.EXTRACTED_USER_ID       := IN_USER_ID;
            V_BANK_DEP_TICKORD_FUTURE.FUTURE_ID               := V_BANK_DEP_TICK_FUTURE.FUTURE_ID;
            TABLE_IU_PKG.BANK_DEP_TICKORD_FUTURE_I_SP(V_BANK_DEP_TICKORD_FUTURE);
            /***DEP_TKTS_ONHAND_QTY will depend on book quantity. If we need different quantity we have to update the book quantity first and save it. Then place the order.
            For future this will start with new order as if there was "0" DEP_TKTS_ONHAND_QTY ***/
            V_BANK_DEP_TICK_FUTURE.DEP_TKTS_ONHAND_QTY        := 0;
            V_BANK_DEP_TICK_FUTURE.YTD_DEP_TKTS_ORDERED_QTY   := 0;
            V_BANK_DEP_TICK_FUTURE.EFFECTIVE_DATE  := LEAST(NVL(V_BANK_DEP_TICK_FUTURE.EXPIRATION_DATE, SYSDATE), SYSDATE);
            TABLE_IU_PKG.BANK_DEP_TICK_FUTURE_I_SP(V_BANK_DEP_TICK_FUTURE);
            CREATE_DEPOSIT_TKT_INPUT_FILE(V_BANK_DEP_TICK_FUTURE.COST_CENTER_CODE,IN_FUTURE_ID);
            BEGIN
               SELECT BANK_ACCOUNT_NBR, 
                      COST_CENTER_CODE,       
                      DAILY_USE_ACTUAL,
                      DAILY_USE_OVERRIDE,    
                      DEP_TKTS_ONHAND_QTY,     
                      YTD_DEP_TKTS_ORDERED_QTY,
                      REORDER_POINT,
                      REORDER_NUMBER_BKS,
                      IMAGES_PER_PAGE,     
                      NBR_FORMS_PER_BK,        
                      PART_PAPER_PER_FORM,
                      NBR_DEP_TICKETS_PER_BK,
                      SHEETS_OF_PAPER_PER_BK, 
                      EFFECTIVE_DATE, 
                      EXPIRATION_DATE,         
                      LAST_MAINTENANCE_DATE,
                      LAST_MAINT_USER_ID,  
                      REORDER_SWITCH,     
                      LAST_VW_ORDER_DATE
                 INTO V_BANK_DEP_TICK
                 FROM BANK_DEP_TICK_FUTURE
                WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
                  AND FUTURE_ID        = IN_FUTURE_ID;
            EXCEPTION
              WHEN OTHERS THEN
                  NULL;
            END;
            RSA_WEB_SERVICES_PKG.CREATE_DEPOSIT_TICKET_ORDER(V_BANK_DEP_TICK);
        END IF;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, 'PLACE_DEPOSIT_TICKET_ORDER ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END PLACE_DEPOSIT_TICKET_ORDER;

END DEPOSIT_TICKET_MAINTENANCE_PKG;