create or replace PACKAGE BODY DEPOSIT_TICKET_MAINTENANCE_PKG
AS
/**********************************************************
This Package contains all the procedures used in
bank deposit ticket maintenance window

Created : 07/09/2015 jxc517 CCN Project....
Changed :
**********************************************************/
PROCEDURE CALCULATE_DEPOSIT_TICKET(
/*******************************************************************************
This procedure is intended to calcualte the deposit tickets
based on the MICR formats part per page value and reference sheets per book value
as sheets per book value/MICR formats part per page

Created : 08/18/2015 jxc517 CCN Project....
Changed : 12/08/2016 nxk927 CCN Project....
          Signature changed to pass IMAGES_PER_PAGE,NBR_FORMS_PER_BK and SHEETS_OF_PAPER_PER_BK from reference table
*******************************************************************************/
    IN_DJDE_FEED_PARM              IN     VARCHAR2,
    IN_OUT_PART_PAPER_PER_FORM     IN OUT NUMBER,
    IN_OUT_NBR_DEP_TICKETS_PER_BK  IN OUT NUMBER,
    IN_OUT_IMAGES_PER_PAGE         IN OUT NUMBER,
    IN_OUT_NBR_FORMS_PER_BK        IN OUT NUMBER,
    IN_OUT_SHEETS_OF_PAPER_PER_BK  IN OUT NUMBER,
    IN_OUT_REORDER_NUMBER_BKS      IN OUT NUMBER)
IS
    V_DJDE_FEED_PARM VARCHAR2(10) := IN_DJDE_FEED_PARM;
BEGIN
    --the feed parm received might contain spaces so first we trim those off
    --then we need to take the last character of this value which contains the number (idealy)
    IN_OUT_PART_PAPER_PER_FORM := SUBSTR(TRIM(V_DJDE_FEED_PARM), -1, 1);
    IN_OUT_NBR_DEP_TICKETS_PER_BK :=
       BANKING_COMMON_TOOLS.GET_STANDARD_VAL_DEPOSIT_ORD('SHEETS_OF_PAPER_PER_BK')/IN_OUT_PART_PAPER_PER_FORM;
    --below 3 fields remain same always : validated with production data
    IN_OUT_IMAGES_PER_PAGE        := NVL(IN_OUT_IMAGES_PER_PAGE,BANKING_COMMON_TOOLS.GET_STANDARD_VAL_DEPOSIT_ORD('IMAGES_PER_PAGE'));
    IN_OUT_NBR_FORMS_PER_BK       := NVL(IN_OUT_NBR_FORMS_PER_BK,BANKING_COMMON_TOOLS.GET_STANDARD_VAL_DEPOSIT_ORD('NBR_FORMS_PER_BK'));
    IN_OUT_SHEETS_OF_PAPER_PER_BK := NVL(IN_OUT_SHEETS_OF_PAPER_PER_BK,BANKING_COMMON_TOOLS.GET_STANDARD_VAL_DEPOSIT_ORD('SHEETS_OF_PAPER_PER_BK'));
    IN_OUT_REORDER_NUMBER_BKS     := NVL(IN_OUT_REORDER_NUMBER_BKS,BANKING_COMMON_TOOLS.GET_STANDARD_VAL_DEPOSIT_ORD('REORDER_NUMBER_BKS'));
END CALCULATE_DEPOSIT_TICKET;

PROCEDURE DELETE_STORE_MICR_FORMAT_DTLS(
/*******************************************************************************
This procedure is intended to get the STORE_MICR_FORMAT_DTLS record
and delete it from the table

Created : 08/18/2015 jxc517 CCN Project....
Changed : 11/19/2015 nxk927 CCN Project....
          changed the order to delete the order first before the ticket
*******************************************************************************/
IN_COST_CENTER_CODE     IN    VARCHAR2,
IN_BANK_ACCOUNT_NBR     IN    VARCHAR2,
IN_MICR_FORMAT_ID       IN    NUMBER)
IS
    CURSOR store_micr_format_dtls_cur1 IS 
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE;
    CURSOR bank_dep_tick_cur IS
        SELECT *
          FROM BANK_DEP_TICK
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE;
    CURSOR bank_dep_tickord_cur IS
        SELECT *
          FROM BANK_DEP_TICKORD
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE;
    CURSOR store_micr_format_dtls_cur IS 
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS
         WHERE BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
           AND MICR_FORMAT_ID   = IN_MICR_FORMAT_ID;
BEGIN
    IF IN_COST_CENTER_CODE IS NOT NULL THEN
        FOR rec IN store_micr_format_dtls_cur1 LOOP
            TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_D_SP(rec);
        END LOOP;
        FOR rec IN bank_dep_tickord_cur LOOP
            TABLE_IU_PKG.BANK_DEP_TICKORD_D_SP(rec);
        END LOOP;
        FOR rec IN bank_dep_tick_cur LOOP
            TABLE_IU_PKG.BANK_DEP_TICK_D_SP(rec);
        END LOOP;
    ELSE
        FOR rec IN store_micr_format_dtls_cur LOOP
            TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_D_SP(rec);
        END LOOP;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END DELETE_STORE_MICR_FORMAT_DTLS;

PROCEDURE EXPIRE_STORE_MICR_FORMAT_DTLS(
/*******************************************************************************
This procedure is intended to get the STORE_MICR_FORMAT_DTLS record
and expire it from the table

Created : 08/18/2015 jxc517 CCN Project....
Changed : 11/19/2015 nxk927 CCN Project....
          changed the order to delete the order first before the ticket
*******************************************************************************/
IN_COST_CENTER_CODE     IN    VARCHAR2,
IN_BANK_ACCOUNT_NBR     IN    VARCHAR2,
IN_MICR_FORMAT_ID       IN    NUMBER,
IN_EXPIRATION_DATE      IN    DATE)
IS
    CURSOR store_micr_format_dtls_cur1 IS 
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EXPIRATION_DATE IS NULL;
    CURSOR bank_dep_tick_cur IS
        SELECT *
          FROM BANK_DEP_TICK
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EXPIRATION_DATE IS NULL;
    CURSOR bank_dep_tickord_cur IS
        SELECT *
          FROM BANK_DEP_TICKORD
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EXPIRATION_DATE IS NULL;
    CURSOR store_micr_format_dtls_cur IS 
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS
         WHERE BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
           AND MICR_FORMAT_ID   = IN_MICR_FORMAT_ID
           AND EXPIRATION_DATE IS NULL;
BEGIN
    IF IN_COST_CENTER_CODE IS NOT NULL THEN
        FOR rec IN store_micr_format_dtls_cur1 LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_I_SP(rec);
        END LOOP;
        FOR rec IN bank_dep_tickord_cur LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.BANK_DEP_TICKORD_I_SP(rec);
        END LOOP;
        FOR rec IN bank_dep_tick_cur LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.BANK_DEP_TICK_I_SP(rec);
        END LOOP;
    ELSE
        FOR rec IN store_micr_format_dtls_cur LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_I_SP(rec);
        END LOOP;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END EXPIRE_STORE_MICR_FORMAT_DTLS;

PROCEDURE EXPR_STR_MICR_FRMT_DTLS_FTR(
/*******************************************************************************
This procedure is intended to get the STORE_MICR_FORMAT_DTLS record
and expire it from the table

Created : 08/18/2015 jxc517 CCN Project....
Changed : 11/19/2015 nxk927 CCN Project....
          changed the order to delete the order first before the ticket
*******************************************************************************/
IN_COST_CENTER_CODE     IN    VARCHAR2,
IN_BANK_ACCOUNT_NBR     IN    VARCHAR2,
IN_MICR_FORMAT_ID       IN    NUMBER,
IN_FUTURE_ID            IN    NUMBER,
IN_EXPIRATION_DATE      IN    DATE)
IS
    CURSOR store_micr_format_dtls_cur1 IS 
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND FUTURE_ID        = IN_FUTURE_ID
           AND EXPIRATION_DATE IS NULL;
    CURSOR bank_dep_tick_cur IS
        SELECT *
          FROM BANK_DEP_TICK_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND FUTURE_ID        = IN_FUTURE_ID
           AND EXPIRATION_DATE IS NULL;
    CURSOR bank_dep_tickord_cur IS
        SELECT *
          FROM BANK_DEP_TICKORD_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND FUTURE_ID        = IN_FUTURE_ID
           AND EXPIRATION_DATE IS NULL;
    CURSOR store_micr_format_dtls_cur IS 
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS_FUTURE
         WHERE BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
           AND MICR_FORMAT_ID   = IN_MICR_FORMAT_ID
           AND FUTURE_ID        = IN_FUTURE_ID
           AND EXPIRATION_DATE IS NULL;
BEGIN
    IF IN_COST_CENTER_CODE IS NOT NULL THEN
        FOR rec IN store_micr_format_dtls_cur1 LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.STR_MICR_FORMAT_DTLS_FTR_I_SP(rec);
        END LOOP;
        FOR rec IN bank_dep_tickord_cur LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.BANK_DEP_TICKORD_FUTURE_I_SP(rec);
        END LOOP;
        FOR rec IN bank_dep_tick_cur LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.BANK_DEP_TICK_FUTURE_I_SP(rec);
        END LOOP;
    ELSE
        FOR rec IN store_micr_format_dtls_cur LOOP
            rec.EXPIRATION_DATE := IN_EXPIRATION_DATE;
            TABLE_IU_PKG.STR_MICR_FORMAT_DTLS_FTR_I_SP(rec);
        END LOOP;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END EXPR_STR_MICR_FRMT_DTLS_FTR;

FUNCTION CONVERT_FORMAT_TO_VALUE(
/*******************************************************************************
This function converts the format into actual value to be stored in STORE_MICR_FORMAT_DTLS

Created : 08/18/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_FORMAT     IN     VARCHAR2,
IN_VALUE      IN     VARCHAR2) RETURN VARCHAR2
IS
    V_VALUE         VARCHAR2(100) := REGEXP_REPLACE(IN_VALUE, '[^0-9]+');
    V_COUNT         NUMBER := 0;
    V_RETURN_VALUE  VARCHAR2(100);
BEGIN
    IF REGEXP_LIKE(IN_VALUE, '[0-9]+') THEN
        FOR i IN 1..LENGTH(IN_FORMAT) LOOP
            IF SUBSTR(IN_FORMAT,i ,1) = 'X' THEN
                V_COUNT := V_COUNT + 1;
                V_RETURN_VALUE := V_RETURN_VALUE || SUBSTR(V_VALUE, V_COUNT, 1);
            ELSE
                V_RETURN_VALUE := V_RETURN_VALUE || SUBSTR(IN_FORMAT,i ,1);
            END IF;
        END LOOP;
    ELSE
        V_RETURN_VALUE := NVL(IN_VALUE, IN_FORMAT);
    END IF;
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END CONVERT_FORMAT_TO_VALUE;

FUNCTION CONVERT_MICR_CC_FORMAT(
/*******************************************************************************
This function converts the micr cost center format into actual value to be 
stored in STORE_MICR_FORMAT_DTLS

Created : 08/18/2015 jxc517 CCN Project....
Changed : 10/17/2016 nxk927 CCN Project....
          function name changed as his will be only used for micr cost center.
          Added the else conditions to consider numbers as well.
        : 10/21/2016 nxk927 CCN Project....
          simplified the logic to convert the passed value to the format desired         
*******************************************************************************/
IN_FORMAT     IN     VARCHAR2,
IN_VALUE      IN     VARCHAR2) RETURN VARCHAR2
IS
    V_VALUE           VARCHAR2(100) := REGEXP_REPLACE(IN_VALUE, '[^0-9]+');
    V_COUNT           NUMBER := 0;
    V_RETURN_VALUE    VARCHAR2(100);
    V_COST_CENTER     VARCHAR2(4);
BEGIN
    IF REGEXP_LIKE(IN_VALUE, '[0-9]+') THEN
       BEGIN
          SELECT SUBSTR(COST_CENTER_CODE, 3) 
            INTO V_COST_CENTER
            FROM COST_CENTER
           WHERE SUBSTR(COST_CENTER_CODE, 3) IN (SUBSTR(IN_FORMAT, 5), SUBSTR(IN_FORMAT, 1, 4))
             AND SUBSTR(COST_CENTER_CODE, 3) <> '0000' --'0000' is a dummy cost center with open date of 01-JAN-99.
             AND ROWNUM < 2;
       EXCEPTION
           WHEN OTHERS THEN
               NULL;
       END;
       V_RETURN_VALUE := REPLACE(REPLACE(IN_FORMAT,
                                         'XXXX',
                                         IN_VALUE),
                                 V_COST_CENTER,
                                 IN_VALUE);
    ELSE
        V_RETURN_VALUE :=  IN_FORMAT;
    END IF;
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END CONVERT_MICR_CC_FORMAT;

FUNCTION GET_DEPOSIT_TKT_FUT_ID_NBR(
/*******************************************************************************
This fucntion is intended to return the deposit ticket future id
for the cost center that has been passed in

Created : 11/03/2015 nxk927 CCN Project....
Changed : 11/16/2015 nxk927 CCN Project.... 
          passing bank account number as the parameter
*******************************************************************************/
IN_COST_CENTER_CODE    IN      VARCHAR2,
IN_BANK_ACCT_NBR       IN      VARCHAR2,
IN_FUTURE_ID           IN      NUMBER) RETURN VARCHAR2
IS
    V_RETURN_VAL VARCHAR2(10);
BEGIN
    IF IN_FUTURE_ID IS NULL THEN
       SELECT MAX(BANK_DEP_TICK_FTR_ID)
         INTO V_RETURN_VAL
         FROM BANK_DEP_TICKORD
        WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
          AND BANK_ACCOUNT_NBR = IN_BANK_ACCT_NBR;
    ELSE
       SELECT MAX(BANK_DEP_TICK_FTR_ID)
         INTO V_RETURN_VAL
         FROM BANK_DEP_TICKORD_FUTURE
        WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
          AND BANK_ACCOUNT_NBR = IN_BANK_ACCT_NBR
          AND FUTURE_ID        = IN_FUTURE_ID;
    END IF;
    RETURN V_RETURN_VAL;
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END GET_DEPOSIT_TKT_FUT_ID_NBR;

PROCEDURE DEPOSIT_TICKET_MNTNC_UI_SP (
/*******************************************************************************
This procedure is intended to RETURN a ref cursor with data from 
tables based on passed input cost center code

Created : 08/21/2015 jxc517 CCN Project....
Changed : 10/22/2015 sxt410 CCN Project....
          Modified Signature To Pass Current Order Date And Future Order Date. 
Changed : 10/29/2015 jxc517 CCN Project....
          Modified code to include order by clause for bank MICR formats based on FORMAT_NAME
        : 11/16/2015 axk326 CCN Project....
          Added code to retreive the latest order details for the deposit ticket order when placed for current and future tabs
        : 11/23/2015 nxk927 CCN Project...
          For future tab only displaying if the record is a real not the virtual
        : 10/18/2016 nxk927 CCN Project....
          Modified Signature to pass member bank details to UI. It will be used to populate the 
          sub account number in the deposit ticket window. This is added to support the micr details 
          changes for the member bank cost center.
        : 12/09/2016 nxk927 CCN Project....
          Cursor changed for the deposit ticket order table to pass everything as to pass the maintenance date as order date, and
          order date as desired arrival date. This needs to be here until this column is updated
*******************************************************************************/
IN_COST_CENTER_CODE                IN     VARCHAR2
,OUT_BANK_DEP_TICK_REF_CUR            OUT REF_CURSOR
,OUT_BANK_ACCOUNT_REF_CUR             OUT REF_CURSOR
,OUT_BANK_MICR_FORMAT_REF_CUR         OUT REF_CURSOR
,OUT_BANK_DEP_TICK_FTR_REF_CUR        OUT REF_CURSOR
,OUT_BANK_ACCOUNT_FTR_REF_CUR         OUT REF_CURSOR
,OUT_BANK_MICR_FRMT_FTR_REF_CUR       OUT REF_CURSOR
,OUT_BANK_DEP_TICKORD_REF_CUR         OUT REF_CURSOR
,OUT_BANK_DEP_TKORD_FTR_REF_CUR       OUT REF_CURSOR
,OUT_MBR_BANK_CC_REF_CUR              OUT REF_CURSOR
,OUT_MBR_BANK_CC_FTR_REF_CUR          OUT REF_CURSOR)
IS
    V_STORE_MICR_FORMAT_DTLS_REC   STORE_MICR_FORMAT_DTLS%ROWTYPE;
    V_BANK_MICR_FORMAT_REC         BANK_MICR_FORMAT%ROWTYPE;
    V_BANK_ACCOUNT_NBR             BANK_ACCOUNT.BANK_ACCOUNT_NBR%TYPE;
    V_BANK_TYPE_CODE               LEAD_BANK_CC.BANK_TYPE_CODE%TYPE;
    V_LEAD_BANK_ACCOUNT_NBR        LEAD_BANK_CC.LEAD_BANK_ACCOUNT_NBR%TYPE; 
BEGIN
    --Below call is needed to get the store MICR format details for the store passed in
    --If the passed store is a member without a default store MICR, we need to get it's leads store MICR details
    V_STORE_MICR_FORMAT_DTLS_REC := BANKING_COMMON_TOOLS.GET_STORE_MICR_FORMAT_DTLS_REC(IN_COST_CENTER_CODE);

    --The above call just returns the bank MICR format id, but not the actual details
    --so we invoke below procedure to get the actual details associated with that bank account number and format id
    V_BANK_MICR_FORMAT_REC := BANKING_COMMON_TOOLS.GET_STORE_BANK_MICR_FORMAT_REC(V_STORE_MICR_FORMAT_DTLS_REC.BANK_ACCOUNT_NBR,
                                                                                  V_STORE_MICR_FORMAT_DTLS_REC.MICR_FORMAT_ID);

    --Since we don't want to change anything from UI because of the change in store MICR format
    --we need to pass the above obtained store MICR format details along with the actual Bank Deposit Ticket details
    --Also anything that got expired even a second before should not be returned back to UI
    OPEN OUT_BANK_DEP_TICK_REF_CUR FOR
        SELECT A.*,
               V_BANK_MICR_FORMAT_REC.FORMAT_NAME AS FORMAT_NAME,
               V_BANK_MICR_FORMAT_REC.DJDE_FORM_PARM AS DJDE_FORM_PARM,
               V_BANK_MICR_FORMAT_REC.DJDE_FEED_PARM AS DJDE_FEED_PARM,
               V_STORE_MICR_FORMAT_DTLS_REC.MICR_COST_CNTR AS MICR_COST_CNTR,
               V_STORE_MICR_FORMAT_DTLS_REC.MICR_ROUTING_NBR AS MICR_ROUTING_NBR,
               V_STORE_MICR_FORMAT_DTLS_REC.MICR_FORMAT_ACCT_NBR AS MICR_FORMAT_ACTNBR
          FROM BANK_DEP_TICK A
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND NVL(EXPIRATION_DATE, SYSDATE + 1) > SYSDATE;

    --Below query will return the current bank account number and the bank type code for the store passed in
    --To get to the bank account, we are fetching the lead store first if the store passed in is a member
    --Also anything that got expired even a second before should not be returned back to UI
    SELECT LEAD_BANK_ACCOUNT_NBR,
           BANK_TYPE_CODE
      INTO V_BANK_ACCOUNT_NBR,
           V_BANK_TYPE_CODE
      FROM (SELECT LEAD_BANK_ACCOUNT_NBR,
                   BANK_TYPE_CODE,
                   EFFECTIVE_DATE
              FROM LEAD_BANK_CC
             WHERE LEAD_STORE_NBR = IN_COST_CENTER_CODE
               AND NVL(EXPIRATION_DATE, SYSDATE + 1) > SYSDATE
             UNION
            SELECT LEAD_BANK_ACCOUNT_NBR,
                   'M' AS BANK_TYPE_CODE,
                   EFFECTIVE_DATE
             FROM MEMBER_BANK_CC
            WHERE MEMBER_STORE_NBR = IN_COST_CENTER_CODE
              AND NVL(EXPIRATION_DATE, SYSDATE + 1) > SYSDATE
            ORDER BY EFFECTIVE_DATE DESC)
     WHERE ROWNUM < 2;

    --Below cursor will provide all the current bank account details for the store number passed
    OPEN OUT_BANK_ACCOUNT_REF_CUR FOR
        SELECT BA.*,
               V_BANK_TYPE_CODE AS BANK_TYPE_CODE
          FROM BANK_ACCOUNT BA
         WHERE BA.BANK_ACCOUNT_NBR = V_BANK_ACCOUNT_NBR;

    --Below cursor will provide all the current bank MICR format details for the store number passed
    --ordered by FORMAT_NAME
    OPEN OUT_BANK_MICR_FORMAT_REF_CUR FOR
        SELECT BMF.*
          FROM BANK_MICR_FORMAT BMF
         WHERE BMF.BANK_ACCOUNT_NBR = V_BANK_ACCOUNT_NBR
         ORDER BY FORMAT_NAME;
         
    SELECT LEAD_BANK_ACCOUNT_NBR
      INTO V_LEAD_BANK_ACCOUNT_NBR
      FROM (SELECT LEAD_BANK_ACCOUNT_NBR,
                   EFFECTIVE_DATE
              FROM LEAD_BANK_CC
             WHERE LEAD_STORE_NBR = IN_COST_CENTER_CODE
               AND NVL(EXPIRATION_DATE, SYSDATE + 1) > SYSDATE
			      UNION
            SELECT LEAD_BANK_ACCOUNT_NBR,
                   EFFECTIVE_DATE
              FROM MEMBER_BANK_CC
             WHERE MEMBER_STORE_NBR = IN_COST_CENTER_CODE
               AND NVL(EXPIRATION_DATE, SYSDATE + 1) > SYSDATE
               AND TRUNC(EFFECTIVE_DATE) <= TRUNC(SYSDATE)
             ORDER BY EFFECTIVE_DATE DESC)
     WHERE ROWNUM < 2;
    --Below cursor will provide all the current bank deposit ticket order details for the store number passed
    OPEN OUT_BANK_DEP_TICKORD_REF_CUR FOR 
        SELECT BANK_ACCOUNT_NBR,
               COST_CENTER_CODE,
               BANK_DEP_TICK_FTR_ID,
               DEPOSIT_ORDER_PRIORITY,
               DEPOSIT_ORDER_STATUS,
               DEPOSIT_ORDER_SEQ_NBR,
               EFFECTIVE_DATE,
               EXPIRATION_DATE,
               LAST_MAINTENANCE_DATE,
               LAST_MAINTENANCE_DATE ORDER_DATE,--Need this changed later on, LAST_MAINTENANCE_DATE as desired arrival date
               LAST_MAINT_USER_ID,
               ORDER_DATE DESIRED_ARRIVAL_DATE, --Need this changed later on, order date as desired arrival date
               EXTRACTED_USER_ID,
               EXTERNAL_ORDER_ID_GUI,
               ORDER_TRACKING_NUMBER
          FROM BANK_DEP_TICKORD
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND BANK_ACCOUNT_NBR = V_LEAD_BANK_ACCOUNT_NBR
           AND BANK_DEP_TICK_FTR_ID = GET_DEPOSIT_TKT_FUT_ID_NBR(IN_COST_CENTER_CODE, V_LEAD_BANK_ACCOUNT_NBR, NULL);

    --Below cursor will provide all the member bank details for the store number passed
    OPEN OUT_MBR_BANK_CC_REF_CUR FOR 
        SELECT *
          FROM MEMBER_BANK_CC
         WHERE MEMBER_STORE_NBR = IN_COST_CENTER_CODE
           AND NVL(EXPIRATION_DATE, SYSDATE + 1) > SYSDATE;

    --Since we don't want to change anything from UI because of the change in store MICR format
    --we need to pass the store MICR format details along with the actual Bank Deposit Ticket details
    --The inner most query fetches the format id and bank account number for the store based on STORE_MICR_FORMAT_DTLS_FUTURE table
    OPEN OUT_BANK_DEP_TICK_FTR_REF_CUR FOR
        SELECT A.*,
               B.FORMAT_NAME AS FORMAT_NAME,
               B.DJDE_FORM_PARM AS DJDE_FORM_PARM,
               B.DJDE_FEED_PARM AS DJDE_FEED_PARM,
               B.MICR_COST_CNTR AS MICR_COST_CNTR,
               B.MICR_ROUTING_NBR AS MICR_ROUTING_NBR,
               B.MICR_FORMAT_ACCT_NBR AS MICR_FORMAT_ACTNBR
          FROM BANK_DEP_TICK_FUTURE A,
               (SELECT BMFF.FORMAT_NAME,
                       BMFF.DJDE_FORM_PARM,
                       BMFF.DJDE_FEED_PARM,
                       SMFDF.MICR_COST_CNTR,
                       SMFDF.MICR_ROUTING_NBR,
                       SMFDF.MICR_FORMAT_ACCT_NBR,
                       SMFDF.FUTURE_ID
                  FROM (SELECT *
                        --This top-N query was used to get member store MICR details if it has a default MICR assigned
                           FROM (SELECT *
                                   FROM STORE_MICR_FORMAT_DTLS_FUTURE
                                  --IN clause below makes sure we always get the passed stores MICR details
                                  --as well as it's leads storer MICR format details
                                  WHERE COST_CENTER_CODE IN (IN_COST_CENTER_CODE,
                                                             BANKING_COMMON_TOOLS.GET_FTR_LD_STR_NBR_FOR_MBR_STR(IN_COST_CENTER_CODE, NULL))
                                  --below order by clause is to make sure we get store MICR details even for
                                  --a member that doesn't have any default store MICR assigned to it in future
                                  --if member got it's own store MICR that takes precedence
                                  ORDER BY DECODE(COST_CENTER_CODE, IN_COST_CENTER_CODE, 1, 2))
                            WHERE ROWNUM < 2) SMFDF,
                       BANK_MICR_FORMAT_FUTURE BMFF
                 WHERE SMFDF.BANK_ACCOUNT_NBR = BMFF.BANK_ACCOUNT_NBR
                   AND SMFDF.MICR_FORMAT_ID   = BMFF.MICR_FORMAT_ID
                   AND SMFDF.FUTURE_ID        = BMFF.FUTURE_ID
                   AND SMFDF.EFFECTIVE_DATE    > TRUNC(SYSDATE)) B
         WHERE A.COST_CENTER_CODE     = IN_COST_CENTER_CODE
           AND A.FUTURE_ID            = B.FUTURE_ID(+)
           AND A.EFFECTIVE_DATE       > TRUNC(SYSDATE)
         ORDER BY A.FUTURE_ID;

    --Below cursor will provide the future bank account details and store type for the store number passed
    --ordered by FUTURE_ID
    --To get to the bank account, we are fetching the lead store first if the store passed in is a member
    OPEN OUT_BANK_ACCOUNT_FTR_REF_CUR FOR
        SELECT BAF.*,
               BANK_TYPE_CODE
          FROM BANK_ACCOUNT_FUTURE BAF,
               (SELECT LEAD_BANK_ACCOUNT_NBR,
                       BANK_TYPE_CODE,
                       FUTURE_ID
                  FROM LEAD_BANK_CC_FUTURE
                 WHERE LEAD_STORE_NBR   = IN_COST_CENTER_CODE
                   AND EFFECTIVE_DATE   > TRUNC(SYSDATE)
                 UNION
                SELECT LEAD_BANK_ACCOUNT_NBR,
                       'M' AS BANK_TYPE_CODE,
                       FUTURE_ID
                  FROM MEMBER_BANK_CC_FUTURE
                 WHERE MEMBER_STORE_NBR = IN_COST_CENTER_CODE
                   AND EFFECTIVE_DATE   > TRUNC(SYSDATE)) S
         WHERE BAF.BANK_ACCOUNT_NBR     = S.LEAD_BANK_ACCOUNT_NBR
           AND BAF.FUTURE_ID            = S.FUTURE_ID
         ORDER BY BAF.FUTURE_ID;

    --Below cursor will provide all the future bank MICR format details for the store number passed
    --ordered by FUTURE_ID and FORMAT_NAME
    --To get to the bank account, we are fetching the lead store first if the store passed in is a member
    OPEN OUT_BANK_MICR_FRMT_FTR_REF_CUR FOR
        SELECT BMFF.*
          FROM BANK_MICR_FORMAT_FUTURE BMFF,
               (SELECT LEAD_BANK_ACCOUNT_NBR,
                       FUTURE_ID
                  FROM LEAD_BANK_CC_FUTURE
                 WHERE LEAD_STORE_NBR = IN_COST_CENTER_CODE
                   AND EFFECTIVE_DATE > TRUNC(SYSDATE)
                 UNION
                SELECT LEAD_BANK_ACCOUNT_NBR,
                       FUTURE_ID
                  FROM MEMBER_BANK_CC_FUTURE
                 WHERE MEMBER_STORE_NBR = IN_COST_CENTER_CODE
                   AND EFFECTIVE_DATE   > TRUNC(SYSDATE)) S
         WHERE BMFF.BANK_ACCOUNT_NBR    = S.LEAD_BANK_ACCOUNT_NBR
           AND BMFF.FUTURE_ID           = S.FUTURE_ID
         ORDER BY BMFF.FUTURE_ID, BMFF.FORMAT_NAME;

    --Below cursor will provide all the future bank deposit ticket order details for the store number passed
    --ordered by FUTURE_ID
    --Added cost_center_code to the where clause as it has to give the future details for the store that the user is trying to look into 
    OPEN OUT_BANK_DEP_TKORD_FTR_REF_CUR FOR
        SELECT BANK_ACCOUNT_NBR,
               COST_CENTER_CODE,
               BANK_DEP_TICK_FTR_ID,
               DEPOSIT_ORDER_PRIORITY,
               DEPOSIT_ORDER_STATUS,
               DEPOSIT_ORDER_SEQ_NBR,
               EFFECTIVE_DATE,
               EXPIRATION_DATE,
               LAST_MAINTENANCE_DATE,
               LAST_MAINTENANCE_DATE ORDER_DATE, --Need this changed later on, maintenance date as order date
               LAST_MAINT_USER_ID,
               ORDER_DATE DESIRED_ARRIVAL_DATE,  --Need this changed later on, order date as desired arrival date
               EXTRACTED_USER_ID,
               FUTURE_ID,
               EXTERNAL_ORDER_ID_GUI,
               ORDER_TRACKING_NUMBER
          FROM BANK_DEP_TICKORD_FUTURE BDTF
         WHERE BDTF.COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND BDTF.BANK_DEP_TICK_FTR_ID = GET_DEPOSIT_TKT_FUT_ID_NBR(IN_COST_CENTER_CODE, BDTF.BANK_ACCOUNT_NBR, BDTF.FUTURE_ID);

    --Below cursor will provide all the member bank details for the store number passed
    OPEN OUT_MBR_BANK_CC_FTR_REF_CUR FOR 
        SELECT *
          FROM MEMBER_BANK_CC_FUTURE
         WHERE MEMBER_STORE_NBR = IN_COST_CENTER_CODE
           AND EFFECTIVE_DATE   > TRUNC(SYSDATE);
           
END DEPOSIT_TICKET_MNTNC_UI_SP;

PROCEDURE BUILD_TABLE_TYPES(
/******************************************************************************
This procedure is intended to build all the table types from input xml
for this process

Created : 07/17/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
    IN_XML                         IN     CLOB,
    O_BANK_DEP_TICK_REC               OUT BANK_DEP_TICK%ROWTYPE,
    O_BANK_DEP_TICK_FUTURE_REC        OUT BANK_DEP_TICK_FUTURE%ROWTYPE,
    O_MICR_FORMAT_ID                  OUT NUMBER)
IS
    V_XML_BANK_DEP_TICK_FRAG        CLOB;
    V_ROW_DATA                      XMLTYPE := SYS.XMLTYPE(IN_XML);
BEGIN
    IF (V_ROW_DATA.EXISTSNODE('/BANK_DEP_TICK_UI/BANK_DEP_TICK') = 1) THEN --Single Record
        V_XML_BANK_DEP_TICK_FRAG := V_ROW_DATA.EXTRACT('/BANK_DEP_TICK_UI/BANK_DEP_TICK').GETCLOBVAL();
    END IF;
    IF V_XML_BANK_DEP_TICK_FRAG IS NOT NULL  THEN
        IF SYS.XMLTYPE(V_XML_BANK_DEP_TICK_FRAG).EXISTSNODE('/BANK_DEP_TICK/FUTURE_ID/text()') = 1 THEN
            TABLE_IU_PKG.BANK_DEP_TICK_FTR_ROWTYPE_SP('BANK_DEP_TICK_FUTURE',
                                                      REPLACE(V_XML_BANK_DEP_TICK_FRAG,'BANK_DEP_TICK>','BANK_DEP_TICK_FUTURE>'),
                                                      O_BANK_DEP_TICK_FUTURE_REC);
        ELSE
            TABLE_IU_PKG.BANK_DEP_TICK_ROWTYPE_SP('BANK_DEP_TICK',
                                                  V_XML_BANK_DEP_TICK_FRAG,
                                                  O_BANK_DEP_TICK_REC);
        END IF;
        IF (V_ROW_DATA.EXISTSNODE('/BANK_DEP_TICK_UI/BANK_DEP_TICK/MICR_FORMAT_ID/text()') = 1) THEN
            O_MICR_FORMAT_ID := TO_NUMBER(V_ROW_DATA.EXTRACT('/BANK_DEP_TICK_UI/BANK_DEP_TICK/MICR_FORMAT_ID/text()').GETCLOBVAL());
        END IF;
    END IF;
EXCEPTION
    WHEN OTHERS THEN                        
        ERRPKG.RAISE_ERR(SQLCODE, 'BUILD_TABLE_TYPES ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END BUILD_TABLE_TYPES;

FUNCTION IS_FORMAT_CHANGED(
/******************************************************************************
This function will check if the format is changed or not and return Y/N accordingly

Created : 08/21/2015 jxc517 CCN Project....
Changed : 10/20/2016 nxk927 CCN Project....
          Added a check to see if the member sub account changed
        : 11/29/2016 nxk927 CCN Project....
          Removed the member sub account change check
*******************************************************************************/
IN_COST_CENTER_CODE      IN     VARCHAR2,
IN_BANK_ACCOUNT_NBR      IN     VARCHAR2,
IN_FUTURE_ID             IN     NUMBER,
IN_MICR_FORMAT_ID        IN     NUMBER) RETURN VARCHAR2
IS
    V_STORE_MICR_FORMAT_DTLS_REC   STORE_MICR_FORMAT_DTLS%ROWTYPE;
    V_STR_MICR_FORMAT_DTLS_FTR_REC STORE_MICR_FORMAT_DTLS_FUTURE%ROWTYPE;
    V_MICR_FORMAT_ID               NUMBER;
    V_BANK_ACCOUNT_NBR             VARCHAR2(20);
    V_RETURN_VAL                   VARCHAR2(1) := 'N';
BEGIN
    IF IN_FUTURE_ID IS NULL THEN
        V_STORE_MICR_FORMAT_DTLS_REC   := BANKING_COMMON_TOOLS.GET_STORE_MICR_FORMAT_DTLS_REC(IN_COST_CENTER_CODE);
        V_BANK_ACCOUNT_NBR             := V_STORE_MICR_FORMAT_DTLS_REC.BANK_ACCOUNT_NBR;
        V_MICR_FORMAT_ID               := NVL(V_STORE_MICR_FORMAT_DTLS_REC.MICR_FORMAT_ID, 0);
    ELSE
        V_STR_MICR_FORMAT_DTLS_FTR_REC := BANKING_COMMON_TOOLS.GET_STR_MICR_FRMT_DTLS_FTR_REC(IN_COST_CENTER_CODE, IN_FUTURE_ID);
        V_BANK_ACCOUNT_NBR             := V_STR_MICR_FORMAT_DTLS_FTR_REC.BANK_ACCOUNT_NBR;
        V_MICR_FORMAT_ID               := NVL(V_STR_MICR_FORMAT_DTLS_FTR_REC.MICR_FORMAT_ID, 0);
    END IF;
    --Allowing user to make any changes to the deposit Ticket through UI
    --for the existing Sub Accounts that do not match the micr format
    IF NVL(IN_MICR_FORMAT_ID, -1) <> V_MICR_FORMAT_ID
       OR IN_BANK_ACCOUNT_NBR <> V_BANK_ACCOUNT_NBR THEN
        V_RETURN_VAL := 'Y';
    END IF;
    RETURN V_RETURN_VAL;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VAL;
END IS_FORMAT_CHANGED;

PROCEDURE VALIDATE_AND_GET_FORMAT_VALUES(
/******************************************************************************
This procedure will check if the format passed and the actual values support
each other and throw error (or) return calcualted values

Created : 08/21/2015 jxc517 CCN Project....
Changed : 09/14/2016 nxk927 CCN Project....
          validation for the micr details
        : 10/17/2016 nxk927 CCN Project....
          error message updated to ask user to add the micr details for the format desired frm account maintenance screen
          The call to get the micr cost center has been changed to different call.
        : 10/20/2016 nxk927 CCN Project....
          If the format passed is a real format then only validation needs to be done for the format desired.
*******************************************************************************/
IN_BANK_ACCOUNT_NBR   IN     VARCHAR2,
IN_ROUTING_NBR        IN     VARCHAR2,
IN_COST_CENTER_CODE   IN     VARCHAR2,
IN_MICR_FORMAT_ACTNBR IN     VARCHAR2,
IN_MICR_ROUTING_NBR   IN     VARCHAR2,
IN_MICR_COST_CNTR     IN     VARCHAR2,
OUT_MICR_FORMAT_ACTNBR   OUT VARCHAR2,
OUT_MICR_ROUTING_NBR     OUT VARCHAR2,
OUT_MICR_COST_CNTR       OUT VARCHAR2)
IS
    micr_format_conversion         EXCEPTION;
BEGIN
    --If MICR Bank Account Format contains "X" validate the "X" count's with actual bank account numbers digits before replacing
    --IF NOT REGEXP_LIKE(IN_MICR_FORMAT_ACTNBR, '[0-9]+')
    IF REGEXP_LIKE(IN_MICR_FORMAT_ACTNBR, '[X]+')
       AND
       LENGTH(REGEXP_REPLACE(IN_BANK_ACCOUNT_NBR, '[^0-9]+')) <> LENGTH(REGEXP_REPLACE(IN_MICR_FORMAT_ACTNBR, '[^X]+')) THEN
        RAISE micr_format_conversion;
    END IF;

    --If MICR Routing Number Format contains "X" validate the "X" count's with actual bank account numbers digits before replacing
    --IF NOT REGEXP_LIKE(IN_MICR_ROUTING_NBR, '[0-9]+')
    IF IN_ROUTING_NBR IS NOT NULL
       AND
       REGEXP_LIKE(IN_MICR_ROUTING_NBR, '[X]+')
       AND
       LENGTH(REGEXP_REPLACE(IN_ROUTING_NBR, '[^0-9]+')) <> LENGTH(REGEXP_REPLACE(IN_MICR_ROUTING_NBR, '[^X]+')) THEN
        RAISE micr_format_conversion;
    END IF;
    OUT_MICR_FORMAT_ACTNBR := CONVERT_FORMAT_TO_VALUE(IN_MICR_FORMAT_ACTNBR, IN_BANK_ACCOUNT_NBR);
    OUT_MICR_ROUTING_NBR   := CONVERT_FORMAT_TO_VALUE(IN_MICR_ROUTING_NBR, IN_ROUTING_NBR);
    OUT_MICR_COST_CNTR     := CONVERT_MICR_CC_FORMAT(IN_MICR_COST_CNTR, SUBSTR(IN_COST_CENTER_CODE, 3));
EXCEPTION
    WHEN micr_format_conversion THEN
        ERRPKG.RAISE_ERR(errnums.en_micr_format_conversion,
                         'VALIDATE_AND_GET_FORMAT_VALUES',
                         'Format selected does not support the actual bank account/routing number values.Please add micr details with the format from account maintenance first to support that Format');
    WHEN OTHERS THEN
        NULL;
END VALIDATE_AND_GET_FORMAT_VALUES;

PROCEDURE MEMBER_BANK_ACCT_UPDATE(
/********************************************************************************
This procedure is intended to update member_bank_cc/member bank_cc_future table
with the passed member bank account number

Created : 10/20/2016 nxk927 CCN Project....
Changed : 11/29/2016 nxk927 CCN Project...
          update only when the member account number changes.
Changed : 12/02/2016 nxk927 CCN Project...
          Added the NVL for the passed bank account number as well as it might be
          passed as null
********************************************************************************/
  IN_COST_CENTER_CODE    IN     VARCHAR2,
  IN_MBR_BANK_ACCT_NBR   IN     VARCHAR2,
  IN_USER_ID             IN     VARCHAR2,
  IN_LEAD_BANK_ACCT_NBR  IN     VARCHAR2 DEFAULT NULL,
  IN_FUTURE_ID           IN     VARCHAR2 DEFAULT NULL)
IS
  BEGIN
    IF IN_FUTURE_ID IS NULL THEN
       UPDATE MEMBER_BANK_CC
          SET MEMBER_BANK_ACCOUNT_NBR           = IN_MBR_BANK_ACCT_NBR,
              UPDATE_DATE                       = SYSDATE,
              LAST_UPD_USER_ID                  = IN_USER_ID
        WHERE MEMBER_STORE_NBR                  = IN_COST_CENTER_CODE
          AND NVL(MEMBER_BANK_ACCOUNT_NBR, 'X') <> NVL(IN_MBR_BANK_ACCT_NBR,'X');
    ELSE
        UPDATE MEMBER_BANK_CC_FUTURE
          SET MEMBER_BANK_ACCOUNT_NBR           = IN_MBR_BANK_ACCT_NBR,
              UPDATE_DATE                       = SYSDATE,
              LAST_UPD_USER_ID                  = IN_USER_ID
        WHERE MEMBER_STORE_NBR                  = IN_COST_CENTER_CODE
          AND LEAD_BANK_ACCOUNT_NBR             = IN_LEAD_BANK_ACCT_NBR
          AND FUTURE_ID                         = IN_FUTURE_ID
          AND NVL(MEMBER_BANK_ACCOUNT_NBR, 'X') <> NVL(IN_MBR_BANK_ACCT_NBR,'X');
    END IF;
  EXCEPTION
     WHEN OTHERS THEN
         ERRPKG.RAISE_ERR(SQLCODE, 'MEMBER_BANK_ACCT_UPDATE', SUBSTR(SQLERRM,1,500));
END MEMBER_BANK_ACCT_UPDATE;

PROCEDURE DEPOSIT_TKT_CURRENT_UPSERT_SP( 
/******************************************************************************
This procedure is intended to update following table used in the
Deposit Ticket Maintenance Window that are current records
    Tables: 
       BANK_DEP_TICK

Created : 08/21/2015 jxc517 CCN Project....
Changed : 11/05/2015 jxc517 CCN Project....
          If the store MICR format change, we need to recalculate (if needed) the number of deposit tickets per book
        : 10/17/2016 nxk927 CCN Project....
          Signature change to include the member bank account and consider the member bank account for the validation
          Updating the member bank account for the member cost center
        : 10/20/2016 nxk927 CCN Project....
          Calling the update procedure directly for the member bank account number
          Signature changed for IS_FORMAT_CHANGED procedure
          Passing the parameter IN_MBR_BANK_ACCT_NBR as parameter
        : 11/29/2016 nxk927/jxc517 CCN Project...
          Validating the micr format only when the IN_MBR_BANK_ACCT_NBR is null.
          Member bank account can be passed as null. Removing the check condition for the update even
          if the member bank account is passed back as null.
        : 12/08/2016 nxk927 CCN Project...
          if the effective date is passed, used the same date if there is no change,
          else sysdate.
          Signature changed to get the standard ticket fields from the reference table
*******************************************************************************/
    IN_BANK_DEP_TICK_REC  IN     BANK_DEP_TICK%ROWTYPE,
    IN_MICR_FORMAT_ID     IN     NUMBER,
    IN_MBR_BANK_ACCT_NBR  IN     VARCHAR2 DEFAULT NULL)
IS
    V_STORE_MICR_FORMAT_DTLS_REC STORE_MICR_FORMAT_DTLS%ROWTYPE;
    V_BANK_MICR_FORMAT_REC       BANK_MICR_FORMAT%ROWTYPE;
    V_BANK_DEP_TICK_HIST_REC     BANK_DEP_TICK%ROWTYPE;
    V_BANK_DEP_TICK_REC          BANK_DEP_TICK%ROWTYPE := IN_BANK_DEP_TICK_REC;    
    V_BANK_ACCOUNT_REC           BANK_ACCOUNT%ROWTYPE;
    V_EXPIRATION_DATE            DATE;
    V_PROC_NAME                  VARCHAR2(30) := 'DEPOSIT_TKT_CURRENT_UPSERT_SP';
BEGIN
    BEGIN
        SELECT *
          INTO V_BANK_DEP_TICK_HIST_REC
          FROM BANK_DEP_TICK
         WHERE COST_CENTER_CODE = V_BANK_DEP_TICK_REC.COST_CENTER_CODE;
        TABLE_IU_PKG.BANK_DEP_TICK_HIST_I_SP(V_BANK_DEP_TICK_HIST_REC);
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    V_BANK_DEP_TICK_REC.EFFECTIVE_DATE  := NVL(V_BANK_DEP_TICK_REC.EFFECTIVE_DATE, SYSDATE);
    TABLE_IU_PKG.BANK_DEP_TICK_I_SP(V_BANK_DEP_TICK_REC);
    IF IS_FORMAT_CHANGED(V_BANK_DEP_TICK_REC.COST_CENTER_CODE,
                         V_BANK_DEP_TICK_REC.BANK_ACCOUNT_NBR,
                         NULL,
                         IN_MICR_FORMAT_ID) = 'Y' THEN
        BEGIN
            SELECT *
              INTO V_STORE_MICR_FORMAT_DTLS_REC
              FROM STORE_MICR_FORMAT_DTLS
             WHERE COST_CENTER_CODE = V_BANK_DEP_TICK_REC.COST_CENTER_CODE;
            V_EXPIRATION_DATE := V_STORE_MICR_FORMAT_DTLS_REC.EXPIRATION_DATE;
            TABLE_IU_PKG.STR_MICR_FRMT_DTLS_HIST_I_SP(V_STORE_MICR_FORMAT_DTLS_REC);
        EXCEPTION
            WHEN OTHERS THEN
                NULL;
        END;
        IF IN_MICR_FORMAT_ID IS NOT NULL THEN --there is no new format, expire the old record and don't update anything else
            V_BANK_MICR_FORMAT_REC := BANKING_COMMON_TOOLS.GET_STORE_BANK_MICR_FORMAT_REC(V_BANK_DEP_TICK_REC.BANK_ACCOUNT_NBR,
                                                                                          IN_MICR_FORMAT_ID);
            V_BANK_ACCOUNT_REC := BANKING_COMMON_TOOLS.GET_BANK_ACCOUNT_REC(V_BANK_DEP_TICK_REC.BANK_ACCOUNT_NBR);
            V_STORE_MICR_FORMAT_DTLS_REC.COST_CENTER_CODE := V_BANK_DEP_TICK_REC.COST_CENTER_CODE;
            V_STORE_MICR_FORMAT_DTLS_REC.BANK_ACCOUNT_NBR := V_BANK_DEP_TICK_REC.BANK_ACCOUNT_NBR;
            IF IN_MBR_BANK_ACCT_NBR IS NULL THEN
                VALIDATE_AND_GET_FORMAT_VALUES(NVL(IN_MBR_BANK_ACCT_NBR,V_BANK_DEP_TICK_REC.BANK_ACCOUNT_NBR),
                                               V_BANK_ACCOUNT_REC.ROUTING_NBR,
                                               V_BANK_DEP_TICK_REC.COST_CENTER_CODE,
                                               V_BANK_MICR_FORMAT_REC.MICR_FORMAT_ACTNBR,
                                               V_BANK_MICR_FORMAT_REC.MICR_ROUTING_NBR,
                                               V_BANK_MICR_FORMAT_REC.MICR_COST_CNTR,
                                               V_STORE_MICR_FORMAT_DTLS_REC.MICR_FORMAT_ACCT_NBR, --out
                                               V_STORE_MICR_FORMAT_DTLS_REC.MICR_ROUTING_NBR, --out
                                               V_STORE_MICR_FORMAT_DTLS_REC.MICR_COST_CNTR); --out
            ELSE
                V_STORE_MICR_FORMAT_DTLS_REC.MICR_FORMAT_ACCT_NBR := V_BANK_MICR_FORMAT_REC.MICR_FORMAT_ACTNBR;
                V_STORE_MICR_FORMAT_DTLS_REC.MICR_ROUTING_NBR     := V_BANK_MICR_FORMAT_REC.MICR_ROUTING_NBR;
                V_STORE_MICR_FORMAT_DTLS_REC.MICR_COST_CNTR       := V_BANK_MICR_FORMAT_REC.MICR_COST_CNTR;
            END IF;
            V_STORE_MICR_FORMAT_DTLS_REC.MICR_FORMAT_ID  := IN_MICR_FORMAT_ID;
            V_STORE_MICR_FORMAT_DTLS_REC.EFFECTIVE_DATE  := SYSDATE;
            V_STORE_MICR_FORMAT_DTLS_REC.EXPIRATION_DATE := V_EXPIRATION_DATE;
            TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_I_SP(V_STORE_MICR_FORMAT_DTLS_REC);
            --If the store MICR format change, we need to verify if the part paper per form changed or not
            --if it changes, we need to recalculate the number of deposit tickets per book
            --Example : PART2 => 324/2 = 162, PART3 => 324/3 = 108, PART4 => 324/4 = 81
            --Then we need to update the data accordingly in BANK_DEP_TICK_* table
            CALCULATE_DEPOSIT_TICKET(V_BANK_MICR_FORMAT_REC.DJDE_FEED_PARM,
                                     V_BANK_DEP_TICK_REC.PART_PAPER_PER_FORM,
                                     V_BANK_DEP_TICK_REC.NBR_DEP_TICKETS_PER_BK,
                                     V_BANK_DEP_TICK_REC.IMAGES_PER_PAGE,
                                     V_BANK_DEP_TICK_REC.NBR_FORMS_PER_BK,
                                     V_BANK_DEP_TICK_REC.SHEETS_OF_PAPER_PER_BK,
                                     V_BANK_DEP_TICK_REC.REORDER_NUMBER_BKS);
            TABLE_IU_PKG.BANK_DEP_TICK_I_SP(V_BANK_DEP_TICK_REC);
        ELSE
            IF V_STORE_MICR_FORMAT_DTLS_REC.COST_CENTER_CODE IS NOT NULL THEN
                TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_D_SP(V_STORE_MICR_FORMAT_DTLS_REC);
            END IF;
        END IF;
    END IF;
    MEMBER_BANK_ACCT_UPDATE(V_BANK_DEP_TICK_REC.COST_CENTER_CODE,
                            IN_MBR_BANK_ACCT_NBR,
                            V_BANK_DEP_TICK_REC.LAST_MAINT_USER_ID);
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME || ' ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END DEPOSIT_TKT_CURRENT_UPSERT_SP;

PROCEDURE EXPIRE_PREV_CUR_DEPOSIT_DTLS(
/*******************************************************************************
    This procedure is intended to check and expire previous current deposit details records
    before inserting new record

Created : 08/24/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE IN     VARCHAR2,
IN_EFFECTIVE_DATE   IN     DATE)
IS
    CURSOR bank_dep_tick_cur IS
        SELECT *
          FROM BANK_DEP_TICK
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EFFECTIVE_DATE  <  IN_EFFECTIVE_DATE
           AND EXPIRATION_DATE IS NULL;
    CURSOR bank_dep_tickord_cur IS
        SELECT *
          FROM BANK_DEP_TICKORD
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EFFECTIVE_DATE  <  IN_EFFECTIVE_DATE
           AND EXPIRATION_DATE IS NULL;
    CURSOR str_micr_format_dtls_cur IS
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EFFECTIVE_DATE  <  IN_EFFECTIVE_DATE
           AND EXPIRATION_DATE IS NULL;
    V_PROC_NAME                VARCHAR2(30) := 'EXPIRE_PREV_CUR_DEPOSIT_DTLS';
    V_EXPIRE_DATE              DATE := IN_EFFECTIVE_DATE - INTERVAL '1' SECOND;
BEGIN
    FOR rec IN bank_dep_tick_cur LOOP
        rec.EXPIRATION_DATE := GREATEST(rec.EFFECTIVE_DATE, V_EXPIRE_DATE);
        TABLE_IU_PKG.BANK_DEP_TICK_I_SP(rec);
    END LOOP;
    FOR rec IN bank_dep_tickord_cur LOOP
        rec.EXPIRATION_DATE := GREATEST(rec.EFFECTIVE_DATE, V_EXPIRE_DATE);
        TABLE_IU_PKG.BANK_DEP_TICKORD_I_SP(rec);
    END LOOP;    
    FOR rec IN str_micr_format_dtls_cur LOOP
        rec.EXPIRATION_DATE := GREATEST(rec.EFFECTIVE_DATE, V_EXPIRE_DATE);
        TABLE_IU_PKG.STORE_MICR_FORMAT_DTLS_I_SP(rec);
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME, SUBSTR(SQLERRM,1,500));
END EXPIRE_PREV_CUR_DEPOSIT_DTLS;

PROCEDURE EXPIRE_PREV_FTR_DEPOSIT_DTLS(
/*******************************************************************************
    This procedure is intended to check and expire previous future deposit details records
    before inserting new record

Created : 08/24/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE IN     VARCHAR2,
IN_EFFECTIVE_DATE   IN     DATE)
IS
    CURSOR bank_dep_tick_future_cur IS
        SELECT *
          FROM BANK_DEP_TICK_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EFFECTIVE_DATE  <  IN_EFFECTIVE_DATE
           AND EXPIRATION_DATE IS NULL;
    CURSOR bank_dep_tickord_future_cur IS
        SELECT *
          FROM BANK_DEP_TICKORD_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EFFECTIVE_DATE  <  IN_EFFECTIVE_DATE
           AND EXPIRATION_DATE IS NULL;           
    CURSOR str_micr_format_dtls_ftr_cur IS
        SELECT *
          FROM STORE_MICR_FORMAT_DTLS_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND EFFECTIVE_DATE  <  IN_EFFECTIVE_DATE
           AND EXPIRATION_DATE IS NULL;
    V_PROC_NAME                VARCHAR2(30) := 'EXPIRE_PREV_FTR_DEPOSIT_DTLS';
    V_EXPIRE_DATE              DATE := IN_EFFECTIVE_DATE - INTERVAL '1' SECOND;
BEGIN
    FOR rec IN bank_dep_tick_future_cur LOOP
        rec.EXPIRATION_DATE := GREATEST(rec.EFFECTIVE_DATE, V_EXPIRE_DATE);
        TABLE_IU_PKG.BANK_DEP_TICK_FUTURE_I_SP(rec);
    END LOOP;
    FOR rec IN bank_dep_tickord_future_cur LOOP
        rec.EXPIRATION_DATE := GREATEST(rec.EFFECTIVE_DATE, V_EXPIRE_DATE);
        TABLE_IU_PKG.BANK_DEP_TICKORD_FUTURE_I_SP(rec);
    END LOOP;
    FOR rec IN str_micr_format_dtls_ftr_cur LOOP
        rec.EXPIRATION_DATE := GREATEST(rec.EFFECTIVE_DATE, V_EXPIRE_DATE);
        TABLE_IU_PKG.STR_MICR_FORMAT_DTLS_FTR_I_SP(rec);
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME, SUBSTR(SQLERRM,1,500));
END EXPIRE_PREV_FTR_DEPOSIT_DTLS;

PROCEDURE EXPIRE_PREVIOUS_DEP_TICK_DTLS(
/*******************************************************************************
    This procedure is intended to check and expire previous deposit details records
    before inserting new record

Created : 08/24/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE IN     VARCHAR2,
IN_EFFECTIVE_DATE   IN     DATE)
IS
    V_PROC_NAME                VARCHAR2(30) := 'EXPIRE_PREVIOUS_DEP_TICK_DTLS';
BEGIN
    EXPIRE_PREV_CUR_DEPOSIT_DTLS(IN_COST_CENTER_CODE, IN_EFFECTIVE_DATE);
    EXPIRE_PREV_FTR_DEPOSIT_DTLS(IN_COST_CENTER_CODE, IN_EFFECTIVE_DATE);
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME, SUBSTR(SQLERRM,1,500));
END EXPIRE_PREVIOUS_DEP_TICK_DTLS;

PROCEDURE DEPOSIT_TKT_FUTURE_UPSERT_SP( 
/******************************************************************************
This procedure is intended to update following table used in the
Deposit Ticket Maintenance Window that are future records
    Tables: 
       BANK_DEP_TICK

Created : 08/24/2015 jxc517 CCN Project....
Changed : 10/29/2015 nxk927 CCN Project.... 
          DEP_TKTS_ONHAND_QTY start with 0
          YTD_DEP_TKTS_ORDERED_QTY start with 0
Changed : 11/05/2015 jxc517 CCN Project....
          If the store MICR format change, we need to recalculate (if needed) the number of deposit tickets per book
        : 10/17/2016 nxk927 CCN Project.... 
          Signature change to include the member bank account and consider the member bank account for the validation
          Updating the member bank account for the member cost center
        : 10/20/2016 nxk927 CCN Project....
          Calling the update procedure directly for the member bank account number
          Signature changed for IS_FORMAT_CHANGED procedure
          Passing the parameter IN_MBR_BANK_ACCT_NBR as parameter
        : 11/29/2016 nxk927/jxc517 CCN Project...
          Validating the micr format only when the IN_MBR_BANK_ACCT_NBR is null.
          added the nvl condition to calculate the tickets correctly
          Member bank account can be passed as null. Removing the check condition for the update even
          if the member bank account is passed back as null.
        : 12/08/2016 nxk927 CCN Project...
          Signature changed to get the standard ticket fields from the reference table
*******************************************************************************/
    IN_BANK_DEP_TICK_FUTURE_REC  IN     BANK_DEP_TICK_FUTURE%ROWTYPE,
    IN_MICR_FORMAT_ID            IN     NUMBER,
    IN_MBR_FTR_BNK_ACCT_NBR      IN     VARCHAR2 DEFAULT NULL)
IS
    V_STR_MICR_FORMAT_DTLS_FTR_REC STORE_MICR_FORMAT_DTLS_FUTURE%ROWTYPE;
    V_BANK_MICR_FORMAT_FUTURE_REC  BANK_MICR_FORMAT_FUTURE%ROWTYPE;
    V_BANK_ACCOUNT_FUTURE_REC      BANK_ACCOUNT_FUTURE%ROWTYPE;
    V_BANK_DEP_TICK_FUTURE_REC     BANK_DEP_TICK_FUTURE%ROWTYPE := IN_BANK_DEP_TICK_FUTURE_REC;
    V_PROC_NAME                    VARCHAR2(30) := 'DEPOSIT_TKT_FUTURE_UPSERT_SP';
BEGIN
    EXPIRE_PREVIOUS_DEP_TICK_DTLS(V_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE, V_BANK_DEP_TICK_FUTURE_REC.EFFECTIVE_DATE);
    --Future DEP_TKTS_ONHAND_QTY and YTD_DEP_TKTS_ORDERED_QTY always reset to zero.
    V_BANK_DEP_TICK_FUTURE_REC.DEP_TKTS_ONHAND_QTY       := 0; 
    V_BANK_DEP_TICK_FUTURE_REC.YTD_DEP_TKTS_ORDERED_QTY  := 0;
    TABLE_IU_PKG.BANK_DEP_TICK_FUTURE_I_SP(V_BANK_DEP_TICK_FUTURE_REC);
    IF IS_FORMAT_CHANGED(V_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE,
                         V_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR,
                         V_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID,
                         IN_MICR_FORMAT_ID) = 'Y' THEN
        IF IN_MICR_FORMAT_ID IS NOT NULL THEN
            V_BANK_MICR_FORMAT_FUTURE_REC := BANKING_COMMON_TOOLS.GET_STR_BANK_MICR_FRMT_FTR_REC(V_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR,
                                                                                                 IN_MICR_FORMAT_ID,
                                                                                                 V_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID);
            BEGIN
                SELECT *
                  INTO V_BANK_ACCOUNT_FUTURE_REC
                  FROM BANK_ACCOUNT_FUTURE
                 WHERE BANK_ACCOUNT_NBR = V_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR
                   AND FUTURE_ID        = V_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID;
            EXCEPTION
                WHEN OTHERS THEN
                    NULL;
            END;
            V_STR_MICR_FORMAT_DTLS_FTR_REC.COST_CENTER_CODE := V_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE;
            V_STR_MICR_FORMAT_DTLS_FTR_REC.BANK_ACCOUNT_NBR := V_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR;
            IF IN_MBR_FTR_BNK_ACCT_NBR IS NULL THEN
                VALIDATE_AND_GET_FORMAT_VALUES(NVL(IN_MBR_FTR_BNK_ACCT_NBR,V_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR),
                                           V_BANK_ACCOUNT_FUTURE_REC.ROUTING_NBR,
                                           V_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE,
                                           V_BANK_MICR_FORMAT_FUTURE_REC.MICR_FORMAT_ACTNBR,
                                           V_BANK_MICR_FORMAT_FUTURE_REC.MICR_ROUTING_NBR,
                                           V_BANK_MICR_FORMAT_FUTURE_REC.MICR_COST_CNTR,
                                           V_STR_MICR_FORMAT_DTLS_FTR_REC.MICR_FORMAT_ACCT_NBR, --out
                                           V_STR_MICR_FORMAT_DTLS_FTR_REC.MICR_ROUTING_NBR, --out
                                           V_STR_MICR_FORMAT_DTLS_FTR_REC.MICR_COST_CNTR); --out
            ELSE
                V_STR_MICR_FORMAT_DTLS_FTR_REC.MICR_FORMAT_ACCT_NBR := V_BANK_MICR_FORMAT_FUTURE_REC.MICR_FORMAT_ACTNBR;
                V_STR_MICR_FORMAT_DTLS_FTR_REC.MICR_ROUTING_NBR     := V_BANK_MICR_FORMAT_FUTURE_REC.MICR_ROUTING_NBR;
                V_STR_MICR_FORMAT_DTLS_FTR_REC.MICR_COST_CNTR       := V_BANK_MICR_FORMAT_FUTURE_REC.MICR_COST_CNTR;
            END IF;
            V_STR_MICR_FORMAT_DTLS_FTR_REC.EFFECTIVE_DATE   := V_BANK_DEP_TICK_FUTURE_REC.EFFECTIVE_DATE;
            V_STR_MICR_FORMAT_DTLS_FTR_REC.EXPIRATION_DATE  := V_BANK_DEP_TICK_FUTURE_REC.EXPIRATION_DATE;
            V_STR_MICR_FORMAT_DTLS_FTR_REC.MICR_FORMAT_ID   := IN_MICR_FORMAT_ID;
            V_STR_MICR_FORMAT_DTLS_FTR_REC.FUTURE_ID        := V_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID;
            TABLE_IU_PKG.STR_MICR_FORMAT_DTLS_FTR_I_SP(V_STR_MICR_FORMAT_DTLS_FTR_REC);
            --If the store MICR format change, we need to verify if the part paper per form changed or not
            --if it changes, we need to recalculate the number of deposit tickets per book
            --Example : PART2 => 324/2 = 162, PART3 => 324/3 = 108, PART4 => 324/4 = 81
            --Then we need to update the data accordingly in BANK_DEP_TICK_* table
            CALCULATE_DEPOSIT_TICKET(V_BANK_MICR_FORMAT_FUTURE_REC.DJDE_FEED_PARM,
                                     V_BANK_DEP_TICK_FUTURE_REC.PART_PAPER_PER_FORM,
                                     V_BANK_DEP_TICK_FUTURE_REC.NBR_DEP_TICKETS_PER_BK,
                                     V_BANK_DEP_TICK_FUTURE_REC.IMAGES_PER_PAGE,
                                     V_BANK_DEP_TICK_FUTURE_REC.NBR_FORMS_PER_BK,
                                     V_BANK_DEP_TICK_FUTURE_REC.SHEETS_OF_PAPER_PER_BK,
                                     V_BANK_DEP_TICK_FUTURE_REC.REORDER_NUMBER_BKS);
            TABLE_IU_PKG.BANK_DEP_TICK_FUTURE_I_SP(V_BANK_DEP_TICK_FUTURE_REC);
        ELSE
            BEGIN
                SELECT *
                  INTO V_STR_MICR_FORMAT_DTLS_FTR_REC
                  FROM STORE_MICR_FORMAT_DTLS_FUTURE
                 WHERE COST_CENTER_CODE = V_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE
                   AND FUTURE_ID        = V_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID;
            EXCEPTION
                WHEN OTHERS THEN
                    NULL;
            END;
            IF V_STR_MICR_FORMAT_DTLS_FTR_REC.COST_CENTER_CODE IS NOT NULL THEN
                TABLE_IU_PKG.STR_MICR_FORMAT_DTLS_FTR_D_SP(V_STR_MICR_FORMAT_DTLS_FTR_REC);
            END IF;
        END IF;
    END IF;
    MEMBER_BANK_ACCT_UPDATE(V_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE,
                            IN_MBR_FTR_BNK_ACCT_NBR,
                            V_BANK_DEP_TICK_FUTURE_REC.LAST_MAINT_USER_ID,
                            V_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR,
                            V_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID);
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME || ' ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END DEPOSIT_TKT_FUTURE_UPSERT_SP;

PROCEDURE DEPOSIT_TKT_MNTNC_UI_UPSERT_SP( 
/******************************************************************************
	This procedure performs the core process for Deposit Ticket Maintenance Window

Created : 07/14/2015 jxc517 CCN Project....
Changed : 08/13/2015 nxk927 CCN Project....
          Removed trunc to accept the time stamp
Changed : 10/27/2015 jxc517 CCN Project....
          For current records we need to push current into history and insert a new
          record with SYSDATE
          For future records we need to use the data that is passed back from UI
        : 10/17/2016 nxk927 CCN Project....
          Signature changed to include the member bank account number as parameter
          which will be used in the current and future upsert procedure
        : 12/08/2016 nxk927 CCN Project....
          Effective date to be taken as being passed.
*******************************************************************************/
    IN_ROW_DATA         IN  CLOB,
    IN_MBR_BNK_ACCT_NBR IN VARCHAR2 DEFAULT NULL)
IS
    V_BANK_DEP_TICK_FUTURE_REC      BANK_DEP_TICK_FUTURE%ROWTYPE;
    V_BANK_DEP_TICK_REC             BANK_DEP_TICK%ROWTYPE;
    V_MICR_FORMAT_ID                NUMBER := NULL;
BEGIN
    
    BUILD_TABLE_TYPES(IN_ROW_DATA,
                      V_BANK_DEP_TICK_REC,
                      V_BANK_DEP_TICK_FUTURE_REC,
                      V_MICR_FORMAT_ID);
    --V_BANK_DEP_TICK_REC.EFFECTIVE_DATE := SYSDATE;
    BUSINESS_RULES_PKG.DEPOSIT_TICKET_MNTNC_BR_SP(V_BANK_DEP_TICK_REC,
                                                  V_BANK_DEP_TICK_FUTURE_REC);
    IF V_BANK_DEP_TICK_REC.COST_CENTER_CODE IS NOT NULL THEN --Current Details
        DEPOSIT_TKT_CURRENT_UPSERT_SP(V_BANK_DEP_TICK_REC, V_MICR_FORMAT_ID, IN_MBR_BNK_ACCT_NBR);
    END IF;
    IF V_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE IS NOT NULL THEN --Future Details
        DEPOSIT_TKT_FUTURE_UPSERT_SP(V_BANK_DEP_TICK_FUTURE_REC, V_MICR_FORMAT_ID,IN_MBR_BNK_ACCT_NBR);
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, 'DEPOSIT_TKT_MNTNC_UI_UPSERT_SP ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END DEPOSIT_TKT_MNTNC_UI_UPSERT_SP;

PROCEDURE GET_BANK_MICR_FORMAT_FTR_REC(
/*******************************************************************************
This procedure is get the bank micr format future recrod based on previous bank account
and format id combinatin. If it is not found it builds one

Created : 08/25/2015 jxc517 CCN Project....
Changed : 11/23/2015 nxk927 CCN Project....
          assigning the prev micr format effective date if the passed effective date is null
          This is for the virtual future
*******************************************************************************/
IN_COST_CENTER_CODE          IN     VARCHAR2,
IN_BANK_ACCOUNT_NBR          IN     VARCHAR2,
IN_FUTURE_ID                 IN     NUMBER,
IN_EFFECTIVE_DATE            IN     DATE,
OUT_BANK_MICR_FORMAT_FTR_REC    OUT BANK_MICR_FORMAT_FUTURE%ROWTYPE)
IS
    V_STR_MICR_FRMT_DTLS_PREV_REC  STORE_MICR_FORMAT_DTLS%ROWTYPE;
    V_BANK_MICR_FRMT_FTR_PREV_REC  BANK_MICR_FORMAT_FUTURE%ROWTYPE;
    V_BANK_MICR_FORMAT_FUTURE_REC  BANK_MICR_FORMAT_FUTURE%ROWTYPE;
    V_BANK_ACCOUNT_FUTURE_REC      BANK_ACCOUNT_FUTURE%ROWTYPE;
    V_MICR_FORMAT_ID               NUMBER := NULL;
    V_EFFECTIVE_DATE               DATE;
BEGIN
    V_STR_MICR_FRMT_DTLS_PREV_REC := BANKING_COMMON_TOOLS.GET_STORE_MICR_FORMAT_DTLS_REC(IN_COST_CENTER_CODE);
    IF V_STR_MICR_FRMT_DTLS_PREV_REC.COST_CENTER_CODE IS NOT NULL THEN
        BEGIN
            SELECT BANK_ACCOUNT_NBR,
                   FORMAT_NAME,
                   DJDE_FORM_PARM,
                   DJDE_FEED_PARM,
                   MICR_COST_CNTR,
                   MICR_ROUTING_NBR,
                   MICR_FORMAT_ACTNBR,
                   EFFECTIVE_DATE,
                   EXPIRATION_DATE,
                   LAST_MAINTENANCE_DATE,
                   LAST_MAINT_USER_ID,
                   UPDATE_DATE,
                   LAST_UPD_USER_ID,
                   NULL FUTURE_ID,
                   MICR_FORMAT_ID
              INTO V_BANK_MICR_FRMT_FTR_PREV_REC
              FROM BANK_MICR_FORMAT
             WHERE BANK_ACCOUNT_NBR = V_STR_MICR_FRMT_DTLS_PREV_REC.BANK_ACCOUNT_NBR
               AND MICR_FORMAT_ID   = V_STR_MICR_FRMT_DTLS_PREV_REC.MICR_FORMAT_ID;
        EXCEPTION
            WHEN OTHERS THEN
                NULL;
        END;
        V_EFFECTIVE_DATE := NVL(IN_EFFECTIVE_DATE,V_BANK_MICR_FRMT_FTR_PREV_REC.EFFECTIVE_DATE);
        V_MICR_FORMAT_ID := BANKING_COMMON_TOOLS.GET_MICR_FRMT_ID_FR_BA_FRMT_NM(IN_BANK_ACCOUNT_NBR,
                                                                                V_BANK_MICR_FRMT_FTR_PREV_REC.FORMAT_NAME,
                                                                                IN_FUTURE_ID);
        IF V_MICR_FORMAT_ID IS NOT NULL THEN --a MICR with that format name already exists for this new bank account number
            V_BANK_MICR_FORMAT_FUTURE_REC := BANKING_COMMON_TOOLS.GET_STR_BANK_MICR_FRMT_FTR_REC(IN_BANK_ACCOUNT_NBR,
                                                                                                 V_MICR_FORMAT_ID,
                                                                                                 IN_FUTURE_ID);
        ELSE --a MICR with that format name does not exist for this new bank account number, so build and insert one
            V_BANK_MICR_FORMAT_FUTURE_REC := V_BANK_MICR_FRMT_FTR_PREV_REC;
            V_BANK_MICR_FORMAT_FUTURE_REC.BANK_ACCOUNT_NBR      := IN_BANK_ACCOUNT_NBR;
            V_BANK_MICR_FORMAT_FUTURE_REC.FUTURE_ID             := IN_FUTURE_ID;
            V_BANK_MICR_FORMAT_FUTURE_REC.MICR_FORMAT_ID        := BANKING_COMMON_TOOLS.GET_NEXT_MICR_FORMAT_ID(IN_BANK_ACCOUNT_NBR, 'F');
            V_BANK_MICR_FORMAT_FUTURE_REC.EFFECTIVE_DATE        := V_EFFECTIVE_DATE;
            V_BANK_ACCOUNT_FUTURE_REC := BANKING_COMMON_TOOLS.GET_BANK_ACCOUNT_FUTURE_REC(IN_BANK_ACCOUNT_NBR, IN_FUTURE_ID);
            V_BANK_MICR_FORMAT_FUTURE_REC.EXPIRATION_DATE       := V_BANK_ACCOUNT_FUTURE_REC.EXPIRATION_DATE;
            V_BANK_MICR_FORMAT_FUTURE_REC.LAST_MAINTENANCE_DATE := TRUNC(SYSDATE);
            --V_BANK_MICR_FORMAT_FUTURE_REC.LAST_MAINT_USER_ID    := 'CODBLT';
            V_BANK_MICR_FORMAT_FUTURE_REC.UPDATE_DATE           := TRUNC(SYSDATE);
            --V_BANK_MICR_FORMAT_FUTURE_REC.LAST_UPD_USER_ID      := 'CODEBLT';
            INSERT INTO BANK_MICR_FORMAT_FUTURE VALUES V_BANK_MICR_FORMAT_FUTURE_REC;
        END IF;
        OUT_BANK_MICR_FORMAT_FTR_REC := V_BANK_MICR_FORMAT_FUTURE_REC;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END GET_BANK_MICR_FORMAT_FTR_REC;

PROCEDURE INSERT_BANK_DEPOSIT_DTLS_FTR(
/*******************************************************************************
This procedure is intended to build the STORE_MICR_FORMAT_DTLS_FUTURE, 
BANK_DEP_TICK_FUTURE records and insert the same

Created : 08/25/2015 jxc517 CCN Project....
Changed : 11/02/2015 nxk927 CCN Project....
          Future DEP_TKTS_ONHAND_QTY and YTD_DEP_TKTS_ORDERED_QTY always reset to zero.
Changed : 11/05/2015 jxc517 CCN Project....
          If the store MICR format change, we need to recalculate (if needed) the number of deposit tickets per book
        : 11/20/2015 nxk927 CCN Project....
          assigning the effective date from prev record if it is passed as null.
          This is for the virtual future
        : 10/24/2015 nxk927 CCN Project....
          removing the Store MICR format re-validation while creating lead future details as part of transfer process
        : 12/08/2016 nxk927 CCN Project....
          signature changed to get the deposit ticket standard fields from the reference table
*******************************************************************************/
IN_COST_CENTER_CODE     IN    VARCHAR2,
IN_BANK_ACCOUNT_NBR     IN    VARCHAR2,
IN_FUTURE_ID            IN    NUMBER,
IN_EFFECTIVE_DATE       IN    DATE,
IN_EXPIRATION_DATE      IN    DATE,
IN_BANK_TYPE_CODE       IN    VARCHAR2)
IS
    V_BANK_DEP_TICK_FTR_PREV_REC   BANK_DEP_TICK_FUTURE%ROWTYPE;
    V_BANK_MICR_FORMAT_FUTURE_REC  BANK_MICR_FORMAT_FUTURE%ROWTYPE;
    V_BANK_DEP_TICK_FUTURE_REC     BANK_DEP_TICK_FUTURE%ROWTYPE;
    V_STR_MICR_FRMT_DTLS_FTR_REC   STORE_MICR_FORMAT_DTLS_FUTURE%ROWTYPE;
    V_STR_MICR_FRMT_DTLS_REC       STORE_MICR_FORMAT_DTLS%ROWTYPE;
    V_EFFECTIVE_DATE               DATE;
BEGIN
    BEGIN
        SELECT A.*,
               NULL FUTURE_ID
          INTO V_BANK_DEP_TICK_FTR_PREV_REC
          FROM BANK_DEP_TICK A
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE;
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    V_EFFECTIVE_DATE := NVL(IN_EFFECTIVE_DATE,V_BANK_DEP_TICK_FTR_PREV_REC.EFFECTIVE_DATE);
    IF V_BANK_DEP_TICK_FTR_PREV_REC.COST_CENTER_CODE IS NOT NULL THEN
        V_BANK_DEP_TICK_FUTURE_REC := V_BANK_DEP_TICK_FTR_PREV_REC;
        V_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR          := IN_BANK_ACCOUNT_NBR;
        V_BANK_DEP_TICK_FUTURE_REC.EFFECTIVE_DATE            := V_EFFECTIVE_DATE;
        V_BANK_DEP_TICK_FUTURE_REC.EXPIRATION_DATE           := IN_EXPIRATION_DATE;
        V_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID                 := IN_FUTURE_ID;
        V_BANK_DEP_TICK_FUTURE_REC.LAST_MAINTENANCE_DATE     := SYSDATE;
        V_BANK_DEP_TICK_FUTURE_REC.LAST_MAINT_USER_ID        := 'CODBLT';
        --Future DEP_TKTS_ONHAND_QTY and YTD_DEP_TKTS_ORDERED_QTY always reset to zero.
        V_BANK_DEP_TICK_FUTURE_REC.DEP_TKTS_ONHAND_QTY       := 0;
        V_BANK_DEP_TICK_FUTURE_REC.YTD_DEP_TKTS_ORDERED_QTY  := 0;
        TABLE_IU_PKG.BANK_DEP_TICK_FUTURE_I_SP(V_BANK_DEP_TICK_FUTURE_REC);
    END IF;
    IF NVL(IN_BANK_TYPE_CODE, 'X') <> 'M' THEN
        GET_BANK_MICR_FORMAT_FTR_REC(IN_COST_CENTER_CODE,
                                     IN_BANK_ACCOUNT_NBR,
                                     IN_FUTURE_ID,
                                     IN_EFFECTIVE_DATE,
                                     V_BANK_MICR_FORMAT_FUTURE_REC);
       --Lead future is getting created here as part of transfer, so just copy the leads current format into future tables
       IF V_BANK_MICR_FORMAT_FUTURE_REC.MICR_FORMAT_ID IS NOT NULL THEN
            --get current format for the lead
            V_STR_MICR_FRMT_DTLS_REC := BANKING_COMMON_TOOLS.GET_STORE_MICR_FORMAT_DTLS_REC(IN_COST_CENTER_CODE);
            --build the future format fo rthe lead from current format
            V_STR_MICR_FRMT_DTLS_FTR_REC.BANK_ACCOUNT_NBR     := V_STR_MICR_FRMT_DTLS_REC.BANK_ACCOUNT_NBR;
            V_STR_MICR_FRMT_DTLS_FTR_REC.MICR_FORMAT_ID       := V_STR_MICR_FRMT_DTLS_REC.MICR_FORMAT_ID;
            V_STR_MICR_FRMT_DTLS_FTR_REC.COST_CENTER_CODE     := IN_COST_CENTER_CODE;
            V_STR_MICR_FRMT_DTLS_FTR_REC.MICR_FORMAT_ACCT_NBR := V_STR_MICR_FRMT_DTLS_REC.MICR_FORMAT_ACCT_NBR;
            V_STR_MICR_FRMT_DTLS_FTR_REC.MICR_ROUTING_NBR     := V_STR_MICR_FRMT_DTLS_REC.MICR_ROUTING_NBR;
            V_STR_MICR_FRMT_DTLS_FTR_REC.MICR_COST_CNTR       := V_STR_MICR_FRMT_DTLS_REC.MICR_COST_CNTR;
            V_STR_MICR_FRMT_DTLS_FTR_REC.EFFECTIVE_DATE       := V_EFFECTIVE_DATE;
            V_STR_MICR_FRMT_DTLS_FTR_REC.EXPIRATION_DATE      := IN_EXPIRATION_DATE;
            V_STR_MICR_FRMT_DTLS_FTR_REC.FUTURE_ID            := IN_FUTURE_ID;
            --insert the future lead format
            TABLE_IU_PKG.STR_MICR_FORMAT_DTLS_FTR_I_SP(V_STR_MICR_FRMT_DTLS_FTR_REC);
            --If the store MICR format change, we need to verify if the part paper per form changed or not
            --if it changes, we need to recalculate the number of deposit tickets per book
            --Example : PART2 => 324/2 = 162, PART3 => 324/3 = 108, PART4 => 324/4 = 81
            --Then we need to update the data accordingly in BANK_DEP_TICK_* table
            CALCULATE_DEPOSIT_TICKET(V_BANK_MICR_FORMAT_FUTURE_REC.DJDE_FEED_PARM,
                                     V_BANK_DEP_TICK_FUTURE_REC.PART_PAPER_PER_FORM,
                                     V_BANK_DEP_TICK_FUTURE_REC.NBR_DEP_TICKETS_PER_BK,
                                     V_BANK_DEP_TICK_FUTURE_REC.IMAGES_PER_PAGE,
                                     V_BANK_DEP_TICK_FUTURE_REC.NBR_FORMS_PER_BK,
                                     V_BANK_DEP_TICK_FUTURE_REC.SHEETS_OF_PAPER_PER_BK,
                                     V_BANK_DEP_TICK_FUTURE_REC.REORDER_NUMBER_BKS);
            TABLE_IU_PKG.BANK_DEP_TICK_FUTURE_I_SP(V_BANK_DEP_TICK_FUTURE_REC);
        END IF;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END INSERT_BANK_DEPOSIT_DTLS_FTR;

FUNCTION GET_DEPOSIT_ORDER_SEQ_NBR(
/*******************************************************************************
This fucntion is intended to return the deposit ticket sequence for the cost center passed in

Created : 09/08/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE    IN      VARCHAR2) RETURN VARCHAR2
IS
    V_RETURN_VAL VARCHAR2(10);
BEGIN
    SELECT MAX(DEPOSIT_ORDER_SEQ_NBR)
      INTO V_RETURN_VAL
      FROM (SELECT DEPOSIT_ORDER_SEQ_NBR
              FROM BANK_DEP_TICKORD_HIST
             WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
             UNION
            SELECT DEPOSIT_ORDER_SEQ_NBR
              FROM BANK_DEP_TICKORD
             WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
             UNION
            SELECT DEPOSIT_ORDER_SEQ_NBR
              FROM BANK_DEP_TICKORD_FUTURE
             WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE);
    RETURN V_RETURN_VAL;
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END GET_DEPOSIT_ORDER_SEQ_NBR;

PROCEDURE CREATE_DEPOSIT_TKT_INPUT_FILE(
/******************************************************************************
This procedure is intended to create the input deposit ticket file.
Corporate Treasury will then send the bank deposit ticket information to Linda. 
Depending on the request, either of the following will be done:
    1) Add a brand new bank account/routing number and attach store(s) to it
    2) Add a new store to an existing bank account/routing number
    3) Update existing bank account/routing number.  For example, a bank gets bought out and accounts are renumbered and/or routing number changes. 
      (Note, all of these events trigger printing of deposit tickets).

Created : 08/19/2015 jxc517 CCN Project....
Changed : 10/21/2015 nxk927 CCN Project...
          Added call to create the deposit order for future 
Changed : 11/11/2015 nxk927 CCN Project...
          made changes to get the micr details of lead if not present for the members.
          added BANK_DEP_TICK_FTR_ID as a parameter to get the right data
        : 11/19/2015 nxk927 CCN Project...
          correcting the join condition
        : 08/26/2016 nxk927 CCN Project...
          passing the passed cost center in the filename
        : 08/30/2016 nxk927 CCN Project...
          getting the details for the cost center passed besides the micr details if not present for the passed cost center
*******************************************************************************/
    IN_COST_CENTER          IN VARCHAR2,
    IN_FUTURE_ID            IN VARCHAR2,
    IN_BANK_DEP_TICK_FTR_ID IN VARCHAR2)
IS
    CURSOR main_cur IS
        SELECT BDTO.BANK_ACCOUNT_NBR,
               BDTO.COST_CENTER_CODE,
               'BDCVSW' FORM_COVER, --hard coded?
               'SHERWIN-WILLIAMS' COMPANY, --hard coded?
               ADDRESS_LINE_1 ADDRESS,
               CITY,
               STATE_CODE,
               ZIP_CODE||'-'||A.ZIP_CODE_4 ZIP,
               B.MICR_ROUTING_NBR ROUTING_NUMBER,
               B.MICR_FORMAT_ACCT_NBR ACCOUNT_NUMBER,
               B.DJDE_FORM_PARM FORM_TICKET,
               B.DJDE_FEED_PARM FEED_TICKET,
               'DEPOSIT_TICKET_'||IN_COST_CENTER HTML_NAME
          FROM BANK_DEP_TICKORD BDTO,
               ADDRESS_VW A,
               (SELECT SMFD.MICR_ROUTING_NBR,
                       SMFD.MICR_FORMAT_ACCT_NBR,
                       IN_COST_CENTER COST_CENTER_CODE,
                       BMF.DJDE_FORM_PARM ,
                       BMF.DJDE_FEED_PARM
                  FROM (SELECT *
                        --This top-N query was used to get member store MICR details if it has a default MICR assigned
                           FROM (SELECT *
                                   FROM STORE_MICR_FORMAT_DTLS
                                  --IN clause below makes sure we always get the passed stores MICR details
                                  --as well as it's leads storer MICR format details
                                  WHERE COST_CENTER_CODE IN (IN_COST_CENTER,
                                                             BANKING_COMMON_TOOLS.GET_LEAD_STORE_NBR_FOR_MBR_STR(IN_COST_CENTER))
                                  --below order by clause is to make sure we get store MICR details even for
                                  --a member that doesn't have any default store MICR assigned to it 
                                  --if member got it's own store MICR that takes precedence
                                  ORDER BY DECODE(COST_CENTER_CODE, IN_COST_CENTER, 1, 2))
                            WHERE ROWNUM < 2) SMFD,
                       BANK_MICR_FORMAT BMF
                 WHERE SMFD.BANK_ACCOUNT_NBR = BMF.BANK_ACCOUNT_NBR
                   AND SMFD.MICR_FORMAT_ID   = BMF.MICR_FORMAT_ID) B
        WHERE BDTO.COST_CENTER_CODE          = B.COST_CENTER_CODE
          AND BDTO.BANK_DEP_TICK_FTR_ID      = IN_BANK_DEP_TICK_FTR_ID
          AND BDTO.COST_CENTER_CODE          = A.COST_CENTER_CODE(+)
          AND A.EXPIRATION_DATE IS NULL;

    CURSOR main_cur_future IS
        SELECT BDTO.BANK_ACCOUNT_NBR,
               BDTO.COST_CENTER_CODE,
               'BDCVSW' FORM_COVER, --hard coded?
               'SHERWIN-WILLIAMS' COMPANY, --hard coded?
               ADDRESS_LINE_1 ADDRESS,
               CITY,
               STATE_CODE,
               ZIP_CODE||'-'||A.ZIP_CODE_4 ZIP,
               B.MICR_ROUTING_NBR ROUTING_NUMBER,
               B.MICR_FORMAT_ACCT_NBR ACCOUNT_NUMBER,
               B.DJDE_FORM_PARM FORM_TICKET,
               B.DJDE_FEED_PARM FEED_TICKET,
               'DEPOSIT_TICKET_'||IN_COST_CENTER HTML_NAME
          FROM BANK_DEP_TICKORD_FUTURE BDTO,
               ADDRESS_VW A,
               (SELECT SMFD.MICR_ROUTING_NBR,
                       SMFD.MICR_FORMAT_ACCT_NBR,
                       IN_COST_CENTER COST_CENTER_CODE,
                       BMF.DJDE_FORM_PARM ,
                       BMF.DJDE_FEED_PARM,
                       SMFD.FUTURE_ID
                  FROM (SELECT *
                        --This top-N query was used to get member store MICR details if it has a default MICR assigned
                           FROM (SELECT *
                                   FROM STORE_MICR_FORMAT_DTLS_FUTURE
                                  --IN clause below makes sure we always get the passed stores MICR details
                                  --as well as it's leads storer MICR format details
                                  WHERE COST_CENTER_CODE IN (IN_COST_CENTER,
                                                             BANKING_COMMON_TOOLS.GET_FTR_LD_STR_NBR_FOR_MBR_STR(IN_COST_CENTER, IN_FUTURE_ID))
                                  --below order by clause is to make sure we get store MICR details even for
                                  --a member that doesn't have any default store MICR assigned to it in future
                                  --if member got it's own store MICR that takes precedence
                                  ORDER BY DECODE(COST_CENTER_CODE, IN_COST_CENTER, 1, 2))
                            WHERE ROWNUM < 2) SMFD,
                       BANK_MICR_FORMAT_FUTURE BMF
                 WHERE SMFD.BANK_ACCOUNT_NBR = BMF.BANK_ACCOUNT_NBR
                   AND SMFD.MICR_FORMAT_ID   = BMF.MICR_FORMAT_ID
                   AND SMFD.FUTURE_ID        = BMF.FUTURE_ID) B
         WHERE BDTO.COST_CENTER_CODE         = B.COST_CENTER_CODE
           AND BDTO.FUTURE_ID                = IN_FUTURE_ID
           AND BDTO.BANK_DEP_TICK_FTR_ID     = IN_BANK_DEP_TICK_FTR_ID
           AND BDTO.COST_CENTER_CODE         = A.COST_CENTER_CODE(+)
           AND A.EXPIRATION_DATE IS NULL;    
        
       
    PATH                     VARCHAR2(50) := 'BANKING_DATA_FILES';
    BANK_DEPOSIT_IP_FILE_NM  VARCHAR2(50) := 'DEPOSIT_TICKET_';
                                             --||TO_CHAR(IN_DATE,'DDMONRRRR');--|| '_' ||TO_CHAR(SYSDATE,'HH24MISS');
    BANK_DEPOSIT_INPUT_FILE  UTL_FILE.FILE_TYPE;

    V_OUT_CLOB         CLOB;
    V_COUNT            NUMBER := 0;
BEGIN
  IF IN_FUTURE_ID IS NULL THEN
    FOR rec IN main_cur LOOP
       IF rec.COST_CENTER_CODE is not null then
        BANK_DEPOSIT_INPUT_FILE := UTL_FILE.FOPEN (PATH
                                            ,BANK_DEPOSIT_IP_FILE_NM ||IN_COST_CENTER||'.txt'
                                            ,'W' --BINARY
                                            ,32767);
        V_OUT_CLOB := V_OUT_CLOB ||
                    RPAD(NVL(SUBSTR(rec.COST_CENTER_CODE, 3), ' '), 4, ' ') || --STORE-NBR (4)
                    RPAD(NVL(rec.FORM_COVER, ' '), 6, ' ') ||                  --FORM_COVER (6)
                    RPAD(NVL(rec.FORM_TICKET, ' '), 6, ' ') ||                 --FORM_TICKET (6)
                    RPAD(NVL(rec.FEED_TICKET, ' '), 5, ' ') ||                 --FEED_TICKET (5)
                    RPAD(NVL(rec.COMPANY, ' '), 26, ' ') ||                    --COMPANY (26)
                    RPAD(NVL(rec.ADDRESS, ' '), 30, ' ') ||                    --ADDRESS (30)
                    RPAD(NVL(rec.CITY, ' '), 30, ' ') ||                       --CITY (30)
                    RPAD(NVL(rec.STATE_CODE, ' '), 2, ' ') ||                  --STATE_CODE (2)
                    RPAD(NVL(rec.ZIP, ' '), 10, ' ') ||                        --ZIP (10)
                    RPAD(NVL(rec.ROUTING_NUMBER, ' '), 11, ' ') ||             --ROUTING_NUMBER (11)
                    RPAD(NVL(rec.ACCOUNT_NUMBER, ' '), 19, ' ') ||             --ACCOUNT_NUMBER (15)
                    RPAD(NVL(rec.HTML_NAME, ' '), 50, ' ')                   --HTML_NAME (50)
                    ;
       UTL_FILE.PUT_LINE(BANK_DEPOSIT_INPUT_FILE, V_OUT_CLOB, TRUE);
       UTL_FILE.FCLOSE(BANK_DEPOSIT_INPUT_FILE);
       V_OUT_CLOB := NULL;
       END IF;
    END LOOP;
  ELSE
    FOR rec IN main_cur_future LOOP
       IF rec.COST_CENTER_CODE is not null then
        BANK_DEPOSIT_INPUT_FILE := UTL_FILE.FOPEN (PATH
                                            ,BANK_DEPOSIT_IP_FILE_NM ||IN_COST_CENTER||'.txt'
                                            ,'W' --BINARY
                                            ,32767);
        V_OUT_CLOB := V_OUT_CLOB ||
                    RPAD(NVL(SUBSTR(rec.COST_CENTER_CODE, 3), ' '), 4, ' ') || --STORE-NBR (4)
                    RPAD(NVL(rec.FORM_COVER, ' '), 6, ' ') ||                  --FORM_COVER (6)
                    RPAD(NVL(rec.FORM_TICKET, ' '), 6, ' ') ||                 --FORM_TICKET (6)
                    RPAD(NVL(rec.FEED_TICKET, ' '), 5, ' ') ||                 --FEED_TICKET (5)
                    RPAD(NVL(rec.COMPANY, ' '), 26, ' ') ||                    --COMPANY (26)
                    RPAD(NVL(rec.ADDRESS, ' '), 30, ' ') ||                    --ADDRESS (30)
                    RPAD(NVL(rec.CITY, ' '), 30, ' ') ||                       --CITY (30)
                    RPAD(NVL(rec.STATE_CODE, ' '), 2, ' ') ||                  --STATE_CODE (2)
                    RPAD(NVL(rec.ZIP, ' '), 10, ' ') ||                        --ZIP (10)
                    RPAD(NVL(rec.ROUTING_NUMBER, ' '), 11, ' ') ||             --ROUTING_NUMBER (11)
                    RPAD(NVL(rec.ACCOUNT_NUMBER, ' '), 19, ' ') ||             --ACCOUNT_NUMBER (15)
                    RPAD(NVL(rec.HTML_NAME, ' '), 50, ' ')                   --HTML_NAME (50)
                    ;
       UTL_FILE.PUT_LINE(BANK_DEPOSIT_INPUT_FILE, V_OUT_CLOB, TRUE);
       UTL_FILE.FCLOSE(BANK_DEPOSIT_INPUT_FILE);
       V_OUT_CLOB := NULL;
       END IF;
    END LOOP;
END IF;    
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, 'CREATE_DEPOSIT_TKT_INPUT_FILE ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END CREATE_DEPOSIT_TKT_INPUT_FILE;

PROCEDURE PLACE_DEPOSIT_TICKET_ORDER(
/*******************************************************************************
This procedure is intended to place a deposit ticket order for the store passed in

Created : 08/31/2015 jxc517 CCN Project....
Changed : 10/20/2015 sxt410 CCN Project....
          Changed Column Name From Extract_Date To Order_Date
Changed : 10/21/2015 jxc517 CCN Project....
          Added code to re-calculate the onhand, ytd deposit tickets
        : 10/21/2015 nxk927 CCN Project...
          Added call to create the deposit order for future 
          Future DEP_TKTS_ONHAND_QTY and YTD_DEP_TKTS_ORDERED_QTY always reset to zero.
        : 11/04/2015 nxk927 CCN Project...
          Added condition to not to update the on hand quantity if the date is not current
          Removed the business rule that was not allowing order to be placed in current if future is present
          ADDED to take the standard value from bank_dep_tickoak table if sent as null
        : 11/05/2015 nxk927 CCN Project...
          record should be only moved if there are changes in current. So moved
          the history insert inside the if condition when there will be changes in current
          --removed the unwanted codes
        : 11/11/2015 nxk927 CCN Project...
          passing BANK_DEP_TICK_FTR_ID as well to get the right record.
        : 11/13/2015 axk326 CCN Project...
          added a new condition to raise error when we try to place order for the input cost center 
          that has no store micr format details attached to it.
        : 11/18/2015  nxk927 CCN Project...
          added the business rule for current and future for order date and check to see if 
          store micr detail moved inside the business rule call.
          passing the bank account number to get the deposit ticket fut_id 
Changed : 11/30/2016 nxk972 CCN Project....
          Passing order date to the procedure CREATE_DEPOSIT_TICKET_ORDER to have the order date in the xml
          rather than the deposit ticket effective date
Changed : 12/07/2016 nxk972 CCN Project....
          Updating LAST_VW_ORDER_DATE and LAST_MAINTENANCE_DATE with the date the order was placed 
          , effective date not to be changed
*******************************************************************************/
IN_COST_CENTER_CODE     IN     VARCHAR2,
IN_ORDERED_DATE         IN     DATE,
IN_FUTURE_ID            IN     NUMBER,
IN_USER_ID              IN     VARCHAR2)
IS
    CURSOR bank_dep_tickord_ftr_cur IS
        SELECT *
          FROM BANK_DEP_TICKORD_FUTURE
         WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
           AND FUTURE_ID        > NVL(IN_FUTURE_ID, 0);
    V_BANK_DEP_TICKORD                 BANK_DEP_TICKORD%ROWTYPE;
    V_BANK_DEP_TICKORD_FUTURE          BANK_DEP_TICKORD_FUTURE%ROWTYPE;
    V_BANK_DEP_TICK                    BANK_DEP_TICK%ROWTYPE;
    V_BANK_DEP_TICK_FUTURE             BANK_DEP_TICK_FUTURE%ROWTYPE;
    V_NBR_DEP_TICKETS_PER_BK           BANK_DEP_TICK.NBR_DEP_TICKETS_PER_BK%TYPE;
    V_REORDER_NUMBER_BKS               BANK_DEP_TICK.REORDER_NUMBER_BKS%TYPE;
    V_COUNT                            NUMBER := 0;
BEGIN
    --business rule to check if micr detail is present
    -- check the order place date is valid or not
    BUSINESS_RULES_PKG.PLACE_TCKT_ORDER_BR_SP(IN_COST_CENTER_CODE,
                                              IN_ORDERED_DATE,
                                              IN_FUTURE_ID);
    IF IN_FUTURE_ID IS NULL THEN
        BEGIN
            SELECT *
              INTO V_BANK_DEP_TICK
              FROM BANK_DEP_TICK
             WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE;
        EXCEPTION
            WHEN OTHERS THEN
                NULL;
        END;
       
        IF V_BANK_DEP_TICK.COST_CENTER_CODE IS NOT NULL THEN
           V_BANK_DEP_TICK.LAST_MAINTENANCE_DATE      := SYSDATE;
           V_BANK_DEP_TICK.LAST_VW_ORDER_DATE         := TRUNC(SYSDATE);
           TABLE_IU_PKG.BANK_DEP_TICK_I_SP(V_BANK_DEP_TICK);
           V_BANK_DEP_TICKORD.BANK_ACCOUNT_NBR        := V_BANK_DEP_TICK.BANK_ACCOUNT_NBR;
           V_BANK_DEP_TICKORD.COST_CENTER_CODE        := V_BANK_DEP_TICK.COST_CENTER_CODE;
           V_BANK_DEP_TICKORD.BANK_DEP_TICK_FTR_ID    := NVL(GET_DEPOSIT_TKT_FUT_ID_NBR(V_BANK_DEP_TICK.COST_CENTER_CODE, V_BANK_DEP_TICKORD.BANK_ACCOUNT_NBR, IN_FUTURE_ID),0) + 1;
           V_BANK_DEP_TICKORD.DEPOSIT_ORDER_PRIORITY  := 100;
           V_BANK_DEP_TICKORD.DEPOSIT_ORDER_STATUS    := 'P';
           V_BANK_DEP_TICKORD.DEPOSIT_ORDER_SEQ_NBR   := NVL(GET_DEPOSIT_ORDER_SEQ_NBR(V_BANK_DEP_TICK.COST_CENTER_CODE),0) + 1;
           V_BANK_DEP_TICKORD.EFFECTIVE_DATE          := V_BANK_DEP_TICK.EFFECTIVE_DATE;
           V_BANK_DEP_TICKORD.EXPIRATION_DATE         := V_BANK_DEP_TICK.EXPIRATION_DATE;
           V_BANK_DEP_TICKORD.LAST_MAINTENANCE_DATE   := TRUNC(SYSDATE);
           V_BANK_DEP_TICKORD.LAST_MAINT_USER_ID      := IN_USER_ID;
           V_BANK_DEP_TICKORD.ORDER_DATE              := IN_ORDERED_DATE;
           V_BANK_DEP_TICKORD.EXTRACTED_USER_ID       := IN_USER_ID;
           TABLE_IU_PKG.BANK_DEP_TICKORD_I_SP(V_BANK_DEP_TICKORD);
           CREATE_DEPOSIT_TKT_INPUT_FILE(IN_COST_CENTER_CODE,NULL,V_BANK_DEP_TICKORD.BANK_DEP_TICK_FTR_ID);
           RSA_WEB_SERVICES_PKG.CREATE_DEPOSIT_TICKET_ORDER(V_BANK_DEP_TICK,
                                                            IN_ORDERED_DATE);
            
           --DEP_TKTS_ONHAND_QTY will depend on book quantity. If we need different quantity we have to update the book quantity first and save it. Then place the order.
           IF IN_ORDERED_DATE = TRUNC(SYSDATE) THEN 
              --record should be only moved from current to history if there are changes in current
              --the following process should only run if the order date is current
              TABLE_IU_PKG.BANK_DEP_TICK_HIST_I_SP(V_BANK_DEP_TICK);
              --if the order date is current then we will update the DEP_TKTS_ONHAND_QTY and YTD_DEP_TKTS_ORDERED_QTY
              --if not the batch process will update the qauntity when it hits the date
              V_NBR_DEP_TICKETS_PER_BK                   := BANKING_COMMON_TOOLS.GET_STANDARD_VAL_DEPOSIT_ORD('NBR_DEP_TICKETS_PER_BK');
              V_REORDER_NUMBER_BKS                       := BANKING_COMMON_TOOLS.GET_STANDARD_VAL_DEPOSIT_ORD('REORDER_NUMBER_BKS');
              V_BANK_DEP_TICK.NBR_DEP_TICKETS_PER_BK     := NVL(V_BANK_DEP_TICK.NBR_DEP_TICKETS_PER_BK,V_NBR_DEP_TICKETS_PER_BK);
              V_BANK_DEP_TICK.REORDER_NUMBER_BKS         := NVL(V_BANK_DEP_TICK.REORDER_NUMBER_BKS,V_REORDER_NUMBER_BKS);
              V_BANK_DEP_TICK.DEP_TKTS_ONHAND_QTY        := NVL(V_BANK_DEP_TICK.DEP_TKTS_ONHAND_QTY,0) + V_BANK_DEP_TICK.NBR_DEP_TICKETS_PER_BK * V_BANK_DEP_TICK.REORDER_NUMBER_BKS;
              V_BANK_DEP_TICK.YTD_DEP_TKTS_ORDERED_QTY   := NVL(V_BANK_DEP_TICK.YTD_DEP_TKTS_ORDERED_QTY,0) + V_BANK_DEP_TICK.NBR_DEP_TICKETS_PER_BK * V_BANK_DEP_TICK.REORDER_NUMBER_BKS;
              TABLE_IU_PKG.BANK_DEP_TICK_I_SP(V_BANK_DEP_TICK);
           END IF;
        END IF;
    ELSE
        BEGIN
            SELECT *      
              INTO V_BANK_DEP_TICK_FUTURE
              FROM BANK_DEP_TICK_FUTURE
             WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
               AND FUTURE_ID        = IN_FUTURE_ID;
        EXCEPTION
            WHEN OTHERS THEN
                NULL;
        END;
        
        IF V_BANK_DEP_TICK_FUTURE.COST_CENTER_CODE IS NOT NULL THEN
            V_BANK_DEP_TICKORD_FUTURE.BANK_ACCOUNT_NBR        := V_BANK_DEP_TICK_FUTURE.BANK_ACCOUNT_NBR;
            V_BANK_DEP_TICKORD_FUTURE.COST_CENTER_CODE        := V_BANK_DEP_TICK_FUTURE.COST_CENTER_CODE;
            V_BANK_DEP_TICKORD_FUTURE.BANK_DEP_TICK_FTR_ID    := NVL(GET_DEPOSIT_TKT_FUT_ID_NBR(V_BANK_DEP_TICK_FUTURE.COST_CENTER_CODE, V_BANK_DEP_TICKORD_FUTURE.BANK_ACCOUNT_NBR, IN_FUTURE_ID),0) + 1;
            V_BANK_DEP_TICKORD_FUTURE.DEPOSIT_ORDER_PRIORITY  := 100;
            V_BANK_DEP_TICKORD_FUTURE.DEPOSIT_ORDER_STATUS    := 'P';
            V_BANK_DEP_TICKORD_FUTURE.DEPOSIT_ORDER_SEQ_NBR   := NVL(GET_DEPOSIT_ORDER_SEQ_NBR(V_BANK_DEP_TICK_FUTURE.COST_CENTER_CODE),0) + 1;
            V_BANK_DEP_TICKORD_FUTURE.EFFECTIVE_DATE          := V_BANK_DEP_TICK_FUTURE.EFFECTIVE_DATE;
            V_BANK_DEP_TICKORD_FUTURE.EXPIRATION_DATE         := V_BANK_DEP_TICK_FUTURE.EXPIRATION_DATE;
            V_BANK_DEP_TICKORD_FUTURE.LAST_MAINTENANCE_DATE   := TRUNC(SYSDATE);
            V_BANK_DEP_TICKORD_FUTURE.LAST_MAINT_USER_ID      := IN_USER_ID;
            V_BANK_DEP_TICKORD_FUTURE.ORDER_DATE              := IN_ORDERED_DATE;
            V_BANK_DEP_TICKORD_FUTURE.EXTRACTED_USER_ID       := IN_USER_ID;
            V_BANK_DEP_TICKORD_FUTURE.FUTURE_ID               := V_BANK_DEP_TICK_FUTURE.FUTURE_ID;
            TABLE_IU_PKG.BANK_DEP_TICKORD_FUTURE_I_SP(V_BANK_DEP_TICKORD_FUTURE);
            /***DEP_TKTS_ONHAND_QTY will depend on book quantity. If we need different quantity we have to update the book quantity first and save it. Then place the order.
            For future this will start with new order as if there was "0" DEP_TKTS_ONHAND_QTY ***/
            V_BANK_DEP_TICK_FUTURE.DEP_TKTS_ONHAND_QTY        := 0;
            V_BANK_DEP_TICK_FUTURE.YTD_DEP_TKTS_ORDERED_QTY   := 0;
            V_BANK_DEP_TICK_FUTURE.LAST_VW_ORDER_DATE         := TRUNC(SYSDATE);
            TABLE_IU_PKG.BANK_DEP_TICK_FUTURE_I_SP(V_BANK_DEP_TICK_FUTURE);
            CREATE_DEPOSIT_TKT_INPUT_FILE(V_BANK_DEP_TICK_FUTURE.COST_CENTER_CODE,IN_FUTURE_ID,V_BANK_DEP_TICKORD_FUTURE.BANK_DEP_TICK_FTR_ID);
            BEGIN
               SELECT BANK_ACCOUNT_NBR, 
                      COST_CENTER_CODE,       
                      DAILY_USE_ACTUAL,
                      DAILY_USE_OVERRIDE,    
                      DEP_TKTS_ONHAND_QTY,     
                      YTD_DEP_TKTS_ORDERED_QTY,
                      REORDER_POINT,
                      REORDER_NUMBER_BKS,
                      IMAGES_PER_PAGE,     
                      NBR_FORMS_PER_BK,        
                      PART_PAPER_PER_FORM,
                      NBR_DEP_TICKETS_PER_BK,
                      SHEETS_OF_PAPER_PER_BK, 
                      EFFECTIVE_DATE, 
                      EXPIRATION_DATE,         
                      LAST_MAINTENANCE_DATE,
                      LAST_MAINT_USER_ID,  
                      REORDER_SWITCH,     
                      LAST_VW_ORDER_DATE
                 INTO V_BANK_DEP_TICK
                 FROM BANK_DEP_TICK_FUTURE
                WHERE COST_CENTER_CODE = IN_COST_CENTER_CODE
                  AND FUTURE_ID        = IN_FUTURE_ID;
            EXCEPTION
              WHEN OTHERS THEN
                  NULL;
            END;
            RSA_WEB_SERVICES_PKG.CREATE_DEPOSIT_TICKET_ORDER(V_BANK_DEP_TICK,
                                                             IN_ORDERED_DATE);
        END IF;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, 'PLACE_DEPOSIT_TICKET_ORDER ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END PLACE_DEPOSIT_TICKET_ORDER;


END DEPOSIT_TICKET_MAINTENANCE_PKG;