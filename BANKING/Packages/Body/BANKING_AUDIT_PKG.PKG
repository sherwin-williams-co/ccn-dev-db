create or replace PACKAGE BODY BANKING_AUDIT_PKG AS
/*********************************************************** 
This package has procedures and functions related to the audit_log table

Created : 09/15/2015 jcx517 CCN project....
Changed : 08/30/2017 rxa457 Changes to fix ASP-835 audit issue with multiple kickoffs.
************************************************************/
    v_max_tran_id_last_batch    AUDIT_LOG.LOG_ID%TYPE;
    v_max_tran_id_current_batch AUDIT_LOG.LOG_ID%TYPE;

FUNCTION XML_EXTRACT_NO_EXCEPTION(
/**********************************************************
This function returns null if XPATH does not exist within xmltype, 
oracle throws an exception if not handled this way

Created : 09/15/2015 jcx517 CCN project....
Changed :
**********************************************************/
p_xml   IN     XMLTYPE,
p_xpath IN     VARCHAR2) RETURN VARCHAR2 
IS
BEGIN
    RETURN CASE WHEN P_XML.EXTRACT(P_XPATH) IS NOT NULL THEN
                    p_xml.extract(p_xpath || '/text()').getstringval()
                ELSE 
                    NULL
            END;
END XML_EXTRACT_NO_EXCEPTION;

FUNCTION IS_ROW_DATA_DIFFERENT(
/**********************************************************
This function returns true if the new record data is different from old record data
Some columns just gets updated for every commit, even though the actual data is not changed.
This function will validate previous record and current record ignoring that columns
which are store in AUDIT_COMPARE_IGNORE_COLUMNS table

Created : 10/27/2015 jcx517 CCN project....
Changed : 11/09/2015 jcx517 CCN project....
          If the virtual futures are created their effective dates will be less than TRUNC(SYSDATE)
          We should not pass those records again for future as they are virtual and exists in current table as well
Changed : 11/10/2015 jcx517 CCN project....
          Modified the code to deal with virtual futures that got updated as part of actual current tables
**********************************************************/
    IN_TABLE_NAME IN     VARCHAR2,
    IN_ROW_PREV   IN     XMLTYPE,
    IN_ROW_CURR  IN     XMLTYPE) RETURN BOOLEAN
IS
    CURSOR GET_COLS (IN_TABLE IN VARCHAR2) IS
        SELECT COLUMN_NAME
          FROM ALL_TAB_COLUMNS
         WHERE TABLE_NAME = IN_TABLE
           AND OWNER = 'BANKING'
           AND COLUMN_NAME NOT IN (SELECT COLUMN_NAME
                                     FROM AUDIT_COMPARE_IGNORE_COLUMNS)
         ORDER BY COLUMN_ID ASC;

    V_RETURN_VAL          BOOLEAN := FALSE;
    V_FTR_REC_EFFCTV_DT   DATE;
    V_LAST_BATCH_RUN_DATE DATE;
BEGIN
    --If the previous record exists then we need to compare and make sure at least some details are changed
    IF IN_ROW_PREV IS NOT NULL THEN
        FOR GET_COLS_REC IN GET_COLS(IN_TABLE_NAME) LOOP
            --If at least one detail is changed, we should send it back for backfeed
            --NOTE: that we should skip some columns which always change with an update
            --This is done by ignoring columns marked in AUDIT_COMPARE_IGNORE_COLUMNS table
            IF NVL(XML_EXTRACT_NO_EXCEPTION(IN_ROW_PREV,'//' || GET_COLS_REC.COLUMN_NAME),'~') <>
               NVL(XML_EXTRACT_NO_EXCEPTION(IN_ROW_CURR,'//' || GET_COLS_REC.COLUMN_NAME),'~') THEN
                V_RETURN_VAL := TRUE;
                EXIT;
            END IF;
        END LOOP;
    ELSE --Current tables with out previous record, just send it to back feed
        V_RETURN_VAL := TRUE;
    END IF;

    --If the data is different we also need to see if it is a virtual future update happened due to current records update
    --If so we should not send them twice(once for current and once for future) rather they should go only for current audit
    --So verify if it is a virtual future record with effective date < TRUNC(last batch run date) + 1
    --If it is we should NOT send it as future as it is not a real future record but just a virtual future record
    --So return FALSE in this scenario saying do not do anything for these records
    --CONCLUSION: send future table details only if the effective date > TRUNC(SYSDATE)
    IF V_RETURN_VAL AND IN_TABLE_NAME LIKE '%FUTURE' THEN
        BEGIN
            V_FTR_REC_EFFCTV_DT := TO_DATE(XML_EXTRACT_NO_EXCEPTION(IN_ROW_CURR,'//EFFECTIVE_DATE'), 'RRRRMMDD');
            --We need to consider weekends as well
            --If a future was created on friday with effective date as saturday, it will be a future
            --But the batch won't pick these records until sunday(so we can't always say it's TRUNC(SYSDATE)
            --Below query will get the TRUNC of last batch run date to deal with this weekend scenario's
            --NVL around MAX function is because for the first time run in any environment there won't be any data
            SELECT NVL(MAX(BATCH_JOB_LAST_RUN_DATE), TRUNC(SYSDATE - 1))
              INTO V_LAST_BATCH_RUN_DATE
              FROM BATCH_JOB
             WHERE BATCH_JOB_NAME          = 'BANKING_AUDIT_LOG'
               AND BATCH_JOB_LAST_RUN_DATE < TRUNC(SYSDATE);
            IF NVL(V_FTR_REC_EFFCTV_DT, TRUNC(SYSDATE)) > TRUNC(V_LAST_BATCH_RUN_DATE) + 1 THEN
                V_RETURN_VAL := TRUE;
            ELSE
                V_RETURN_VAL := FALSE;
            END IF;
            --transaction done after the previous audit batch will be handled in future to current batch
        EXCEPTION
            WHEN OTHERS THEN
                NULL;
        END;
    END IF;

    RETURN V_RETURN_VAL;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VAL;
END IS_ROW_DATA_DIFFERENT;

FUNCTION IS_COLUMN_PART_OF_KEY(
/**********************************************************
This function returns true if the passed input column part of key specified(as input)
  in the passed input table

in_TABLE_NAME - specifies the table name that needs to be verified for
in_COLUMN_NAME - specifies the column name that needs to be verified for
in_KEY_TYPE - specifies the key that needs to be verified for - 'P' => Primary Key

Created : 09/15/2015 jcx517 CCN project....
Changed :
**********************************************************/
IN_TABLE_NAME  IN VARCHAR2,
IN_COLUMN_NAME IN VARCHAR2,
IN_KEY_TYPE    IN VARCHAR2) RETURN BOOLEAN IS
    V_COUNT NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO V_COUNT
      FROM ALL_CONSTRAINTS CONS,
           ALL_CONS_COLUMNS COLS
     WHERE CONS.CONSTRAINT_TYPE = UPPER(IN_KEY_TYPE)
       AND COLS.TABLE_NAME      = UPPER(IN_TABLE_NAME)
       AND COLS.COLUMN_NAME     = UPPER(IN_COLUMN_NAME)
       AND CONS.CONSTRAINT_NAME = COLS.CONSTRAINT_NAME
       AND CONS.OWNER           = COLS.OWNER
       AND COLS.OWNER           = 'BANKING';
    IF V_COUNT = 1 THEN
       RETURN TRUE;
    ELSE
       RETURN FALSE;
    END IF;
EXCEPTION
   WHEN OTHERS THEN
      RETURN FALSE;
END IS_COLUMN_PART_OF_KEY;

PROCEDURE UPDATE_AUDIT_REC_FLAG(
/*******************************************************
Procedure to update AUDIT_REC_FLAG column of AUDIT_LOG tablw

Created : 09/15/2015 jcx517 CCN project....
Changed :
*******************************************************/
    IN_TABLE_NAME     IN     VARCHAR2,
    IN_KEY            IN     VARCHAR2,
    IN_LOG_ID_PREV    IN     AUDIT_LOG.LOG_ID%TYPE,
    IN_LOG_ID_CURR    IN     AUDIT_LOG.LOG_ID%TYPE,
    OUT_CONTEXT          OUT VARCHAR2)
IS
BEGIN
    OUT_CONTEXT := 'Updating the PREV AUDIT_REC_FLAG to C';
    UPDATE AUDIT_LOG
       SET AUDIT_REC_FLAG     = 'C',
           AUDIT_REC_EFF_DATE = SYSDATE
     WHERE TABLE_NAME     = IN_TABLE_NAME
       AND LOG_ID         = IN_LOG_ID_PREV
       AND TRANSACTION_ID = IN_KEY
       AND AUDIT_REC_FLAG = 'R';
    OUT_CONTEXT := 'Updating the CURR AUDIT_REC_FLAG to R';
    UPDATE AUDIT_LOG
       SET AUDIT_REC_FLAG = 'R'
     WHERE TABLE_NAME     = IN_TABLE_NAME
       AND LOG_ID         = IN_LOG_ID_CURR
       AND TRANSACTION_ID = IN_KEY
       AND AUDIT_REC_FLAG IS NULL;
--Exceptions handled in calling procedure
END UPDATE_AUDIT_REC_FLAG;

PROCEDURE PARSE_DIFFERENCE_XML(
/*******************************************************
Procedure to Parse xmls from the audit_log table and 
create an output xml with the differences

Created : 09/15/2015 jcx517 CCN project....
Changed : 09/21/2015 jxc517 CCN Project....
          Requested to pass the format name to identify the record that
          is being updates for Bank MICR Format details
          10/13/2015 sxh487 Added EFFECTIVE_DATE as part of the 
          backfeed process
Changed : 10/27/2015 jcx517 CCN project....
          Added the OWNER clause in the cursor as ALL_* gets same table data from
          other schemas as well
Changed : 10/27/2015 jcx517 CCN project....
          Added call to IS_ROW_DATA_DIFFERENT function to make sure data actually changed or not.
          Some columns just gets updated for every commit, even though the actual data is not changed.
          This function will validate previous record and current record ignoring that columns
          which are store in AUDIT_COMPARE_IGNORE_COLUMNS table
        : 12/02/2015 dxv848 CCN project.....
          Added the logic if the new bank account is added then we have to get the recon_bank_account
          number from the data base(A bank_account_nbr padded with zeros is Recon_bank_account_nbr)
*******************************************************/
    IN_TABLE_NAME     IN     VARCHAR2,
    IN_KEY            IN     VARCHAR2,
    OUT_CC_CODE          OUT VARCHAR2,
    OUT_BNK_ACCNT_NBR    OUT VARCHAR2,
    OUT_CHANGE_TYPE      OUT VARCHAR2,
    OUT_PREV_ROW         OUT XMLTYPE,
    OUT_CURR_ROW         OUT XMLTYPE,
    OUT_DIFF             OUT XMLTYPE,
    OUT_LOG_ID_PREV      OUT NUMBER,
    OUT_LOG_ID           OUT NUMBER)
IS
    CURSOR GET_COLS (IN_TABLE IN VARCHAR2) IS
        SELECT COLUMN_NAME, COLUMN_ID
          FROM ALL_TAB_COLUMNS
         WHERE TABLE_NAME = IN_TABLE
           AND OWNER = 'BANKING'
         ORDER BY COLUMN_ID ASC;
    ROW_PREV           AUDIT_LOG.TABLE_ROW_DATA%TYPE;
    V_LOG_ID_PREV      AUDIT_LOG.LOG_ID%TYPE;
    ROW_CURR           AUDIT_LOG.TABLE_ROW_DATA%TYPE;
    V_LOG_ID_CURR      AUDIT_LOG.LOG_ID%TYPE;
    PK_CURR            AUDIT_LOG.TABLE_PK_VALUE%TYPE;
    V_CONTEXT          VARCHAR2(200);
    V_CHANGE_TYPE      VARCHAR2(1);
    COMP_CURR          VARCHAR2(1000);
    COMP_PREV          VARCHAR2(1000);
    XMLSTRING          CLOB:='';
BEGIN
    V_CONTEXT := 'Selecting Previous Row from Audit_Log';
    BEGIN
        SELECT TABLE_ROW_DATA, LOG_ID INTO ROW_PREV, V_LOG_ID_PREV
          FROM AUDIT_LOG AL,
               BATCH_JOB BATCH
         WHERE AL.TABLE_NAME        = IN_TABLE_NAME
           AND BATCH.BATCH_JOB_NAME = 'BANKING_AUDIT_LOG'
           AND AL.AUDIT_REC_FLAG    = 'R'
           AND AL.TRANSACTION_ID    = IN_KEY
           AND AL.TRANSACTION_DATE IN (SELECT MAX(AL1.TRANSACTION_DATE)
                                         FROM AUDIT_LOG AL1
                                        WHERE AL1.TABLE_NAME     = AL.TABLE_NAME
                                          AND AL1.TRANSACTION_ID = IN_KEY
                                          AND AL1.AUDIT_REC_FLAG = 'R')
           AND BATCH.BATCH_JOB_LAST_RUN_DATE IN(SELECT MAX(B1.BATCH_JOB_LAST_RUN_DATE)
                                                  FROM BATCH_JOB B1
                                                 WHERE B1.BATCH_JOB_NAME= 'BANKING_AUDIT_LOG')
           AND ROWNUM < 2
         ORDER BY AL.LOG_ID DESC;
        V_CHANGE_TYPE := 'C';
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            V_CHANGE_TYPE := 'A';
    END;
    V_CONTEXT := 'Selecting Current Row from Audit_Log';
    SELECT TABLE_ROW_DATA, LOG_ID, TABLE_PK_VALUE INTO ROW_CURR, V_LOG_ID_CURR, PK_CURR -- Added to accomodate population of primary key columns in backFeed files generated
      FROM AUDIT_LOG AL
     WHERE TABLE_NAME        = IN_TABLE_NAME
       AND AL.TRANSACTION_ID = IN_KEY
       AND AL.TRANSACTION_DATE IN (SELECT MAX(AL1.TRANSACTION_DATE)
                                     FROM AUDIT_LOG AL1
                                    WHERE AL1.TABLE_NAME     = AL.TABLE_NAME
                                      AND AL1.TRANSACTION_ID = IN_KEY
                                      AND AL1.LOG_ID        <= v_max_tran_id_current_batch)
       AND AL.LOG_ID = (SELECT MAX( AL2.LOG_ID)
                          FROM AUDIT_LOG AL2
                         WHERE AL2.TABLE_NAME = AL.TABLE_NAME
                           AND AL2.TRANSACTION_ID = IN_KEY
                           AND AL2.LOG_ID <= v_max_tran_id_current_batch)
       AND ROWNUM < 2;
    V_CONTEXT := 'Data comparision ignoring some generic columns that always change';
    IF IS_ROW_DATA_DIFFERENT(IN_TABLE_NAME, ROW_PREV, ROW_CURR) THEN
        V_CONTEXT := 'Parsing the XMLType';
        --Start building the XML string
        XMLSTRING := '<' || IN_Table_name || ' xmlns:xsi="http://www.w3.org/2001/XMLSchema" xsi:nonamespaceSchemaLocation="http://www.oracle.com/Employee.xsd">';
        FOR GET_COLS_REC IN GET_COLS(IN_TABLE_NAME) LOOP
            IF V_CHANGE_TYPE = 'C' THEN
                COMP_PREV := XML_EXTRACT_NO_EXCEPTION(ROW_PREV,'//' || GET_COLS_REC.COLUMN_NAME);
            END IF; 
            COMP_CURR := NVL(XML_EXTRACT_NO_EXCEPTION(ROW_CURR,'//' || GET_COLS_REC.COLUMN_NAME),'~');
            --If the elements have changed OR new row, append them to the XML string
            IF V_CHANGE_TYPE = 'A' THEN
                --If RECON_BANK_ACCOUNT_NBR column is removed in future, we need to send the this value manually in AUDIT
                IF GET_COLS_REC.COLUMN_NAME ='RECON_BANK_ACCOUNT_NBR' THEN
                    -- Below REGEXP_REPLACE will eliminate all characters other than digits(0-9)
                    COMP_CURR := LPAD(REGEXP_REPLACE(OUT_BNK_ACCNT_NBR,'[^[:digit:]]'),16,0);
                END IF;
                XMLSTRING := XMLSTRING || '<' || GET_COLS_REC.COLUMN_NAME || '>' || COMP_CURR || '</' || GET_COLS_REC.COLUMN_NAME || '>';
            ELSE
                --Populate the XML String only if the value is changed or if particular column is part of primary key
                IF NVL(COMP_CURR,'A') <> NVL(COMP_PREV,'A')
                   OR XML_EXTRACT_NO_EXCEPTION(PK_CURR,'//' || GET_COLS_REC.COLUMN_NAME) IS NOT NULL 
                   OR (GET_COLS_REC.COLUMN_NAME = 'FORMAT_NAME' AND IN_TABLE_NAME LIKE 'BANK_MICR_FORMAT%') 
                   OR (GET_COLS_REC.COLUMN_NAME = 'EFFECTIVE_DATE') THEN
                    XMLSTRING := XMLSTRING || '<' || GET_COLS_REC.COLUMN_NAME || '>' || COMP_CURR || '</' || GET_COLS_REC.COLUMN_NAME || '>';
                END IF;
            END IF;
            IF GET_COLS_REC.COLUMN_NAME IN ('BANK_ACCOUNT_NBR', 'LEAD_BANK_ACCOUNT_NBR') THEN
                OUT_BNK_ACCNT_NBR := COMP_CURR;
            ELSIF GET_COLS_REC.COLUMN_NAME IN ('COST_CENTER_CODE', 'LEAD_STORE_NBR', 'MEMBER_STORE_NBR') THEN
                OUT_CC_CODE := COMP_CURR;
            END IF;
        END LOOP;
        V_CONTEXT := 'Final value being set';
        XMLSTRING        := XMLSTRING || '</' || IN_Table_name || '>';
    END IF;
    UPDATE_AUDIT_REC_FLAG(IN_TABLE_NAME,IN_KEY, V_LOG_ID_PREV, V_LOG_ID_CURR, V_CONTEXT);

    OUT_CHANGE_TYPE   := V_CHANGE_TYPE;
    OUT_PREV_ROW      := ROW_PREV;
    OUT_CURR_ROW      := ROW_CURR;
    IF XMLSTRING <> EMPTY_CLOB() THEN
        OUT_DIFF          := XMLType(XMLSTRING);
    END IF;
    OUT_LOG_ID_PREV   := V_LOG_ID_PREV;
    OUT_LOG_ID        := V_LOG_ID_CURR;
END PARSE_DIFFERENCE_XML; 

PROCEDURE PROCESS_AUDIT_LOG(
/**********************************************************
This procedure is the core process that performs the required operations
for the audit log processing

Created : 09/15/2015 jcx517 CCN project....
Changed : 10/27/2015 jcx517 CCN project....
          Added condition around BUILD_FILE_SP call, as this call will not
          be needed if the difference XML itself is null
        : 06/29/2018 kxm302 CCN Project....
          Removed the call BUILD_FILE_SP as we won't be writing any files any more
**********************************************************/
    IN_TRANSACTION_ID     IN     VARCHAR2,
    IN_TABLE_NAME         IN     VARCHAR2,
    OUT_BANK_ACCOUNT_NBR     OUT VARCHAR2,
    OUT_CC_CODE              OUT VARCHAR2,
    OUT_CONTEXT              OUT VARCHAR2)
IS
    V_CONTEXT	          VARCHAR2(200);
    DIFF_XML            XMLTYPE;
    OUT_PREV_ROW        XMLTYPE;
    OUT_CURR_ROW        XMLTYPE;
    V_LOG_ID            NUMBER; --current log id
    V_LOG_ID_PREV       NUMBER; --Previous log id
    V_CC_CODE           COST_CENTER.COST_CENTER_CODE%TYPE;
    V_BANK_ACCOUNT_NBR  BANK_ACCOUNT.BANK_ACCOUNT_NBR%TYPE;
    V_CHANGE_TYPE       VARCHAR2(1) := 'A';
BEGIN
    V_CONTEXT:='Call procedure PARSE_DIFFERENCE_XML for every combination of table_name,transaction_id';
    PARSE_DIFFERENCE_XML(IN_TABLE_NAME,
                         IN_TRANSACTION_ID,
                         V_CC_CODE,
                         V_BANK_ACCOUNT_NBR,
                         V_CHANGE_TYPE,
                         OUT_PREV_ROW,
                         OUT_CURR_ROW,
                         DIFF_XML,
                         V_LOG_ID_PREV,
                         V_LOG_ID);

    OUT_BANK_ACCOUNT_NBR := V_BANK_ACCOUNT_NBR;
    OUT_CC_CODE          := V_CC_CODE;
    OUT_CONTEXT          := V_CONTEXT;
END PROCESS_AUDIT_LOG;

FUNCTION GET_MAX_TRANS_ID_LAST_BATCH
/**********************************************************
GET_MAX_TRANS_ID_LAST_BATCH

This function returns the maximum log id from 'AUDIT_LOG' table that is processed and marked as R.

Created : 08/30/2017 rxa457 CCN Project Team . . .
Modified:
**********************************************************/
RETURN audit_log.log_id%TYPE
IS
    L_LOG_ID audit_log.log_id%TYPE;
BEGIN

    SELECT MAX(LOG_ID)
      INTO L_LOG_ID
      FROM AUDIT_LOG
     WHERE AUDIT_REC_FLAG = 'R';

    RETURN L_LOG_ID;

EXCEPTION
    WHEN OTHERS THEN
        RETURN L_LOG_ID;
END GET_MAX_TRANS_ID_LAST_BATCH;

FUNCTION GET_MAX_TRANS_ID_CURRENT_BATCH
/**********************************************************
GET_MAX_TRANS_ID_CURRENT_BATCH

This function returns the maximum log id from 'AUDIT_LOG' table.

Created : 08/30/2017 rxa457 CCN Project Team . . .
**********************************************************/
RETURN audit_log.log_id%TYPE
IS
    L_LOG_ID audit_log.log_id%TYPE;
BEGIN

    SELECT MAX(LOG_ID)
      INTO L_LOG_ID
      FROM AUDIT_LOG
     WHERE AUDIT_REC_FLAG IS NULL
       AND LOG_ID > v_max_tran_id_last_batch;

    RETURN L_LOG_ID;

EXCEPTION
    WHEN OTHERS THEN
        RETURN L_LOG_ID;
END GET_MAX_TRANS_ID_CURRENT_BATCH;

PROCEDURE SELECT_AUDIT_LOG
/**********************************************************
Selects all rows from audit_log that have changed from
the last run of the backfeed process

Created : 09/15/2015 jcx517 CCN project....
Changed : 03/15/2017 gxg192 Changes to run the audit log process again if new records
                            are added in audit log while the initial process was running
        : 03/17/2017 gxg192 Changes to re-run audit process only if v_after_max_tran_id is
                            greater than v_before_max_tran_id.
        : 08/21/2017 rxa457 Changes to fix ASP-835 audit issue with multiple kickoffs.
**********************************************************/
IS
    CURSOR SEL_AUDIT_LOG IS
        SELECT DISTINCT TABLE_NAME,
               TRANSACTION_ID
          FROM AUDIT_LOG
         WHERE AUDIT_REC_FLAG IS NULL
           AND LOG_ID > v_max_tran_id_last_batch;
    V_CONTEXT	VARCHAR2(200);
    V_CC_CODE           COST_CENTER.COST_CENTER_CODE%TYPE;
    V_BANK_ACCOUNT_NBR  BANK_ACCOUNT.BANK_ACCOUNT_NBR%TYPE;
    V_BATCH_NUMBER      BATCH_JOB.BATCH_JOB_NUMBER%TYPE;
    V_TRANS_STATUS      BATCH_JOB.TRANS_STATUS%TYPE := 'SUCCESSFUL';
    V_BATCH_JOB_STATUS  BATCH_JOB.BATCH_JOB_STATUS%TYPE := 'PROCESSING';

BEGIN
    V_CONTEXT:='Inserting a record in the Batch_Job table with Status as PROCESSING';
    CCN_BATCH_PKG.INSERT_BATCH_JOB('BANKING_AUDIT_LOG', V_BATCH_NUMBER);
    CCN_BATCH_PKG.LOCK_DATABASE_SP(); -- PRAGMA AUTONOMOUS_TRANSACTION;

    v_max_tran_id_last_batch := get_max_trans_id_last_batch();
    v_max_tran_id_current_batch := get_max_trans_id_current_batch();

    FOR SEL_AUDIT_REC IN SEL_AUDIT_LOG LOOP
        BEGIN
            SAVEPOINT NEXT_AUDIT_REC;
            PROCESS_AUDIT_LOG(SEL_AUDIT_REC.TRANSACTION_ID,
                              SEL_AUDIT_REC.TABLE_NAME,
                              V_BANK_ACCOUNT_NBR,
                              V_CC_CODE,
                              V_CONTEXT);
        EXCEPTION
            WHEN OTHERS THEN
                ROLLBACK TO NEXT_AUDIT_REC;
                V_TRANS_STATUS := 'ERROR';
                errpkg.INSERT_ERROR_LOG_SP(SQLCODE,
                                           'SELECT_AUDIT_LOG', --proc name
                                           SUBSTR(SQLERRM,1,500),
                                           NVL(V_BANK_ACCOUNT_NBR, 'BANK_ACCOUNT_NBR'),
                                           NVL(V_CC_CODE, 'AUDIT'),
                                           'BANKING_AUDIT_LOG');
        END;
    END LOOP;

    V_CONTEXT:='Updating the Status in batch_job table';
    CCN_BATCH_PKG.UPDATE_BATCH_JOB('BANKING_AUDIT_LOG', V_BATCH_NUMBER, V_TRANS_STATUS);
    CCN_BATCH_PKG.UNLOCK_DATABASE_SP(); -- PRAGMA AUTONOMOUS_TRANSACTION; 
EXCEPTION
    WHEN OTHERS THEN
        V_CONTEXT := V_CONTEXT || ' ' || SQLCODE || ' ' || SQLERRM;
        ERRPKG.RAISE_ERR(-20003,'SELECT_AUDIT_LOG',V_CONTEXT);
END SELECT_AUDIT_LOG;

END BANKING_AUDIT_PKG;