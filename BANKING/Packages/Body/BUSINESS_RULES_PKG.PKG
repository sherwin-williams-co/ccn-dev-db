create or replace PACKAGE BODY         BUSINESS_RULES_PKG
AS
/**********************************************************
  This Package performs all the business rules that are applicable
  for banking application

Created : 05/26/2015 jxc517 CCN Project....
Changed :
**********************************************************/
PROCEDURE VALIDATE_DATE_RULES(
/******************************************************************************
    This procedure validates basic rules for effective date and expiration date 

Created : 07/09/2015 jxc517 CCN Project....
Changed : 07/17/2017 rxa457 CCN Project Team..
					    For Virtual bank Futures, bank effective date will not be greater than Sysdate but at the same time lead effective date will be greater than sysdate
              Future ID will be generated only when the lead or bank has a future effective date which is automatically handled by BUILD_TABLE_TYPES so it is not necessary to
              check for bank effective date when Lead effective date is being checked subsequently
*******************************************************************************/
IN_EFFECTIVE_DATE       IN     DATE,
IN_EXPIRATION_DATE      IN     DATE,
IN_FUTURE_ID            IN     NUMBER,
IN_PROCEDURE_NAME       IN     VARCHAR2,
IN_COMMENT_STRING       IN     VARCHAR2)
IS
BEGIN
    IF IN_EFFECTIVE_DATE IS NULL THEN
        ERRPKG.RAISE_ERR(errnums.en_effective_date_null,
                         IN_PROCEDURE_NAME,
                         'Effective Date of the ' || IN_COMMENT_STRING || ' cannot be null');
    END IF;
    IF NVL(IN_EXPIRATION_DATE, IN_EFFECTIVE_DATE) < IN_EFFECTIVE_DATE THEN
        ERRPKG.RAISE_ERR(errnums.en_exprtn_lt_effctv_dt_dt,
                         IN_PROCEDURE_NAME,
                         'Expiration Date of the ' || IN_COMMENT_STRING || ' cannot be less than Effective date');
    END IF;
    IF IN_FUTURE_ID IS NOT NULL THEN
        IF NVL(IN_PROCEDURE_NAME,'XYZ') <> 'ACCOUNT_MAINTENANCE_BR_SP' AND NVL(IN_COMMENT_STRING,'XYZ') <> 'Bank Account' THEN
        IF TRUNC(IN_EFFECTIVE_DATE) <= TRUNC(SYSDATE) THEN --future records can never have an effective date <= sysdate
            ERRPKG.RAISE_ERR(errnums.en_effctv_dt_lte_current_dt,
                             IN_PROCEDURE_NAME,
                             'Effective Date of the ' || IN_COMMENT_STRING || ' cannot be less than or equal to current date');
        END IF;
    END IF;
		END IF;
END VALIDATE_DATE_RULES;

PROCEDURE VALIDATE_PARENT_CHILD_DATES(
/******************************************************************************
    This procedure validates parent and childs effective date and expiration dates

Created : 07/17/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_PRNT_EFFECTIVE_DATE    IN     DATE,
IN_PRNT_EXPIRATION_DATE   IN     DATE,
IN_CHLD_EFFECTIVE_DATE    IN     DATE,
IN_CHLD_EXPIRATION_DATE   IN     DATE,
IN_PROCEDURE_NAME         IN     VARCHAR2,
IN_COMMENT_STRING         IN     VARCHAR2)
IS
BEGIN
    IF (IN_CHLD_EFFECTIVE_DATE NOT BETWEEN IN_PRNT_EFFECTIVE_DATE AND NVL(IN_PRNT_EXPIRATION_DATE, IN_CHLD_EFFECTIVE_DATE))
--child effective date not between parent effective and expiration date
       OR
       (IN_CHLD_EXPIRATION_DATE IS NULL AND IN_PRNT_EXPIRATION_DATE IS NOT NULL)
--child not expired but parent expired
       OR
       (IN_CHLD_EXPIRATION_DATE IS NOT NULL AND 
        IN_CHLD_EXPIRATION_DATE NOT BETWEEN IN_PRNT_EFFECTIVE_DATE AND NVL(IN_PRNT_EXPIRATION_DATE, IN_CHLD_EXPIRATION_DATE)) THEN
--child expiration date not between parent effective and expiration date
            ERRPKG.RAISE_ERR(errnums.en_parent_child_dates_err, IN_PROCEDURE_NAME, IN_COMMENT_STRING);
    END IF;
END VALIDATE_PARENT_CHILD_DATES;

PROCEDURE VALIDATE_CURRENT_EFFCTV_DT(
/*******************************************************************************
  This procedure will check if the current record is new and its effective date is
  less than current date

Created : 07/16/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_TABLE_NAME           IN     VARCHAR2,
IN_BANK_ACCOUNT_NBR     IN     VARCHAR2,
IN_LEAD_STORE_NBR       IN     VARCHAR2,
IN_EFFECTIVE_DATE       IN     DATE,
IN_PROCEDURE_NAME       IN     VARCHAR2,
IN_COMMENT_STRING       IN     VARCHAR2)
IS
    V_COUNT         NUMBER := 0;
BEGIN
    CASE
        WHEN IN_TABLE_NAME = 'BANK_ACCOUNT' THEN
            SELECT COUNT(*)
              INTO V_COUNT 
              FROM BANK_ACCOUNT
             WHERE BANK_ACCOUNT_NBR   = IN_BANK_ACCOUNT_NBR;
        WHEN IN_TABLE_NAME = 'BANK_MICR_FORMAT' THEN
            SELECT COUNT(*)
              INTO V_COUNT 
              FROM BANK_MICR_FORMAT
             WHERE BANK_ACCOUNT_NBR   = IN_BANK_ACCOUNT_NBR;
        WHEN IN_TABLE_NAME = 'LEAD_BANK_CC' THEN
            SELECT COUNT(*)
              INTO V_COUNT 
              FROM LEAD_BANK_CC
             WHERE LEAD_BANK_ACCOUNT_NBR   = IN_BANK_ACCOUNT_NBR;
        WHEN IN_TABLE_NAME = 'MEMBER_BANK_CC' THEN
            SELECT COUNT(*)
              INTO V_COUNT 
              FROM MEMBER_BANK_CC
             WHERE LEAD_STORE_NBR   = IN_LEAD_STORE_NBR;
        WHEN IN_TABLE_NAME = 'BANK_DEP_TICK' THEN
            SELECT COUNT(*)
              INTO V_COUNT 
              FROM BANK_DEP_TICK
             WHERE BANK_ACCOUNT_NBR  = IN_BANK_ACCOUNT_NBR
               AND COST_CENTER_CODE  = IN_LEAD_STORE_NBR;
        WHEN IN_TABLE_NAME = 'BANK_DEP_BAG_TICK' THEN
            SELECT COUNT(*)
              INTO V_COUNT 
              FROM BANK_DEP_BAG_TICK
             WHERE COST_CENTER_CODE  = IN_LEAD_STORE_NBR;
        WHEN IN_TABLE_NAME = 'BANK_DEP_TICKORD' THEN
            SELECT COUNT(*)
              INTO V_COUNT 
              FROM BANK_DEP_TICKORD
             WHERE COST_CENTER_CODE  = IN_LEAD_STORE_NBR;
    END CASE;  
    IF V_COUNT = 0 AND TRUNC(IN_EFFECTIVE_DATE) < TRUNC(SYSDATE) THEN
        ERRPKG.RAISE_ERR(errnums.en_effctv_dt_lt_current_dt,
                         IN_PROCEDURE_NAME,
                         'Effective Date of the ' || IN_COMMENT_STRING || ' cannot be less than current date');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END VALIDATE_CURRENT_EFFCTV_DT;

FUNCTION IS_LEAD_ACTV_FOR_EFFCTV_DT(
/*******************************************************************************
  This function will return "Y" if the passed lead is active for a bank account number
  that is different from the passed bank account number as of the effective dates

Created : 07/10/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE   IN     VARCHAR2,
IN_BANK_ACCOUNT_NBR   IN     VARCHAR2,
IN_EFFECTIVE_DATE     IN     DATE) RETURN VARCHAR2
IS
    V_RETURN_VALUE VARCHAR2(1) := 'N';
BEGIN
    SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
      INTO V_RETURN_VALUE
      FROM (SELECT 1
              FROM LEAD_BANK_CC
             WHERE LEAD_STORE_NBR = IN_COST_CENTER_CODE
               AND LEAD_BANK_ACCOUNT_NBR <> NVL(IN_BANK_ACCOUNT_NBR, 'X')
               AND IN_EFFECTIVE_DATE BETWEEN EFFECTIVE_DATE AND NVL(EXPIRATION_DATE, IN_EFFECTIVE_DATE)
             UNION
            SELECT 1
              FROM LEAD_BANK_CC_FUTURE
             WHERE LEAD_STORE_NBR = IN_COST_CENTER_CODE
               AND LEAD_BANK_ACCOUNT_NBR <> NVL(IN_BANK_ACCOUNT_NBR, 'X')
               AND IN_EFFECTIVE_DATE BETWEEN EFFECTIVE_DATE AND NVL(EXPIRATION_DATE, IN_EFFECTIVE_DATE)
           );
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VALUE;
END IS_LEAD_ACTV_FOR_EFFCTV_DT;

FUNCTION IS_STR_A_MBR_EVER_FROM_DT_PASD(
/*******************************************************************************
  This function will return "Y" if the passed store is a member as of input date or in future

Created : 11/12/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE   IN     VARCHAR2,
IN_EFFECTIVE_DATE     IN     DATE) RETURN VARCHAR2
IS
    V_RETURN_VALUE VARCHAR2(1) := 'N';
BEGIN
    SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
      INTO V_RETURN_VALUE
      FROM (SELECT 1
              FROM MEMBER_BANK_CC
             WHERE MEMBER_STORE_NBR = IN_COST_CENTER_CODE
               AND (IN_EFFECTIVE_DATE BETWEEN EFFECTIVE_DATE AND NVL(EXPIRATION_DATE, IN_EFFECTIVE_DATE)
                    OR EFFECTIVE_DATE >= IN_EFFECTIVE_DATE)
             UNION
            SELECT 1
              FROM MEMBER_BANK_CC_FUTURE
             WHERE MEMBER_STORE_NBR = IN_COST_CENTER_CODE
               AND (IN_EFFECTIVE_DATE BETWEEN EFFECTIVE_DATE AND NVL(EXPIRATION_DATE, IN_EFFECTIVE_DATE)
                    OR EFFECTIVE_DATE >= IN_EFFECTIVE_DATE)
           );
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VALUE;
END IS_STR_A_MBR_EVER_FROM_DT_PASD;

FUNCTION IS_BNK_ACCNT_EXPRTN_INVALID(
/******************************************************************************
  This function will return "Y" if the passed bank account contains active
  MICR Format or Lead as of the date it is being expired

Created : 07/30/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_BANK_ACCOUNT_NBR   IN     VARCHAR2,
IN_EXPIRATION_DATE    IN     DATE,
IN_FUTURE_ID          IN     NUMBER) RETURN VARCHAR2
IS
    V_RETURN_VALUE VARCHAR2(1) := 'N';
BEGIN
    IF IN_EXPIRATION_DATE IS NOT NULL THEN
        SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
          INTO V_RETURN_VALUE
          FROM (SELECT 1
                  FROM LEAD_BANK_CC LB
                 WHERE LB.LEAD_BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
                   AND (LB.EXPIRATION_DATE IS NULL OR LB.EXPIRATION_DATE > IN_EXPIRATION_DATE)
                 UNION
                SELECT 1
                  FROM LEAD_BANK_CC_FUTURE LBF
                 WHERE LBF.LEAD_BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
                   AND LBF.FUTURE_ID             = NVL(IN_FUTURE_ID, 0)
                   AND (LBF.EXPIRATION_DATE IS NULL OR LBF.EXPIRATION_DATE > IN_EXPIRATION_DATE)
               );
        IF V_RETURN_VALUE = 'N' THEN
            SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
              INTO V_RETURN_VALUE
              FROM (SELECT 1
                      FROM BANK_MICR_FORMAT BMF
                     WHERE BMF.BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
                       AND (BMF.EXPIRATION_DATE IS NULL OR BMF.EXPIRATION_DATE > IN_EXPIRATION_DATE)
                     UNION
                    SELECT 1
                      FROM BANK_MICR_FORMAT_FUTURE BMFF
                     WHERE BMFF.BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
                       AND BMFF.FUTURE_ID        = NVL(IN_FUTURE_ID, 0)
                       AND (BMFF.EXPIRATION_DATE IS NULL OR BMFF.EXPIRATION_DATE > IN_EXPIRATION_DATE)
               );
        END IF;
    END IF;
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VALUE;
END IS_BNK_ACCNT_EXPRTN_INVALID;

FUNCTION IS_MICR_EXPIRATION_INVALID(
/*******************************************************************************
  This function will return "Y" if the passed MICR-bank account combination
  contains active stores using it as of the date it is being expired

Created : 08/18/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_BANK_ACCOUNT_NBR   IN     VARCHAR2,
IN_MICR_FORMAT_ID     IN     NUMBER,
IN_EXPIRATION_DATE    IN     DATE,
IN_FUTURE_ID          IN     NUMBER) RETURN VARCHAR2
IS
    V_RETURN_VALUE VARCHAR2(1) := 'N';
BEGIN
    IF IN_EXPIRATION_DATE IS NOT NULL THEN
        SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
          INTO V_RETURN_VALUE
          FROM (SELECT 1
                  FROM STORE_MICR_FORMAT_DTLS SMFD
                 WHERE SMFD.BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
                   AND SMFD.MICR_FORMAT_ID   = IN_MICR_FORMAT_ID
                   AND (SMFD.EXPIRATION_DATE IS NULL OR SMFD.EXPIRATION_DATE > IN_EXPIRATION_DATE)
                 UNION
                SELECT 1
                  FROM STORE_MICR_FORMAT_DTLS_FUTURE SMFDF
                 WHERE SMFDF.BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
                   AND SMFDF.MICR_FORMAT_ID   = MICR_FORMAT_ID
                   AND SMFDF.FUTURE_ID        = NVL(IN_FUTURE_ID, 0)
                   AND (SMFDF.EXPIRATION_DATE IS NULL OR SMFDF.EXPIRATION_DATE > IN_EXPIRATION_DATE)
               );
    END IF;
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VALUE;
END IS_MICR_EXPIRATION_INVALID;

FUNCTION IS_LEAD_EXPIRATION_INVALID(
/*******************************************************************************
  This function will return "Y" if the passed lead-bank account combination
  contains active members as of the date it is being expired

Created : 07/14/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE   IN     VARCHAR2,
IN_BANK_ACCOUNT_NBR   IN     VARCHAR2,
IN_EXPIRATION_DATE    IN     DATE,
IN_FUTURE_ID          IN     NUMBER) RETURN VARCHAR2
IS
    V_RETURN_VALUE VARCHAR2(1) := 'N';
BEGIN
    IF IN_EXPIRATION_DATE IS NOT NULL THEN
        SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
          INTO V_RETURN_VALUE
          FROM (SELECT 1
                  FROM MEMBER_BANK_CC MB
                 WHERE MB.LEAD_BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
                   AND MB.LEAD_STORE_NBR        = IN_COST_CENTER_CODE
                   AND (MB.EXPIRATION_DATE IS NULL OR MB.EXPIRATION_DATE > IN_EXPIRATION_DATE)
                 UNION
                SELECT 1
                  FROM MEMBER_BANK_CC_FUTURE MBF
                 WHERE MBF.LEAD_BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
                   AND MBF.LEAD_STORE_NBR        = IN_COST_CENTER_CODE
                   AND MBF.FUTURE_ID             = NVL(IN_FUTURE_ID, 0)
                   AND (MBF.EXPIRATION_DATE IS NULL OR MBF.EXPIRATION_DATE > IN_EXPIRATION_DATE)
               );
        /*IF V_RETURN_VALUE = 'N' THEN
            SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
              INTO V_RETURN_VALUE
              FROM (SELECT 1
                      FROM STORE_MICR_FORMAT_DTLS SMFD
                     WHERE SMFD.COST_CENTER_CODE   = IN_COST_CENTER_CODE
                       AND (SMFD.EXPIRATION_DATE IS NULL OR SMFD.EXPIRATION_DATE > IN_EXPIRATION_DATE)
                     UNION
                    SELECT 1
                      FROM STORE_MICR_FORMAT_DTLS_FUTURE SMFDF
                     WHERE SMFDF.COST_CENTER_CODE = IN_COST_CENTER_CODE
                       AND SMFDF.FUTURE_ID        = NVL(IN_FUTURE_ID, 0)
                       AND (SMFDF.EXPIRATION_DATE IS NULL OR SMFDF.EXPIRATION_DATE > IN_EXPIRATION_DATE)
                   );
        END IF;
        IF V_RETURN_VALUE = 'N' THEN
            SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
              INTO V_RETURN_VALUE
              FROM (SELECT 1
                      FROM BANK_DEP_TICK BDT
                     WHERE BDT.COST_CENTER_CODE   = IN_COST_CENTER_CODE
                       AND (BDT.EXPIRATION_DATE IS NULL OR BDT.EXPIRATION_DATE > IN_EXPIRATION_DATE)
                     UNION
                    SELECT 1
                      FROM BANK_DEP_TICK_FUTURE BDTF
                     WHERE BDTF.COST_CENTER_CODE = IN_COST_CENTER_CODE
                       AND BDTF.FUTURE_ID        = NVL(IN_FUTURE_ID, 0)
                       AND (BDTF.EXPIRATION_DATE IS NULL OR BDTF.EXPIRATION_DATE > IN_EXPIRATION_DATE)
                   );
        END IF;*/
    END IF;
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VALUE;
END IS_LEAD_EXPIRATION_INVALID;

FUNCTION IS_LEAD_EFFECTIVE_INVALID(
/*******************************************************************************
  This function will return "Y" if the passed leads effective date is greater
  than the existing members/deposit tickets/store MICR effective dates

Created : 09/15/2015 jxc517 CCN Project....
Changed : 10/23/2015 jxc517 CCN Project....
          Relaxing the edit for child tables as there is no way for user now to
          expire these tables from UI
*******************************************************************************/
IN_COST_CENTER_CODE   IN     VARCHAR2,
IN_BANK_ACCOUNT_NBR   IN     VARCHAR2,
IN_EFFECTIVE_DATE     IN     DATE,
IN_FUTURE_ID          IN     NUMBER) RETURN VARCHAR2
IS
    V_RETURN_VALUE VARCHAR2(1) := 'N';
BEGIN
    SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
      INTO V_RETURN_VALUE
      FROM (SELECT 1
              FROM MEMBER_BANK_CC MB
             WHERE MB.LEAD_BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
               AND MB.LEAD_STORE_NBR        = IN_COST_CENTER_CODE
               AND MB.EFFECTIVE_DATE        < IN_EFFECTIVE_DATE
               AND (MB.EXPIRATION_DATE IS NULL OR MB.EXPIRATION_DATE >= IN_EFFECTIVE_DATE)
             UNION
            SELECT 1
              FROM MEMBER_BANK_CC_FUTURE MBF
             WHERE MBF.LEAD_BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
               AND MBF.LEAD_STORE_NBR        = IN_COST_CENTER_CODE
               AND MBF.FUTURE_ID             = NVL(IN_FUTURE_ID, 0)
               AND MBF.EFFECTIVE_DATE        < IN_EFFECTIVE_DATE
               AND (MBF.EXPIRATION_DATE IS NULL OR MBF.EXPIRATION_DATE >= IN_EFFECTIVE_DATE)
              /*UNION
             SELECT 1
              FROM STORE_MICR_FORMAT_DTLS SMFD
             WHERE SMFD.COST_CENTER_CODE    = IN_COST_CENTER_CODE
               AND SMFD.EFFECTIVE_DATE      < IN_EFFECTIVE_DATE
               AND (SMFD.EXPIRATION_DATE IS NULL OR SMFD.EXPIRATION_DATE >= IN_EFFECTIVE_DATE)
             UNION
            SELECT 1
              FROM STORE_MICR_FORMAT_DTLS_FUTURE SMFDF
             WHERE SMFDF.COST_CENTER_CODE    = IN_COST_CENTER_CODE
               AND SMFDF.EFFECTIVE_DATE      < IN_EFFECTIVE_DATE
               AND SMFDF.FUTURE_ID           = NVL(IN_FUTURE_ID, 0)
               AND (SMFDF.EXPIRATION_DATE IS NULL OR SMFDF.EXPIRATION_DATE >= IN_EFFECTIVE_DATE)
             UNION
            SELECT 1
              FROM BANK_DEP_TICK BDT
             WHERE BDT.COST_CENTER_CODE    = IN_COST_CENTER_CODE
               AND BDT.EFFECTIVE_DATE      < IN_EFFECTIVE_DATE
               AND (BDT.EXPIRATION_DATE IS NULL OR BDT.EXPIRATION_DATE >= IN_EFFECTIVE_DATE)
             UNION
            SELECT 1
              FROM BANK_DEP_TICK_FUTURE BDTF
             WHERE BDTF.COST_CENTER_CODE    = IN_COST_CENTER_CODE
               AND BDTF.EFFECTIVE_DATE      < IN_EFFECTIVE_DATE
               AND BDTF.FUTURE_ID           = NVL(IN_FUTURE_ID, 0)
               AND (BDTF.EXPIRATION_DATE IS NULL OR BDTF.EXPIRATION_DATE >= IN_EFFECTIVE_DATE)*/
           );
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VALUE;
END IS_LEAD_EFFECTIVE_INVALID;

FUNCTION IS_BNK_ACCNT_EXPRTN_INVALID(
/******************************************************************************
  This function will return "Y" if the passed bank account contains active
  MICR Format or Lead as of the date it is being expired

Created : 07/22/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
    IN_BANK_ACCOUNT_REC                IN BANK_ACCOUNT%ROWTYPE,
    IN_BANK_ACCOUNT_FUTURE_REC         IN BANK_ACCOUNT_FUTURE%ROWTYPE,
    IN_LEAD_BANK_CC_REC                IN LEAD_BANK_CC%ROWTYPE,
    IN_LEAD_BANK_CC_FUTURE_REC         IN LEAD_BANK_CC_FUTURE%ROWTYPE,
    IN_BANK_MICR_FORMAT_TAB            IN TABLE_IU_PKG.BANK_MICR_FORMAT_TAB_TYPE,
    IN_BANK_MICR_FORMAT_FUTURE_TAB     IN TABLE_IU_PKG.BANK_MICR_FORMAT_FTR_TAB_TYPE) RETURN VARCHAR2
IS
    V_INDEX        NUMBER := 0;
    V_RETURN_VALUE VARCHAR2(1) := 'N';
BEGIN
    IF IN_BANK_ACCOUNT_REC.EXPIRATION_DATE IS NOT NULL THEN
        IF IN_LEAD_BANK_CC_REC.EXPIRATION_DATE IS NULL
           OR IN_LEAD_BANK_CC_REC.EXPIRATION_DATE > IN_BANK_ACCOUNT_REC.EXPIRATION_DATE THEN
            V_RETURN_VALUE := 'Y';
        ELSE
            V_INDEX := IN_BANK_MICR_FORMAT_TAB.FIRST;
            WHILE V_INDEX IS NOT NULL LOOP
                IF IN_BANK_MICR_FORMAT_TAB(V_INDEX).EXPIRATION_DATE IS NULL
                   OR IN_BANK_MICR_FORMAT_TAB(V_INDEX).EXPIRATION_DATE > IN_BANK_ACCOUNT_REC.EXPIRATION_DATE THEN
                    V_RETURN_VALUE := 'Y';
                END IF;
                V_INDEX := IN_BANK_MICR_FORMAT_TAB.NEXT(V_INDEX);
            END LOOP;
        END IF;
    ELSIF IN_BANK_ACCOUNT_FUTURE_REC.EXPIRATION_DATE IS NOT NULL THEN
        IF IN_LEAD_BANK_CC_FUTURE_REC.EXPIRATION_DATE IS NULL
           OR IN_LEAD_BANK_CC_FUTURE_REC.EXPIRATION_DATE > IN_BANK_ACCOUNT_FUTURE_REC.EXPIRATION_DATE THEN
            V_RETURN_VALUE := 'Y';
        ELSE
            V_INDEX := IN_BANK_MICR_FORMAT_FUTURE_TAB.FIRST;
            WHILE V_INDEX IS NOT NULL LOOP
                IF IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).EXPIRATION_DATE IS NULL
                   OR IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).EXPIRATION_DATE > IN_BANK_ACCOUNT_FUTURE_REC.EXPIRATION_DATE THEN
                    V_RETURN_VALUE := 'Y';
                END IF;
                V_INDEX := IN_BANK_MICR_FORMAT_FUTURE_TAB.NEXT(V_INDEX);
            END LOOP;
        END IF;
    END IF;
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VALUE;
END IS_BNK_ACCNT_EXPRTN_INVALID;

FUNCTION IS_BNK_ACCNT_EFFCTV_INVALID(
/******************************************************************************
  This function will return "Y" if the passed bank account contains active
  MICR Format or Lead before it's effective date

Created : 09/15/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
    IN_BANK_ACCOUNT_REC                IN BANK_ACCOUNT%ROWTYPE,
    IN_BANK_ACCOUNT_FUTURE_REC         IN BANK_ACCOUNT_FUTURE%ROWTYPE,
    IN_LEAD_BANK_CC_REC                IN LEAD_BANK_CC%ROWTYPE,
    IN_LEAD_BANK_CC_FUTURE_REC         IN LEAD_BANK_CC_FUTURE%ROWTYPE,
    IN_BANK_MICR_FORMAT_TAB            IN TABLE_IU_PKG.BANK_MICR_FORMAT_TAB_TYPE,
    IN_BANK_MICR_FORMAT_FUTURE_TAB     IN TABLE_IU_PKG.BANK_MICR_FORMAT_FTR_TAB_TYPE) RETURN VARCHAR2
IS
    V_INDEX        NUMBER := 0;
    V_RETURN_VALUE VARCHAR2(1) := 'N';
BEGIN
    IF IN_BANK_ACCOUNT_REC.EFFECTIVE_DATE IS NOT NULL THEN
        IF IN_LEAD_BANK_CC_REC.EFFECTIVE_DATE < IN_BANK_ACCOUNT_REC.EFFECTIVE_DATE
           AND (IN_LEAD_BANK_CC_REC.EXPIRATION_DATE IS NULL OR IN_LEAD_BANK_CC_REC.EXPIRATION_DATE >= IN_BANK_ACCOUNT_REC.EFFECTIVE_DATE) THEN
            V_RETURN_VALUE := 'Y';
        ELSE
            V_INDEX := IN_BANK_MICR_FORMAT_TAB.FIRST;
            WHILE V_INDEX IS NOT NULL LOOP
                IF IN_BANK_MICR_FORMAT_TAB(V_INDEX).EFFECTIVE_DATE < IN_BANK_ACCOUNT_REC.EFFECTIVE_DATE 
                   AND (IN_BANK_MICR_FORMAT_TAB(V_INDEX).EXPIRATION_DATE IS NULL OR IN_BANK_MICR_FORMAT_TAB(V_INDEX).EXPIRATION_DATE >= IN_BANK_ACCOUNT_REC.EFFECTIVE_DATE) THEN
                    V_RETURN_VALUE := 'Y';
                END IF; 
                V_INDEX := IN_BANK_MICR_FORMAT_TAB.NEXT(V_INDEX);
            END LOOP; 
        END IF;
    ELSIF IN_BANK_ACCOUNT_FUTURE_REC.EFFECTIVE_DATE IS NOT NULL THEN
        IF IN_LEAD_BANK_CC_FUTURE_REC.EFFECTIVE_DATE < IN_BANK_ACCOUNT_FUTURE_REC.EFFECTIVE_DATE 
           AND (IN_LEAD_BANK_CC_FUTURE_REC.EXPIRATION_DATE IS NULL OR IN_LEAD_BANK_CC_FUTURE_REC.EXPIRATION_DATE >= IN_BANK_ACCOUNT_FUTURE_REC.EFFECTIVE_DATE) THEN
            V_RETURN_VALUE := 'Y';
        ELSE
            V_INDEX := IN_BANK_MICR_FORMAT_FUTURE_TAB.FIRST;
            WHILE V_INDEX IS NOT NULL LOOP
                IF IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).EFFECTIVE_DATE < IN_BANK_ACCOUNT_FUTURE_REC.EFFECTIVE_DATE
                   AND (IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).EXPIRATION_DATE IS NULL OR IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).EXPIRATION_DATE >= IN_BANK_ACCOUNT_FUTURE_REC.EFFECTIVE_DATE) THEN
                    V_RETURN_VALUE := 'Y';
                END IF;
                V_INDEX := IN_BANK_MICR_FORMAT_FUTURE_TAB.NEXT(V_INDEX);
            END LOOP;
        END IF;
    END IF;
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VALUE;
END IS_BNK_ACCNT_EFFCTV_INVALID;

FUNCTION IS_BNK_ACCNT_FTR_EFFCTV_INVALD(
/******************************************************************************
  This function will return "Y" if the passed bank account effective date is
  less than or equal to previous records effective date

Created : 07/28/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
    IN_BANK_ACCOUNT_FUTURE_REC         IN BANK_ACCOUNT_FUTURE%ROWTYPE) RETURN VARCHAR2
IS
    V_INDEX        NUMBER := 0;
    V_RETURN_VALUE VARCHAR2(1) := 'N';
BEGIN
    SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
      INTO V_RETURN_VALUE
      FROM (SELECT BANK_ACCOUNT_NBR, EFFECTIVE_DATE, EXPIRATION_DATE
              FROM BANK_ACCOUNT
             WHERE BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_FUTURE_REC.BANK_ACCOUNT_NBR
             UNION
            SELECT BANK_ACCOUNT_NBR, EFFECTIVE_DATE, EXPIRATION_DATE
              FROM BANK_ACCOUNT_FUTURE
             WHERE BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_FUTURE_REC.BANK_ACCOUNT_NBR
               AND FUTURE_ID        < IN_BANK_ACCOUNT_FUTURE_REC.FUTURE_ID)
     WHERE EFFECTIVE_DATE >= IN_BANK_ACCOUNT_FUTURE_REC.EFFECTIVE_DATE;
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VALUE;
END IS_BNK_ACCNT_FTR_EFFCTV_INVALD;

FUNCTION IS_MICR_FORMAT_ADDED_TWICE(
/*******************************************************************************
  This procedure will check if the same MICR format is added twice or not

created : 08/17/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_BANK_MICR_FORMAT_NAME       IN     VARCHAR2,
IN_BANK_MICR_FORMAT_CC_TAB     IN     TABLE_IU_PKG.BANK_MICR_FORMAT_TAB_TYPE,
IN_BANK_MICR_FORMAT_FUTURE_TAB IN     TABLE_IU_PKG.BANK_MICR_FORMAT_FTR_TAB_TYPE) RETURN VARCHAR2
IS
    V_INDEX         NUMBER := 0;
    V_FORMAT_COUNT  NUMBER := 0;
    V_RETURN_VAL    VARCHAR2(1) := 'N';
BEGIN
    IF IN_BANK_MICR_FORMAT_CC_TAB.COUNT > 0 THEN
        V_INDEX := IN_BANK_MICR_FORMAT_CC_TAB.FIRST;
        WHILE V_INDEX IS NOT NULL LOOP
            IF IN_BANK_MICR_FORMAT_CC_TAB(V_INDEX).FORMAT_NAME = IN_BANK_MICR_FORMAT_NAME THEN
                V_FORMAT_COUNT := V_FORMAT_COUNT + 1;
            END IF;
            IF V_FORMAT_COUNT > 1 THEN
                V_RETURN_VAL := 'Y';
                EXIT;
            END IF;
            V_INDEX := IN_BANK_MICR_FORMAT_CC_TAB.NEXT(V_INDEX);
        END LOOP;  
    END IF;
    IF IN_BANK_MICR_FORMAT_FUTURE_TAB.COUNT > 0 THEN
        V_INDEX := IN_BANK_MICR_FORMAT_FUTURE_TAB.FIRST;
        WHILE V_INDEX IS NOT NULL LOOP
            IF IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).FORMAT_NAME = IN_BANK_MICR_FORMAT_NAME THEN
                V_FORMAT_COUNT := V_FORMAT_COUNT + 1;
            END IF;
            IF V_FORMAT_COUNT > 1 THEN
                V_RETURN_VAL := 'Y';
                EXIT;
            END IF;
            V_INDEX := IN_BANK_MICR_FORMAT_FUTURE_TAB.NEXT(V_INDEX);
        END LOOP;  
    END IF;
    RETURN V_RETURN_VAL;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VAL;
END IS_MICR_FORMAT_ADDED_TWICE;

FUNCTION IS_LEAD_BANK_TYPE_INVALID(
/*******************************************************************************
  This function will return "Y" if the passed lead type is independent and
  it got no members under it

Created : 08/21/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE   IN     VARCHAR2,
IN_BANK_ACCOUNT_NBR   IN     VARCHAR2,
IN_LEAD_BANK_TYPE     IN     VARCHAR2,
IN_EFFECTIVE_DATE     IN     DATE,
IN_FUTURE_ID          IN     NUMBER) RETURN VARCHAR2
IS
    V_RETURN_VALUE VARCHAR2(1) := 'N';
BEGIN
    IF IN_LEAD_BANK_TYPE = 'I' THEN
        SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
          INTO V_RETURN_VALUE
          FROM (SELECT 1
                  FROM MEMBER_BANK_CC MB
                 WHERE MB.LEAD_BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
                   AND MB.LEAD_STORE_NBR        = IN_COST_CENTER_CODE
                   AND IN_EFFECTIVE_DATE BETWEEN MB.EFFECTIVE_DATE AND NVL(MB.EXPIRATION_DATE, IN_EFFECTIVE_DATE)
                 UNION
                SELECT 1
                  FROM MEMBER_BANK_CC_FUTURE MBF
                 WHERE MBF.LEAD_BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
                   AND MBF.LEAD_STORE_NBR        = IN_COST_CENTER_CODE
                   AND MBF.FUTURE_ID             = NVL(IN_FUTURE_ID, 0)
                   AND IN_EFFECTIVE_DATE BETWEEN MBF.EFFECTIVE_DATE AND NVL(MBF.EXPIRATION_DATE, IN_EFFECTIVE_DATE)
               );
    END IF;
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VALUE;
END IS_LEAD_BANK_TYPE_INVALID;

FUNCTION IS_LEAD_BANK_TYPE_CHNG(
/*******************************************************************************
  This function will return "Y" if the passed lead type is changed from existing

Created : 10/06/2017 axk326 CCN Project Team....
Changed : 12/20/2016 jxc517 CCN Project Team....
          Corrected the braces to avoid wrong values getting pulled from the query
*******************************************************************************/
IN_COST_CENTER_CODE   IN     VARCHAR2,
IN_BANK_ACCOUNT_NBR   IN     VARCHAR2,
IN_LEAD_BANK_TYPE     IN     VARCHAR2,
IN_EFFECTIVE_DATE     IN     DATE) RETURN VARCHAR2
IS
    V_RETURN_VALUE VARCHAR2(1) := 'N';
BEGIN
    SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
      INTO V_RETURN_VALUE
      FROM LEAD_BANK_CC 
     WHERE LEAD_STORE_NBR = IN_COST_CENTER_CODE
       AND LEAD_BANK_ACCOUNT_NBR = IN_BANK_ACCOUNT_NBR
       AND ((BANK_TYPE_CODE = IN_LEAD_BANK_TYPE AND EFFECTIVE_DATE <> IN_EFFECTIVE_DATE)
           OR (BANK_TYPE_CODE <> IN_LEAD_BANK_TYPE AND EFFECTIVE_DATE = IN_EFFECTIVE_DATE));
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VALUE;
END IS_LEAD_BANK_TYPE_CHNG;

PROCEDURE ACCOUNT_MAINTENANCE_BR_SP(
/******************************************************************************
    This procedure validates the business rules for Account Maintenance Window 

Created : 07/09/2015 jxc517 CCN Project....
Changed : 11/12/2015 jxc517 CCN Project....
          Added a new rule NOT to allow a store as a lead if he is a member 
          as of the input effective date or in future
        : 03/15/2016 dxv848 CCN Project....
          commented the IS_LEAD_ACTV_FOR_EFFCTV_DT,IS_STR_A_MBR_EVER_FROM_DT_PASD validations
          become it won't consider when we are create a future bank with future lead store
*******************************************************************************/
    IN_BANK_ACCOUNT_REC                IN BANK_ACCOUNT%ROWTYPE,
    IN_BANK_ACCOUNT_FUTURE_REC         IN BANK_ACCOUNT_FUTURE%ROWTYPE,
    IN_LEAD_BANK_CC_REC                IN LEAD_BANK_CC%ROWTYPE,
    IN_LEAD_BANK_CC_FUTURE_REC         IN LEAD_BANK_CC_FUTURE%ROWTYPE,
    IN_BANK_MICR_FORMAT_TAB            IN TABLE_IU_PKG.BANK_MICR_FORMAT_TAB_TYPE,
    IN_BANK_MICR_FORMAT_FUTURE_TAB     IN TABLE_IU_PKG.BANK_MICR_FORMAT_FTR_TAB_TYPE)
IS
    V_INDEX                       NUMBER := 0;
    V_PROC_NAME                   VARCHAR2(30) := 'ACCOUNT_MAINTENANCE_BR_SP';
    V_MICR_FORMAT_NAME            VARCHAR2(10);
    V_BANK_MICR_FORMAT_TAB        TABLE_IU_PKG.BANK_MICR_FORMAT_TAB_TYPE;
    V_BANK_MICR_FORMAT_FUTURE_TAB TABLE_IU_PKG.BANK_MICR_FORMAT_FTR_TAB_TYPE;
    lead_exists_for_effctv_dt      EXCEPTION;
    lead_exprd_with_actv_chlds     EXCEPTION;
    effctv_dt_lt_current_dt        EXCEPTION;
    bnk_accnt_exprd_wt_actv_chld   EXCEPTION;
    bnk_accnt_ftr_effctv_err       EXCEPTION;
    micr_added_twice               EXCEPTION;
    micr_exprd_with_actv_dptks     EXCEPTION;
    lead_indpdt_with_actv_mbr      EXCEPTION;
    lead_bnk_typ_not_chg_err       EXCEPTION;
    childs_effctv_before_parent    EXCEPTION;
    book_keeper_null_err           EXCEPTION;
    lead_ever_mbr_from_effctv_dt   EXCEPTION;
BEGIN
    IF IN_BANK_ACCOUNT_REC.BANK_ACCOUNT_NBR IS NOT NULL THEN
    --********************************************************************************
    --BANK_ACCOUNT Validations
    --********************************************************************************
        VALIDATE_DATE_RULES(IN_BANK_ACCOUNT_REC.EFFECTIVE_DATE,
                            IN_BANK_ACCOUNT_REC.EXPIRATION_DATE,
                            NULL,
                            V_PROC_NAME,
                            'Bank Account');
        IF IS_BNK_ACCNT_EXPRTN_INVALID(IN_BANK_ACCOUNT_REC,
                                       IN_BANK_ACCOUNT_FUTURE_REC,
                                       IN_LEAD_BANK_CC_REC,
                                       IN_LEAD_BANK_CC_FUTURE_REC,
                                       IN_BANK_MICR_FORMAT_TAB,
                                       IN_BANK_MICR_FORMAT_FUTURE_TAB) = 'Y' THEN
            RAISE bnk_accnt_exprd_wt_actv_chld;
        END IF;
        IF IS_BNK_ACCNT_EFFCTV_INVALID(IN_BANK_ACCOUNT_REC,
                                       IN_BANK_ACCOUNT_FUTURE_REC,
                                       IN_LEAD_BANK_CC_REC,
                                       IN_LEAD_BANK_CC_FUTURE_REC,
                                       IN_BANK_MICR_FORMAT_TAB,
                                       IN_BANK_MICR_FORMAT_FUTURE_TAB) = 'Y' THEN                          
            RAISE childs_effctv_before_parent; 
        END IF;
        VALIDATE_CURRENT_EFFCTV_DT('BANK_ACCOUNT',
                                   IN_BANK_ACCOUNT_REC.BANK_ACCOUNT_NBR,
                                   NULL, --lead store nbr
                                   IN_BANK_ACCOUNT_REC.EFFECTIVE_DATE,
                                   V_PROC_NAME,
                                   'Bank Account');
        IF IN_BANK_ACCOUNT_REC.BOOK_KEEPER_NBR IS NULL THEN
            RAISE book_keeper_null_err;
        END IF;
    ELSIF IN_BANK_ACCOUNT_FUTURE_REC.BANK_ACCOUNT_NBR IS NOT NULL THEN
    --********************************************************************************
    --BANK_ACCOUNT_FUTURE Validations
    --********************************************************************************
        VALIDATE_DATE_RULES(IN_BANK_ACCOUNT_FUTURE_REC.EFFECTIVE_DATE,
                            IN_BANK_ACCOUNT_FUTURE_REC.EXPIRATION_DATE,
                            IN_BANK_ACCOUNT_FUTURE_REC.FUTURE_ID,
                            V_PROC_NAME,
                            'Bank Account');
        IF IS_BNK_ACCNT_EXPRTN_INVALID(IN_BANK_ACCOUNT_REC,
                                       IN_BANK_ACCOUNT_FUTURE_REC,
                                       IN_LEAD_BANK_CC_REC,
                                       IN_LEAD_BANK_CC_FUTURE_REC,
                                       IN_BANK_MICR_FORMAT_TAB,
                                       IN_BANK_MICR_FORMAT_FUTURE_TAB) = 'Y' THEN
            RAISE bnk_accnt_exprd_wt_actv_chld;
        END IF;
        IF IS_BNK_ACCNT_EFFCTV_INVALID(IN_BANK_ACCOUNT_REC,
                                       IN_BANK_ACCOUNT_FUTURE_REC,
                                       IN_LEAD_BANK_CC_REC,
                                       IN_LEAD_BANK_CC_FUTURE_REC,
                                       IN_BANK_MICR_FORMAT_TAB,
                                       IN_BANK_MICR_FORMAT_FUTURE_TAB) = 'Y' THEN
            RAISE childs_effctv_before_parent;
        END IF;
        IF IS_BNK_ACCNT_FTR_EFFCTV_INVALD(IN_BANK_ACCOUNT_FUTURE_REC) = 'Y' THEN
            RAISE bnk_accnt_ftr_effctv_err;
        END IF;
        IF IN_BANK_ACCOUNT_FUTURE_REC.BOOK_KEEPER_NBR IS NULL THEN
            RAISE book_keeper_null_err;
        END IF;
    END IF;
    IF IN_LEAD_BANK_CC_REC.LEAD_STORE_NBR IS NOT NULL THEN
    --********************************************************************************
    --LEAD_BANK_CC Validations
    --********************************************************************************
        VALIDATE_DATE_RULES(IN_LEAD_BANK_CC_REC.EFFECTIVE_DATE,
                            IN_LEAD_BANK_CC_REC.EXPIRATION_DATE,
                            NULL,
                            V_PROC_NAME,
                            'Lead');
        VALIDATE_PARENT_CHILD_DATES(IN_BANK_ACCOUNT_REC.EFFECTIVE_DATE,
                                    IN_BANK_ACCOUNT_REC.EXPIRATION_DATE,
                                    IN_LEAD_BANK_CC_REC.EFFECTIVE_DATE,
                                    IN_LEAD_BANK_CC_REC.EXPIRATION_DATE,
                                    V_PROC_NAME,
                                    'Lead Bank CC dates can not be outside Bank Account dates');
        VALIDATE_CURRENT_EFFCTV_DT('LEAD_BANK_CC',
                                   IN_LEAD_BANK_CC_REC.LEAD_BANK_ACCOUNT_NBR,
                                   IN_LEAD_BANK_CC_REC.LEAD_STORE_NBR,
                                   IN_LEAD_BANK_CC_REC.EFFECTIVE_DATE,
                                   V_PROC_NAME,
                                   'Lead');
        IF IS_LEAD_ACTV_FOR_EFFCTV_DT(IN_LEAD_BANK_CC_REC.LEAD_STORE_NBR,
                                      IN_LEAD_BANK_CC_REC.LEAD_BANK_ACCOUNT_NBR,
                                      IN_LEAD_BANK_CC_REC.EFFECTIVE_DATE) = 'Y' THEN
            RAISE lead_exists_for_effctv_dt;
        END IF;
        IF IS_STR_A_MBR_EVER_FROM_DT_PASD(IN_LEAD_BANK_CC_REC.LEAD_STORE_NBR,
                                          IN_LEAD_BANK_CC_REC.EFFECTIVE_DATE) = 'Y' THEN
            RAISE lead_ever_mbr_from_effctv_dt;
        END IF;
        IF IS_LEAD_EXPIRATION_INVALID(IN_LEAD_BANK_CC_REC.LEAD_STORE_NBR,
                                      IN_LEAD_BANK_CC_REC.LEAD_BANK_ACCOUNT_NBR,
                                      IN_LEAD_BANK_CC_REC.EXPIRATION_DATE,
                                      NULL) = 'Y' THEN
            RAISE lead_exprd_with_actv_chlds;
        END IF;
        IF IS_LEAD_EFFECTIVE_INVALID(IN_LEAD_BANK_CC_REC.LEAD_STORE_NBR,
                                      IN_LEAD_BANK_CC_REC.LEAD_BANK_ACCOUNT_NBR,
                                      IN_LEAD_BANK_CC_REC.EFFECTIVE_DATE,
                                      NULL) = 'Y' THEN
            RAISE childs_effctv_before_parent;
        END IF;
        IF IS_LEAD_BANK_TYPE_INVALID(IN_LEAD_BANK_CC_REC.LEAD_STORE_NBR,
                                     IN_LEAD_BANK_CC_REC.LEAD_BANK_ACCOUNT_NBR,
                                     IN_LEAD_BANK_CC_REC.BANK_TYPE_CODE,
                                     IN_LEAD_BANK_CC_REC.EFFECTIVE_DATE,
                                     NULL) = 'Y' THEN
            RAISE lead_indpdt_with_actv_mbr;
        END IF;
        IF IS_LEAD_BANK_TYPE_CHNG(IN_LEAD_BANK_CC_REC.LEAD_STORE_NBR,
                                     IN_LEAD_BANK_CC_REC.LEAD_BANK_ACCOUNT_NBR,
                                     IN_LEAD_BANK_CC_REC.BANK_TYPE_CODE,
                                     IN_LEAD_BANK_CC_REC.EFFECTIVE_DATE) = 'Y' THEN
            RAISE lead_bnk_typ_not_chg_err;
        END IF;
    ELSIF IN_LEAD_BANK_CC_FUTURE_REC.LEAD_STORE_NBR IS NOT NULL THEN
    --********************************************************************************
    --LEAD_BANK_CC_FUTURE Validations
    --********************************************************************************
        VALIDATE_DATE_RULES(IN_LEAD_BANK_CC_FUTURE_REC.EFFECTIVE_DATE,
                            IN_LEAD_BANK_CC_FUTURE_REC.EXPIRATION_DATE,
                            IN_LEAD_BANK_CC_FUTURE_REC.FUTURE_ID,
                            V_PROC_NAME,
                            'Lead');
        VALIDATE_PARENT_CHILD_DATES(IN_BANK_ACCOUNT_FUTURE_REC.EFFECTIVE_DATE,
                                    IN_BANK_ACCOUNT_FUTURE_REC.EXPIRATION_DATE,
                                    IN_LEAD_BANK_CC_FUTURE_REC.EFFECTIVE_DATE,
                                    IN_LEAD_BANK_CC_FUTURE_REC.EXPIRATION_DATE,
                                    V_PROC_NAME,
                                    'Lead Bank CC dates can not be outside Bank Account dates');
       -- commented the IS_LEAD_ACTV_FOR_EFFCTV_DT,IS_STR_A_MBR_EVER_FROM_DT_PASD validations become it wont consider when we are create a future bank with future lead store
       /*IF IS_LEAD_ACTV_FOR_EFFCTV_DT(IN_LEAD_BANK_CC_FUTURE_REC.LEAD_STORE_NBR,
                                      IN_LEAD_BANK_CC_FUTURE_REC.LEAD_BANK_ACCOUNT_NBR,
                                      IN_LEAD_BANK_CC_FUTURE_REC.EFFECTIVE_DATE) = 'Y' THEN
            RAISE lead_exists_for_effctv_dt;
        END IF;
        IF IS_STR_A_MBR_EVER_FROM_DT_PASD(IN_LEAD_BANK_CC_FUTURE_REC.LEAD_STORE_NBR,
                                          IN_LEAD_BANK_CC_FUTURE_REC.EFFECTIVE_DATE) = 'Y' THEN
            RAISE lead_ever_mbr_from_effctv_dt;
        END IF;*/

        IF IS_LEAD_EXPIRATION_INVALID(IN_LEAD_BANK_CC_FUTURE_REC.LEAD_STORE_NBR,
                                      IN_LEAD_BANK_CC_FUTURE_REC.LEAD_BANK_ACCOUNT_NBR,
                                      IN_LEAD_BANK_CC_FUTURE_REC.EXPIRATION_DATE,
                                      IN_LEAD_BANK_CC_FUTURE_REC.FUTURE_ID) = 'Y' THEN
            RAISE lead_exprd_with_actv_chlds;
        END IF;
        IF IS_LEAD_EFFECTIVE_INVALID(IN_LEAD_BANK_CC_FUTURE_REC.LEAD_STORE_NBR,
                                      IN_LEAD_BANK_CC_FUTURE_REC.LEAD_BANK_ACCOUNT_NBR,
                                      IN_LEAD_BANK_CC_FUTURE_REC.EFFECTIVE_DATE,
                                      IN_LEAD_BANK_CC_FUTURE_REC.FUTURE_ID) = 'Y' THEN
            RAISE childs_effctv_before_parent;
        END IF;
        IF IS_LEAD_BANK_TYPE_INVALID(IN_LEAD_BANK_CC_FUTURE_REC.LEAD_STORE_NBR,
                                     IN_LEAD_BANK_CC_FUTURE_REC.LEAD_BANK_ACCOUNT_NBR,
                                     IN_LEAD_BANK_CC_FUTURE_REC.BANK_TYPE_CODE,
                                     IN_LEAD_BANK_CC_FUTURE_REC.EFFECTIVE_DATE,
                                     IN_LEAD_BANK_CC_FUTURE_REC.FUTURE_ID) = 'Y' THEN
            RAISE lead_indpdt_with_actv_mbr;
        END IF;
        IF IS_LEAD_BANK_TYPE_CHNG(IN_LEAD_BANK_CC_REC.LEAD_STORE_NBR,
                                     IN_LEAD_BANK_CC_REC.LEAD_BANK_ACCOUNT_NBR,
                                     IN_LEAD_BANK_CC_REC.BANK_TYPE_CODE,
                                     IN_LEAD_BANK_CC_REC.EFFECTIVE_DATE) = 'Y' THEN
            RAISE lead_bnk_typ_not_chg_err;
        END IF;
    END IF;
    IF IN_BANK_MICR_FORMAT_TAB.COUNT > 0 THEN
    --********************************************************************************
    --BANK_MICR_FORMAT Validations
    --********************************************************************************
        V_INDEX := IN_BANK_MICR_FORMAT_TAB.FIRST;
        WHILE V_INDEX IS NOT NULL LOOP
            VALIDATE_DATE_RULES(IN_BANK_MICR_FORMAT_TAB(V_INDEX).EFFECTIVE_DATE,
                                IN_BANK_MICR_FORMAT_TAB(V_INDEX).EXPIRATION_DATE,
                                NULL,
                                V_PROC_NAME,
                                'MICR Format');
            --can't enter same MICR Format Name more than once
            V_MICR_FORMAT_NAME := IN_BANK_MICR_FORMAT_TAB(V_INDEX).FORMAT_NAME;
            IF IS_MICR_FORMAT_ADDED_TWICE(V_MICR_FORMAT_NAME,
                                          IN_BANK_MICR_FORMAT_TAB,
                                          V_BANK_MICR_FORMAT_FUTURE_TAB) = 'Y' THEN --never touch NULL V_BANK_MICR_FORMAT_FUTURE_TAB here
                RAISE micr_added_twice;
            END IF;
            IF IS_MICR_EXPIRATION_INVALID(IN_BANK_MICR_FORMAT_TAB(V_INDEX).BANK_ACCOUNT_NBR,
                                          IN_BANK_MICR_FORMAT_TAB(V_INDEX).MICR_FORMAT_ID,
                                          IN_BANK_MICR_FORMAT_TAB(V_INDEX).EXPIRATION_DATE,
                                          NULL) = 'Y' THEN
                RAISE micr_exprd_with_actv_dptks;
            END IF;
            VALIDATE_CURRENT_EFFCTV_DT('BANK_MICR_FORMAT',
                                       IN_BANK_MICR_FORMAT_TAB(V_INDEX).BANK_ACCOUNT_NBR,
                                       NULL, --lead store nbr
                                       IN_BANK_MICR_FORMAT_TAB(V_INDEX).EFFECTIVE_DATE,
                                       V_PROC_NAME,
                                       'MICR Format');
            V_INDEX := IN_BANK_MICR_FORMAT_TAB.NEXT(V_INDEX);
        END LOOP;
    ELSIF IN_BANK_MICR_FORMAT_FUTURE_TAB.COUNT > 0 THEN
    --********************************************************************************
    --BANK_MICR_FORMAT_FUTURE Validations
    --********************************************************************************
        V_INDEX := IN_BANK_MICR_FORMAT_FUTURE_TAB.FIRST;
        WHILE V_INDEX IS NOT NULL LOOP
            VALIDATE_DATE_RULES(IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).EFFECTIVE_DATE,
                                IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).EXPIRATION_DATE,
                                IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).FUTURE_ID,
                                V_PROC_NAME,
                                'MICR Format');
            --can't enter same MICR Format Name more than once
            V_MICR_FORMAT_NAME := IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).FORMAT_NAME;
            IF IS_MICR_FORMAT_ADDED_TWICE(V_MICR_FORMAT_NAME,
                                          V_BANK_MICR_FORMAT_TAB, --never touch NULL V_BANK_MICR_FORMAT_TAB here
                                          IN_BANK_MICR_FORMAT_FUTURE_TAB) = 'Y' THEN
                RAISE micr_added_twice;
            END IF;
            IF IS_MICR_EXPIRATION_INVALID(IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).BANK_ACCOUNT_NBR,
                                          IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).MICR_FORMAT_ID,
                                          IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).EXPIRATION_DATE,
                                          IN_BANK_MICR_FORMAT_FUTURE_TAB(V_INDEX).FUTURE_ID) = 'Y' THEN
                RAISE micr_exprd_with_actv_dptks;
            END IF;
            V_INDEX := IN_BANK_MICR_FORMAT_FUTURE_TAB.NEXT(V_INDEX);
        END LOOP;    
    END IF;
EXCEPTION
    WHEN bnk_accnt_exprd_wt_actv_chld THEN
        ERRPKG.RAISE_ERR(errnums.en_bnk_accnt_expr_wt_actv_chld,
                         V_PROC_NAME,
                         'Bank Account can not be expired with active MICR Formats/Leads. Expire MICR Formats and Leads under this bank account number first');
    WHEN bnk_accnt_ftr_effctv_err THEN
        ERRPKG.RAISE_ERR(errnums.en_bnk_accnt_ftr_effctv_err,
                         V_PROC_NAME,
                         'Future Bank Account effective date can not be less than or equal to previous Bank Account effective date');
    WHEN lead_exists_for_effctv_dt THEN
        ERRPKG.RAISE_ERR(errnums.en_lead_exists_for_effctv_dt,
                         V_PROC_NAME,
                         'Lead is already active for another bank account as of the effective date');
    WHEN lead_exprd_with_actv_chlds THEN
        ERRPKG.RAISE_ERR(errnums.en_lead_exprd_with_actv_chlds,
                         V_PROC_NAME,
                         'Lead can not be expired with active members/store deposit tickets. Expire members/store deposit tickets under this lead-bank account number combination first');
    WHEN lead_indpdt_with_actv_mbr THEN
        ERRPKG.RAISE_ERR(errnums.en_lead_indpdt_with_actv_mbr,
                         V_PROC_NAME,
                         'Lead can not be an independent with members active under it. Expire all the members under this lead first');
    WHEN micr_added_twice THEN
        ERRPKG.RAISE_ERR(errnums.en_micr_added_twice,
                         V_PROC_NAME,
                         'Format "'|| V_MICR_FORMAT_NAME ||'" already exists in this Account - MICR Format Name sent twice');
    WHEN micr_exprd_with_actv_dptks THEN
        ERRPKG.RAISE_ERR(errnums.en_micr_exprd_with_actv_dptks,
                         V_PROC_NAME,
                         'MICR can not be expired with active store deposit tickets. Expire store deposit tickets under this MICR-bank account number combination first');
    WHEN childs_effctv_before_parent THEN
        ERRPKG.RAISE_ERR(errnums.en_childs_effctv_before_parent,
                         V_PROC_NAME,
                         'child data becomes effective before parent data, with this update');
    WHEN lead_bnk_typ_not_chg_err THEN
        ERRPKG.RAISE_ERR(errnums.en_lead_bnk_typ_not_chg_err,
                         V_PROC_NAME,
                         'Bank type and effective date has to be changed correspondingly');
    WHEN book_keeper_null_err THEN
        ERRPKG.RAISE_ERR(errnums.en_book_keeper_null_err,
                         V_PROC_NAME,
                         'Bank Account can not be created with out a book keeper number');
    WHEN lead_ever_mbr_from_effctv_dt THEN
        ERRPKG.RAISE_ERR(errnums.en_lead_ever_mbr_frm_efctv_dt,
                         V_PROC_NAME,
                         'Lead entered is a member currently or in future. Please verify the concentration once');
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME || ' ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END ACCOUNT_MAINTENANCE_BR_SP;

FUNCTION IS_MEMBER_ADDED_TWICE(
/*******************************************************************************
  This procedure will check if the same member is added twice or not

created : 07/10/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_MEMBER_CC              IN     VARCHAR2,
IN_MBR_BANK_CC_TAB        IN     TABLE_IU_PKG.MEMBER_BANK_CC_TAB_TYPE,
IN_MBR_BANK_CC_FUTURE_TAB IN     TABLE_IU_PKG.MEMBER_BANK_CC_FUTURE_TAB_TYPE) RETURN VARCHAR2
IS
    V_INDEX         NUMBER := 0;
    V_MEMBER_COUNT  NUMBER := 0;
    V_RETURN_VAL    VARCHAR2(1) := 'N';
BEGIN
    IF IN_MBR_BANK_CC_TAB.COUNT > 0 THEN
        V_INDEX := IN_MBR_BANK_CC_TAB.FIRST;
        WHILE V_INDEX IS NOT NULL LOOP
            IF IN_MBR_BANK_CC_TAB(V_INDEX).MEMBER_STORE_NBR = IN_MEMBER_CC THEN
                V_MEMBER_COUNT := V_MEMBER_COUNT + 1;
            END IF;
            IF V_MEMBER_COUNT > 1 THEN
                V_RETURN_VAL := 'Y';
                EXIT;
            END IF;
            V_INDEX := IN_MBR_BANK_CC_TAB.NEXT(V_INDEX);
        END LOOP;  
    END IF;
    IF IN_MBR_BANK_CC_FUTURE_TAB.COUNT > 0 THEN
        V_INDEX := IN_MBR_BANK_CC_FUTURE_TAB.FIRST;
        WHILE V_INDEX IS NOT NULL LOOP
            IF IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).MEMBER_STORE_NBR = IN_MEMBER_CC THEN
                V_MEMBER_COUNT := V_MEMBER_COUNT + 1;
            END IF;
            IF V_MEMBER_COUNT > 1 THEN
                V_RETURN_VAL := 'Y';
                EXIT;
            END IF;
            V_INDEX := IN_MBR_BANK_CC_FUTURE_TAB.NEXT(V_INDEX);
        END LOOP;  
    END IF;
    RETURN V_RETURN_VAL;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VAL;
END IS_MEMBER_ADDED_TWICE;

FUNCTION IS_MBR_ACTV_FOR_EFFCTV_DT(
/*******************************************************************************
  This function will return "Y" if the passed member is active for a lead
  that is different from the passed lead as of the effective dates

Created : 07/10/2015 jxc517 CCN Project....
Changed : 
*******************************************************************************/
IN_LEAD_BANK_ACCOUNT_NBR IN     VARCHAR2,
IN_LEAD_STORE_NBR        IN     VARCHAR2,
IN_MBR_STORE_NBR         IN     VARCHAR2,
IN_EFFECTIVE_DATE        IN     DATE) RETURN VARCHAR2
IS
    V_RETURN_VALUE VARCHAR2(1) := 'N';
BEGIN
    SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
      INTO V_RETURN_VALUE
      FROM (SELECT 1
              FROM MEMBER_BANK_CC
             WHERE (LEAD_BANK_ACCOUNT_NBR <> NVL(IN_LEAD_BANK_ACCOUNT_NBR, 'X')
                     OR
                     LEAD_STORE_NBR <> NVL(IN_LEAD_STORE_NBR, 'X'))
               AND MEMBER_STORE_NBR = IN_MBR_STORE_NBR
               AND IN_EFFECTIVE_DATE BETWEEN EFFECTIVE_DATE AND NVL(EXPIRATION_DATE, IN_EFFECTIVE_DATE)
             UNION
            SELECT 1
              FROM MEMBER_BANK_CC_FUTURE
             WHERE (LEAD_BANK_ACCOUNT_NBR <> NVL(IN_LEAD_BANK_ACCOUNT_NBR, 'X')
                     OR
                     LEAD_STORE_NBR <> NVL(IN_LEAD_STORE_NBR, 'X'))
               AND MEMBER_STORE_NBR = IN_MBR_STORE_NBR
               AND IN_EFFECTIVE_DATE BETWEEN EFFECTIVE_DATE AND NVL(EXPIRATION_DATE, IN_EFFECTIVE_DATE)
           );
    RETURN V_RETURN_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN_VALUE;
END IS_MBR_ACTV_FOR_EFFCTV_DT;

PROCEDURE MEMBER_MAINTENANCE_BR_SP(
/******************************************************************************
    This procedure validates the business rules for Member Maintenance Window

Created : 07/10/2015 nxk927/jxc517 CCN Project....
Changed : 12/14/2016 jxc517 CCN Project....
          Cleaning up the business rules
*******************************************************************************/
    IN_MBR_BANK_CC_TAB                IN TABLE_IU_PKG.MEMBER_BANK_CC_TAB_TYPE,
    IN_MBR_BANK_CC_FUTURE_TAB         IN TABLE_IU_PKG.MEMBER_BANK_CC_FUTURE_TAB_TYPE)
IS
    V_INDEX                     NUMBER := 0;
    V_MEMBER_STORE_NBR          MEMBER_BANK_CC.MEMBER_STORE_NBR%TYPE;
    V_MBR_BANK_CC_FUTURE_TAB    TABLE_IU_PKG.MEMBER_BANK_CC_FUTURE_TAB_TYPE;
    V_MBR_BANK_CC_TAB           TABLE_IU_PKG.MEMBER_BANK_CC_TAB_TYPE;
    V_LEAD_BANK_CC_FUTURE_REC   LEAD_BANK_CC_FUTURE%ROWTYPE;
    V_LEAD_BANK_CC_REC          LEAD_BANK_CC%ROWTYPE;
    V_PROC_NAME                 VARCHAR2(30) := 'MEMBER_MAINTENANCE_BR_SP';
    member_added_twice          EXCEPTION;
    lead_assigned_as_mem        EXCEPTION;
    mbr_exists_for_effctv_dt    EXCEPTION;
BEGIN
    IF IN_MBR_BANK_CC_TAB.COUNT > 0 THEN
    --********************************************************************************
    --MEMBER_BANK_CC Validations
    --********************************************************************************
        V_INDEX := IN_MBR_BANK_CC_TAB.FIRST;
        WHILE V_INDEX IS NOT NULL LOOP
            V_MEMBER_STORE_NBR := IN_MBR_BANK_CC_TAB(V_INDEX).MEMBER_STORE_NBR;
            VALIDATE_DATE_RULES(IN_MBR_BANK_CC_TAB(V_INDEX).EFFECTIVE_DATE,
                                IN_MBR_BANK_CC_TAB(V_INDEX).EXPIRATION_DATE,
                                NULL,
                                V_PROC_NAME,
                                'Member "'|| V_MEMBER_STORE_NBR ||'"');
            IF V_LEAD_BANK_CC_REC.LEAD_BANK_ACCOUNT_NBR IS NULL THEN
                V_LEAD_BANK_CC_REC := BANKING_COMMON_TOOLS.GET_LEAD_BANK_CC_REC(IN_MBR_BANK_CC_TAB(V_INDEX).LEAD_STORE_NBR);
                IF V_LEAD_BANK_CC_REC.BANK_TYPE_CODE <> 'L' THEN
                    ERRPKG.RAISE_ERR(errnums.en_cc_not_lead_ever,
                                     V_PROC_NAME,
                                     'Cost Center entered is not a Lead');
                END IF;
            END IF;
            VALIDATE_PARENT_CHILD_DATES(V_LEAD_BANK_CC_REC.EFFECTIVE_DATE,
                                        V_LEAD_BANK_CC_REC.EXPIRATION_DATE,
                                        IN_MBR_BANK_CC_TAB(V_INDEX).EFFECTIVE_DATE,
                                        IN_MBR_BANK_CC_TAB(V_INDEX).EXPIRATION_DATE,
                                        V_PROC_NAME,
                                        'Member Bank CC "'|| V_MEMBER_STORE_NBR ||'" dates can not be outside Lead Bank CC dates');
            VALIDATE_CURRENT_EFFCTV_DT('MEMBER_BANK_CC',
                                       NULL, --Bank Account Number
                                       IN_MBR_BANK_CC_TAB(V_INDEX).LEAD_STORE_NBR,
                                       IN_MBR_BANK_CC_TAB(V_INDEX).EFFECTIVE_DATE,
                                       V_PROC_NAME,
                                       'Member "'|| V_MEMBER_STORE_NBR ||'"');
            --can't enter same member more than once
            IF IS_MEMBER_ADDED_TWICE(IN_MBR_BANK_CC_TAB(V_INDEX).MEMBER_STORE_NBR,
                                     IN_MBR_BANK_CC_TAB,
                                     V_MBR_BANK_CC_FUTURE_TAB) = 'Y' THEN --never touch NULL V_MBR_BANK_CC_FUTURE_TAB here
                RAISE member_added_twice;
            END IF;
            --can't enter a member who is currently a lead any where
            IF IS_LEAD_ACTV_FOR_EFFCTV_DT(IN_MBR_BANK_CC_TAB(V_INDEX).MEMBER_STORE_NBR,
                                          NULL,
                                          IN_MBR_BANK_CC_TAB(V_INDEX).EFFECTIVE_DATE) = 'Y' THEN
                RAISE lead_assigned_as_mem;
            END IF;
            --can't enter a member who is a member for some other lead as of that date
            IF IS_MBR_ACTV_FOR_EFFCTV_DT(IN_MBR_BANK_CC_TAB(V_INDEX).LEAD_BANK_ACCOUNT_NBR,
                                         IN_MBR_BANK_CC_TAB(V_INDEX).LEAD_STORE_NBR,
                                         IN_MBR_BANK_CC_TAB(V_INDEX).MEMBER_STORE_NBR,
                                         IN_MBR_BANK_CC_TAB(V_INDEX).EFFECTIVE_DATE) = 'Y' THEN
                RAISE mbr_exists_for_effctv_dt;
            END IF;
            V_INDEX := IN_MBR_BANK_CC_TAB.NEXT(V_INDEX);
        END LOOP;  
    ELSIF IN_MBR_BANK_CC_FUTURE_TAB.COUNT > 0 THEN
    --********************************************************************************
    --MEMBER_BANK_CC_FUTURE Validations
    --********************************************************************************
        V_INDEX := IN_MBR_BANK_CC_FUTURE_TAB.FIRST;
        WHILE V_INDEX IS NOT NULL LOOP
            V_MEMBER_STORE_NBR := IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).MEMBER_STORE_NBR;
            VALIDATE_DATE_RULES(IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).EFFECTIVE_DATE,
                                IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).EXPIRATION_DATE,
                                IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).FUTURE_ID,
                                V_PROC_NAME,
                                'Member "'|| V_MEMBER_STORE_NBR ||'"');
            IF V_LEAD_BANK_CC_FUTURE_REC.LEAD_BANK_ACCOUNT_NBR IS NULL THEN
                V_LEAD_BANK_CC_FUTURE_REC := BANKING_COMMON_TOOLS.GET_LEAD_BANK_CC_FUTURE_REC(
                                                IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).LEAD_BANK_ACCOUNT_NBR,
                                                IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).LEAD_STORE_NBR,
                                                IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).FUTURE_ID);
                IF V_LEAD_BANK_CC_FUTURE_REC.BANK_TYPE_CODE <> 'L' THEN
                    ERRPKG.RAISE_ERR(errnums.en_cc_not_lead_ever,
                                     V_PROC_NAME,
                                     'Cost Center entered is not a Lead');
                END IF;
            END IF;
            VALIDATE_PARENT_CHILD_DATES(V_LEAD_BANK_CC_FUTURE_REC.EFFECTIVE_DATE,
                                        V_LEAD_BANK_CC_FUTURE_REC.EXPIRATION_DATE,
                                        IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).EFFECTIVE_DATE,
                                        IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).EXPIRATION_DATE,
                                        V_PROC_NAME,
                                        'Member Bank CC  "'|| V_MEMBER_STORE_NBR ||'" dates can not be outside Lead Bank CC dates');
            --can't enter same member more than once
            IF IS_MEMBER_ADDED_TWICE(IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).MEMBER_STORE_NBR,
                                     V_MBR_BANK_CC_TAB, --never touch NULL V_MBR_BANK_CC_TAB here
                                     IN_MBR_BANK_CC_FUTURE_TAB) = 'Y' THEN
                RAISE member_added_twice;
            END IF;
            --can't enter a member who is currently a lead any where
            IF IS_LEAD_ACTV_FOR_EFFCTV_DT(IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).MEMBER_STORE_NBR,
                                          NULL,
                                          IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).EFFECTIVE_DATE) = 'Y' THEN
                RAISE lead_assigned_as_mem;
            END IF;
            --can't enter a member who is a member for some other lead as of that date
            IF IS_MBR_ACTV_FOR_EFFCTV_DT(IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).LEAD_BANK_ACCOUNT_NBR,
                                         IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).LEAD_STORE_NBR,
                                         IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).MEMBER_STORE_NBR,
                                         IN_MBR_BANK_CC_FUTURE_TAB(V_INDEX).EFFECTIVE_DATE) = 'Y' THEN
                RAISE mbr_exists_for_effctv_dt;
            END IF;
            V_INDEX := IN_MBR_BANK_CC_FUTURE_TAB.NEXT(V_INDEX);
        END LOOP;
    END IF;
EXCEPTION
    WHEN member_added_twice THEN
        ERRPKG.RAISE_ERR(errnums.en_member_added_twice,
                         V_PROC_NAME,
                         'Member "'|| V_MEMBER_STORE_NBR ||'" already exists in this Lead - member sent twice');
    WHEN lead_assigned_as_mem THEN
        ERRPKG.RAISE_ERR(errnums.en_lead_assigned_as_mem,
                         V_PROC_NAME,
                         'Lead "'|| V_MEMBER_STORE_NBR ||'" cannot be assigned as member under another lead');
    WHEN mbr_exists_for_effctv_dt THEN
        ERRPKG.RAISE_ERR(errnums.en_mbr_exists_for_effctv_dt,
                         V_PROC_NAME,
                         'Member "'|| V_MEMBER_STORE_NBR ||'" is already active for another Lead as of the effective date');
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME || ' ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' ); 
END MEMBER_MAINTENANCE_BR_SP;

PROCEDURE LEAD_TRANSFER_BR_SP(
/******************************************************************************
    This procedure validates the business rules for Lead Transfer process of Concentration Window 

Created : 07/28/2015 jxc517 CCN Project....
Changed : 09/16/2015 axk326 CCN Project....
          Added BR to check if there is any NULL Effective Date while doing the transfer process 
          09/28/2015 sxh487 Added a warning that if an expired member with future 
          is transferred again all the futures will be deleted
Changed : 11/10/2015 jxc517 CCN Project....
          Added business rule to throw error if user tries to perform transfer with multiple dates
Changed : 11/10/2015 nxk927 CCN Project....
          Added business rule to throw error if user tries to enter the date for the member transfer where
          the TO_COST_CENTER is not lead in the date passed
*******************************************************************************/
IN_XML           CLOB)
IS
    V_PROC_NAME                 VARCHAR2(30) := 'LEAD_TRANSFER_BR_SP';
    V_XML_MEMBER_BANK_STR_FRAG  CLOB;
    V_ROW_DATA                  XMLTYPE := SYS.XMLTYPE(IN_XML);
    V_FROM_LEAD_CC              VARCHAR2(6); 
    V_TO_LEAD_CC                VARCHAR2(6);
    V_FROM_LEAD_BANK_CC_REC     LEAD_BANK_CC%ROWTYPE;
    V_TO_LEAD_BANK_CC_REC       LEAD_BANK_CC%ROWTYPE;
    V_COUNT                     NUMBER := 0;
    V_TO_EFFECTIVE_DATE         LEAD_BANK_CC.EFFECTIVE_DATE%TYPE; 
BEGIN
    IF (V_ROW_DATA.EXISTSNODE('/MEMBER_TRANSFER_UI/FROM_LEAD_CC/text()') = 1) THEN
        V_FROM_LEAD_CC := V_ROW_DATA.EXTRACT('/MEMBER_TRANSFER_UI/FROM_LEAD_CC/text()').GETSTRINGVAL();  
    END IF;
    IF (V_ROW_DATA.EXISTSNODE('/MEMBER_TRANSFER_UI/TO_LEAD_CC/text()') = 1) THEN
        V_TO_LEAD_CC := V_ROW_DATA.EXTRACT('/MEMBER_TRANSFER_UI/TO_LEAD_CC/text()').GETSTRINGVAL();  
    END IF;
    IF V_TO_LEAD_CC IS NULL THEN
        ERRPKG.RAISE_ERR(errnums.en_to_lead_not_provided_err,
                         V_PROC_NAME,
                         'To Lead is not specified. Please enter a lead to which these member stores needs to be transfered');
    END IF;

    IF V_FROM_LEAD_CC = V_TO_LEAD_CC THEN
        ERRPKG.RAISE_ERR(errnums.en_from_to_leads_are_same_err,
                         V_PROC_NAME,
                         'Transfer to the same lead is not possible');
    END IF;

    V_COUNT := 0;
    --first get the first 10 characters of the EFFECTIVE_DATE from xml and ocnvert it to date
    --now get the distinct count of the dates
    SELECT COUNT(DISTINCT TO_DATE(SUBSTR(EFFECTIVE_DATE, 1, 10), 'MM-DD-RRRR'))
      INTO V_COUNT
      FROM XMLTABLE ('/MEMBER_TRANSFER_UI/MEMBER_STORES/MEMBER'
                     PASSING V_ROW_DATA
                     COLUMNS EFFECTIVE_DATE VARCHAR2(24) PATH 'EFFECTIVE_DATE/text()');
    --if the count is > 1, transfer is going to be performed with multiple dates => so throw erorr
    IF V_COUNT <> 1 THEN
        ERRPKG.RAISE_ERR(errnums.en_trnsfr_with_multiple_dts,
                         V_PROC_NAME,
                         'Transfer with multiple dates is not valid, please select only one date for all the members being transferred');
    END IF;

    V_COUNT := 0;
    V_FROM_LEAD_BANK_CC_REC := BANKING_COMMON_TOOLS.GET_LEAD_BANK_CC_REC(V_FROM_LEAD_CC);
    SELECT COUNT(*)
      INTO V_COUNT
      FROM MEMBER_BANK_CC
     WHERE LEAD_BANK_ACCOUNT_NBR = V_FROM_LEAD_BANK_CC_REC.LEAD_BANK_ACCOUNT_NBR
       AND LEAD_STORE_NBR        = V_FROM_LEAD_BANK_CC_REC.LEAD_STORE_NBR
       AND MEMBER_STORE_NBR IN (SELECT *
                                  FROM XMLTABLE ('/MEMBER_TRANSFER_UI/MEMBER_STORES/MEMBER'
                                                   PASSING V_ROW_DATA
                                                   COLUMNS Value VARCHAR2(6) PATH 'MEMBER_STORE_NBR/text()'));
    IF V_COUNT = 0 THEN
        ERRPKG.RAISE_ERR(errnums.en_member_not_selected_err,
                         V_PROC_NAME,
                         'Please select at least one member to transfer');
    END IF;

    SELECT COUNT(*)
      INTO V_COUNT
      FROM XMLTABLE ('/MEMBER_TRANSFER_UI/MEMBER_STORES/MEMBER'
                     PASSING V_ROW_DATA
                     COLUMNS MEMBER_STORE_NBR VARCHAR2(6) PATH 'MEMBER_STORE_NBR/text()',
                             EFFECTIVE_DATE VARCHAR2(24) PATH 'EFFECTIVE_DATE/text()')
     WHERE EFFECTIVE_DATE IS NULL;

    IF V_COUNT > 0 THEN
        ERRPKG.RAISE_ERR(errnums.en_to_effect_date_err,
                         V_PROC_NAME,
                         'To effective date is not specified. Please enter an effective date for the member stores to be transfered');
    END IF;

    FOR REC IN (SELECT DISTINCT TO_DATE(SUBSTR(EFFECTIVE_DATE, 1, 10), 'MM-DD-RRRR') EFFECTIVE_DATE
                  FROM XMLTABLE ('/MEMBER_TRANSFER_UI/MEMBER_STORES/MEMBER'
                                   PASSING V_ROW_DATA
                                   COLUMNS EFFECTIVE_DATE VARCHAR2(24) PATH 'EFFECTIVE_DATE/text()')) LOOP
       --This rule will be kicked if :-
       -- scenario 1 -->
          -- if the TO_LEAD is currently an independent, but lead in future we should throw error if the transfer was performed
          -- with the effective date less than that of the lead's effective date in future
       --  scenario 2 -->
          --) If the TO_LEAD is currently assigned to bank account "A" and in future assigned to bank account "B"
        --this business rule will fire if trying to transfer before the future effective date of lead  attached to bank account B
        --lead with bank account "A" will be expired so we will be performing the transfer with the lead having B's record

      --This rule won't be kicked if :-
       -- scenario 1 -->
          --If the TO_LEAD has a virtual future (same bank account in future as lead with no expiration date), this won't be fired
          --unless the effective date is less than that of to_lead

        --The reason for above hard error is because of real future scenario
        IF BANKING_COMMON_TOOLS.IS_LEAD_ON_DATE_PASSED(V_TO_LEAD_CC, rec.EFFECTIVE_DATE) = 'N' THEN
            ERRPKG.RAISE_ERR(errnums.en_mem_to_ld_effect_dt_err,
                             V_PROC_NAME,
                             'The passed effective date is less than the lead effective date. Please enter correct effective date for the member stores to be transfered');
        END IF;
    END LOOP;

    FOR rec IN (SELECT *
                  FROM MEMBER_BANK_CC
                 WHERE LEAD_BANK_ACCOUNT_NBR = V_FROM_LEAD_BANK_CC_REC.LEAD_BANK_ACCOUNT_NBR
                   AND LEAD_STORE_NBR        = V_FROM_LEAD_BANK_CC_REC.LEAD_STORE_NBR
                   AND MEMBER_STORE_NBR IN (SELECT *
                                              FROM XMLTABLE ('/MEMBER_TRANSFER_UI/MEMBER_STORES/MEMBER'
                                                   PASSING V_ROW_DATA
                                                   COLUMNS Value VARCHAR2(6) PATH 'MEMBER_STORE_NBR/text()'))
                  AND EXPIRATION_DATE IS NOT NULL) LOOP
        ERRPKG.STORE_WARNINGS(errnums.en_future_del_wrn,
                              'This Transfer will delete all futures for Member store - '||rec.MEMBER_STORE_NBR);
    END LOOP;

   --Below call will check if there are any warnings and raise those from here
   ERRPKG.RAISE_WARNINGS();
EXCEPTION
  WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME || ' ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END LEAD_TRANSFER_BR_SP;

PROCEDURE MAKE_LEAD_BR_SP(
/******************************************************************************
    This procedure validates the business rules for Make Lead process of Concentration Window 

Created : 07/31/2015 nxk927/jxc517 CCN Project....
Changed : 09/28/2015 sxh487 Added a warning that if an expired member with future 
          is transferred again all the futures will be deleted 
*******************************************************************************/
IN_FROM_LEAD_CC   IN     VARCHAR2,
IN_EFFECTIVE_DATE IN     DATE)
IS
    V_PROC_NAME               VARCHAR2(30) := 'MAKE_LEAD_BR_SP';
BEGIN
    VALIDATE_DATE_RULES(IN_EFFECTIVE_DATE,
                        NULL,
                        NULL,
/*
                        1, --Hard Coded => to make sure that future effective date validation fires
                        --[future effective date can not be less than or equal to sysdate]
*/
                        V_PROC_NAME,
                        'To Lead');
    FOR rec IN (SELECT *
                  FROM MEMBER_BANK_CC
                 WHERE LEAD_STORE_NBR        = IN_FROM_LEAD_CC
                   AND EXPIRATION_DATE IS NOT NULL) LOOP
                    ERRPKG.STORE_WARNINGS(errnums.en_future_del_wrn,
                                         'This Process will delete all the Futures for Member store - '||rec.MEMBER_STORE_NBR);
    END LOOP;
    
    --Below call will check if there are any warnings and raise those from here
    ERRPKG.RAISE_WARNINGS();
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME || ' ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END MAKE_LEAD_BR_SP;

PROCEDURE DEPOSIT_TICKET_MNTNC_BR_SP(
/******************************************************************************
    This procedure validates the business rules for Deposit Ticket Window

Created : 07/15/2015 jxc517 CCN Project Team....
Changed : 
*******************************************************************************/
    IN_BANK_DEP_TICK_REC        IN BANK_DEP_TICK%ROWTYPE,
    IN_BANK_DEP_TICK_FUTURE_REC IN BANK_DEP_TICK_FUTURE%ROWTYPE)
IS
    V_PROC_NAME            VARCHAR2(30) := 'DEPOSIT_TICKET_MNTNC_BR_SP';
    V_BANK_MICR_FORMAT_REC BANK_MICR_FORMAT%ROWTYPE;
BEGIN
    IF IN_BANK_DEP_TICK_REC.COST_CENTER_CODE IS NOT NULL THEN
        --********************************************************************************
        --BANK_DEP_TICK Validations
        --********************************************************************************
        VALIDATE_DATE_RULES(IN_BANK_DEP_TICK_REC.EFFECTIVE_DATE,
                            IN_BANK_DEP_TICK_REC.EXPIRATION_DATE,
                            NULL,
                            V_PROC_NAME,
                            'Deposit Ticket');
        VALIDATE_CURRENT_EFFCTV_DT('BANK_DEP_TICK',
                                   IN_BANK_DEP_TICK_REC.BANK_ACCOUNT_NBR,
                                   IN_BANK_DEP_TICK_REC.COST_CENTER_CODE,
                                   IN_BANK_DEP_TICK_REC.EFFECTIVE_DATE,
                                   V_PROC_NAME,
                                   'Deposit Ticket');
    ELSIF IN_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE IS NOT NULL THEN
        --********************************************************************************
        --BANK_DEP_TICK_FUTURE Validations
        --********************************************************************************
        VALIDATE_DATE_RULES(IN_BANK_DEP_TICK_FUTURE_REC.EFFECTIVE_DATE,
                            IN_BANK_DEP_TICK_FUTURE_REC.EXPIRATION_DATE,
                            IN_BANK_DEP_TICK_FUTURE_REC.FUTURE_ID,
                            V_PROC_NAME,
                            'Deposit Ticket');
        VALIDATE_CURRENT_EFFCTV_DT('BANK_DEP_TICK',
                                   IN_BANK_DEP_TICK_FUTURE_REC.BANK_ACCOUNT_NBR,
                                   IN_BANK_DEP_TICK_FUTURE_REC.COST_CENTER_CODE,
                                   IN_BANK_DEP_TICK_FUTURE_REC.EFFECTIVE_DATE,
                                   V_PROC_NAME,
                                   'Deposit Ticket');
    END IF;
END DEPOSIT_TICKET_MNTNC_BR_SP;

PROCEDURE DEPOSIT_BAG_TICKET_MNTNC_BR_SP(
/******************************************************************************
    This procedure validates the business rules for Deposit Bag TIcket Window

Created : 07/15/2015 axk326 CCN Project Team....
Changed : 10/20/2015 jxc517 CCN Project Team....
          Code has been changed to deal with Deposit Bag futures
Changed : 11/06/2015 jxc517 CCN Project Team....
          Code has been corrected to pass value instead of NULL bank account number
          as we do not get the Bank Account Number from UI for a new record for the Cost Center passed
*******************************************************************************/
    IN_BANK_DEP_BAG_TICK_REC     IN BANK_DEP_BAG_TICK%ROWTYPE,
    IN_BANK_DEP_BAG_TICK_FTR_REC IN BANK_DEP_BAG_TICK_FUTURE%ROWTYPE)
IS
    V_PROC_NAME    VARCHAR2(30) := 'DEPOSIT_BAG_TICKET_MNTNC_BR_SP';
BEGIN
    IF IN_BANK_DEP_BAG_TICK_REC.COST_CENTER_CODE IS NOT NULL THEN
        --********************************************************************************
        --BANK_DEP_BAG_TICK Validations
        --********************************************************************************
        VALIDATE_DATE_RULES(IN_BANK_DEP_BAG_TICK_REC.EFFECTIVE_DATE,
                            IN_BANK_DEP_BAG_TICK_REC.EXPIRATION_DATE,
                            NULL,
                            V_PROC_NAME,
                            'Deposit Bag Ticket');
        VALIDATE_CURRENT_EFFCTV_DT('BANK_DEP_BAG_TICK',
                                   IN_BANK_DEP_BAG_TICK_REC.BANK_ACCOUNT_NBR,
                                   IN_BANK_DEP_BAG_TICK_REC.COST_CENTER_CODE,
                                   IN_BANK_DEP_BAG_TICK_REC.EFFECTIVE_DATE,
                                   V_PROC_NAME,
                                   'Deposit Bag Ticket');
    ELSIF IN_BANK_DEP_BAG_TICK_FTR_REC.COST_CENTER_CODE IS NOT NULL THEN
        --********************************************************************************
        --BANK_DEP_BAG_TICK_FUTURE Validations
        --********************************************************************************
        VALIDATE_DATE_RULES(IN_BANK_DEP_BAG_TICK_FTR_REC.EFFECTIVE_DATE,
                            IN_BANK_DEP_BAG_TICK_FTR_REC.EXPIRATION_DATE,
                            IN_BANK_DEP_BAG_TICK_FTR_REC.FUTURE_ID,
                            V_PROC_NAME,
                            'Deposit Bag Ticket');
        VALIDATE_CURRENT_EFFCTV_DT('BANK_DEP_BAG_TICK',
                                   IN_BANK_DEP_BAG_TICK_FTR_REC.BANK_ACCOUNT_NBR,
                                   IN_BANK_DEP_BAG_TICK_FTR_REC.COST_CENTER_CODE,
                                   IN_BANK_DEP_BAG_TICK_FTR_REC.EFFECTIVE_DATE,
                                   V_PROC_NAME,
                                   'Deposit Bag Ticket');
    END IF;
END DEPOSIT_BAG_TICKET_MNTNC_BR_SP;

FUNCTION IS_DPT_TKT_BAG_REORDR_SWTCH_OK(
/******************************************************************************
   This function returns Y or N if the deposit bag ticket value is "L" or not
   
Created : 11/16/2016 jxc517 CCN Project Team....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE IN       VARCHAR2,
IN_FUTURE_ID        IN       NUMBER) RETURN VARCHAR2
IS
  V_RETURN VARCHAR2(1) := 'Y';
BEGIN
   IF IN_FUTURE_ID IS NOT NULL THEN
       SELECT CASE WHEN COUNT(*) > 0 THEN 'N' ELSE 'Y' END
         INTO V_RETURN
         FROM BANK_DEP_BAG_TICK_FUTURE
        WHERE UPPER(COST_CENTER_CODE)    = UPPER(IN_COST_CENTER_CODE)
          AND FUTURE_ID                  = IN_FUTURE_ID
          AND DEP_BAG_REORDER_SWITCH     = 'L';
   ELSE
       SELECT CASE WHEN COUNT(*) > 0 THEN 'N' ELSE 'Y' END
         INTO V_RETURN
         FROM BANK_DEP_BAG_TICK
        WHERE UPPER(COST_CENTER_CODE)    = UPPER(IN_COST_CENTER_CODE)
          AND DEP_BAG_REORDER_SWITCH     = 'L';
   END IF;
   RETURN V_RETURN;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN;
END IS_DPT_TKT_BAG_REORDR_SWTCH_OK;

FUNCTION IS_DPT_TKT_REORDR_SWTCH_OK(
/******************************************************************************
   This function returns Y or N if the deposit ticket value is "L" or not
   
Created : 11/16/2016 jxc517 CCN Project Team....
Changed : 
*******************************************************************************/
IN_COST_CENTER_CODE IN       VARCHAR2,
IN_FUTURE_ID        IN       NUMBER) RETURN VARCHAR2
IS
  V_RETURN VARCHAR2(1) := 'Y';
BEGIN
   IF IN_FUTURE_ID IS NOT NULL THEN
       SELECT CASE WHEN COUNT(*) > 0 THEN 'N' ELSE 'Y' END
         INTO V_RETURN
         FROM BANK_DEP_TICK_FUTURE
        WHERE UPPER(COST_CENTER_CODE)    = UPPER(IN_COST_CENTER_CODE)
          AND FUTURE_ID                  = IN_FUTURE_ID
          AND REORDER_SWITCH             = 'L';
   ELSE
       SELECT CASE WHEN COUNT(*) > 0 THEN 'N' ELSE 'Y' END
         INTO V_RETURN
         FROM BANK_DEP_TICK
        WHERE UPPER(COST_CENTER_CODE)    = UPPER(IN_COST_CENTER_CODE)
          AND REORDER_SWITCH             = 'L';
   END IF;
  
   RETURN V_RETURN;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_RETURN;
END IS_DPT_TKT_REORDR_SWTCH_OK;

PROCEDURE PLACE_TCKT_ORDER_BR_SP(
/******************************************************************************
    This procedure validates the business rules for placing order from Deposit Bag TIcket Window
    Below procedure will check to see
    1) if there are store micr details attached to the cost center,
    2) if there are any order placed for the future ticket with the
       order date lesser than the effective date of the future record,
    2) if there are any order placed for the current ticket with the
       order date greater than the effective date used for the future ticket

Created : 11/19/2015 nxk927 CCN Project Team....
Changed : 11/24/2015 nxk927 CCN Project Team....
          calling the function to get the store micr details
        : 09/27/2016 nxk927 CCN Project Team....
          added the business rule to check if the cost center is closed or is a dummy cost center
        : 12/13/2016 nxk927 CCN Project Team....
          Effective date validation for the orders not needed anymore.
          Signature changed to removed order date as it is not needed anymore
*******************************************************************************/
   IN_COST_CENTER        IN VARCHAR2,
   IN_FUTURE_ID          IN NUMBER)
IS
   V_PROC_NAME           VARCHAR2(30) := 'PLACE_TCKT_ORDER_BR_SP';
   V_COUNT               NUMBER := 0;
   V_REC                 BANK_DEP_TICK_FUTURE%ROWTYPE;
   V_ST_MICR_DTLS_REC    STORE_MICR_FORMAT_DTLS%ROWTYPE;
   V_ST_MCR_DTLS_F_REC   STORE_MICR_FORMAT_DTLS_FUTURE%ROWTYPE;

BEGIN
    IF BUSINESS_RULES_PKG.IS_PLACING_DPT_TKT_BAG_ORD_OK(IN_COST_CENTER) = 'N' THEN
       --this check is to make sure the cost center is not closed, or is a dummy cost center
       ERRPKG.RAISE_ERR(errnums.en_cc_open_close_dt_err,
                        V_PROC_NAME,
                        'The cost center is either closed or a dummy cost center.');
    END IF;
    IF IS_DPT_TKT_REORDR_SWTCH_OK(IN_COST_CENTER, IN_FUTURE_ID) = 'N' THEN
       --this check is to make sure the ticket order is not placed for reorder switch as "L"
       ERRPKG.RAISE_ERR(errnums.en_dep_tick_reordr_swtc_err,
                        V_PROC_NAME,
                        'Deposit ticket can not be ordered on reorder switch of L');
    END IF;
    BEGIN
       SELECT *
         INTO V_REC
         FROM BANK_DEP_TICK_FUTURE
        WHERE COST_CENTER_CODE  = IN_COST_CENTER
          AND TRUNC(EFFECTIVE_DATE) > TRUNC(SYSDATE);
    EXCEPTION
            WHEN NO_DATA_FOUND THEN
               NULL;
    END;
    IF IN_FUTURE_ID IS NULL THEN
       V_ST_MICR_DTLS_REC:= BANKING_COMMON_TOOLS.GET_STORE_MICR_FORMAT_DTLS_REC(IN_COST_CENTER);
       IF V_ST_MICR_DTLS_REC.COST_CENTER_CODE IS NULL THEN
          ERRPKG.RAISE_ERR(errnums.en_str_micr_dtls_not_avail,
                           V_PROC_NAME,
                           'The cost center retrieved do not have any Store Micr Format Details Attached');
       END IF;

   ELSE
       V_ST_MCR_DTLS_F_REC:= BANKING_COMMON_TOOLS.GET_STR_MICR_FRMT_DTLS_FTR_REC(IN_COST_CENTER,IN_FUTURE_ID);
       IF V_ST_MCR_DTLS_F_REC.COST_CENTER_CODE IS NULL THEN
          ERRPKG.RAISE_ERR(errnums.en_str_micr_dtls_not_avail,
                           V_PROC_NAME,
                           'The cost center retrieved do not have any Store Micr Format Details Attached');
       END IF;
   END IF;
EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME || ' ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END PLACE_TCKT_ORDER_BR_SP;

PROCEDURE PLACE_BAG_ORDER_BR_SP(
/******************************************************************************
    This procedure validates the business rules for placing order from Deposit Bag TIcket Window
    Below procedure will check to see
    1) if there are any order placed for the future bag with the
       order date lesser than the effective date of the future record,
    2) if there are any order placed for the current ticket with the
       order date greater than the effective date used for the future bag

Created : 11/19/2015 nxk927 CCN Project Team....
Changed : 09/27/2016 nxk927 CCN Project Team....
          added the business rule to check if the cost center is closed or is a dummy cost center
        : 12/13/2016 nxk927 CCN Project Team....
          Effective date validation for the orders not needed anymore.
          Signature changed to removed order date as it is not needed anymore
*******************************************************************************/
   IN_COST_CENTER        IN VARCHAR2,
   IN_FUTURE_ID          IN NUMBER)
IS
   V_PROC_NAME           VARCHAR2(30) := 'PLACE_BAG_ORDER_BR_SP';
   V_REC                 BANK_DEP_BAG_TICK_FUTURE%ROWTYPE;
BEGIN
    IF BUSINESS_RULES_PKG.IS_PLACING_DPT_TKT_BAG_ORD_OK(IN_COST_CENTER) = 'N' THEN
       --this check is to make sure the cost center is not closed, or is a dummy cost center
       ERRPKG.RAISE_ERR(errnums.en_cc_open_close_dt_err,
                        V_PROC_NAME,
                        'The cost center is either closed or a dummy cost center.');
    END IF;
    IF IS_DPT_TKT_BAG_REORDR_SWTCH_OK(IN_COST_CENTER, IN_FUTURE_ID) = 'N' THEN
       --this check is to make sure the bag order is not placed for reorder switch as "L"
       ERRPKG.RAISE_ERR(errnums.en_dep_bag_reordr_swtc_err,
                        V_PROC_NAME,
                        'Deposit bag can not be ordered on reorder switch of L');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
         ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME || ' ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END PLACE_BAG_ORDER_BR_SP;

PROCEDURE ACCOUNT_MAINTEN_LEAD_SP(
/******************************************************************************
    This procedure validates the business rules for Make Lead process of Account Maintenance Window
    This procedure validate the date rules and gives the warning message

Created :  11/28/2015 dxv848 CCN Project ....
Changed :
*******************************************************************************/
IN_LEAD_CC        IN     VARCHAR2,
IN_BANKACC_CC     IN     VARCHAR2,
IN_EFFECTIVE_DATE IN     DATE)
IS
    V_PROC_NAME               VARCHAR2(30) := 'ACCOUNT_MAINTEN_LEAD_SP';
    V_RETURN_VALUE            VARCHAR2(1) := 'N';
BEGIN

    VALIDATE_DATE_RULES(IN_EFFECTIVE_DATE,
                        NULL,
                        NULL,
/*
                        1, --Hard Coded => to make sure that future effective date validation fires
                        --[future effective date can not be less than or equal to sysdate]
*/
                        V_PROC_NAME,
                        'To Lead');
    SELECT CASE WHEN COUNT(*) > 0 THEN 'Y' ELSE 'N' END
      INTO V_RETURN_VALUE
      FROM  (SELECT 1
               FROM LEAD_BANK_CC_FUTURE
              WHERE (LEAD_STORE_NBR         = IN_LEAD_CC
                 OR  LEAD_BANK_ACCOUNT_NBR  = IN_BANKACC_CC
                 OR  LEAD_STORE_NBR         = (SELECT LEAD_STORE_NBR
                                                 FROM MEMBER_BANK_CC_FUTURE
                                                WHERE MEMBER_STORE_NBR=IN_LEAD_CC))
                AND EXPIRATION_DATE IS  NULL) ;
    --directly raising the error
    IF V_RETURN_VALUE ='Y' THEN
        ERRPKG.RAISE_ERR(errnums.en_future_del_wrn_accmain,
                         V_PROC_NAME,
                         'The Store number or Bank account account number you are trying to attach has future . This process will delete all the futures');
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        ERRPKG.RAISE_ERR(SQLCODE, V_PROC_NAME || ' ' || SUBSTR(SQLERRM,1,500) || ' IN OTHERS ' );
END ACCOUNT_MAINTEN_LEAD_SP;

PROCEDURE ACCOUNT_MAINTEN_CHECK_FUTURE(
/******************************************************************************
    This procedure validates the business rules for Make Lead process of Account Maintenance Window
    This procedure get the current and future store number and bank account number and checks the business rule
Created :  01/15/2016 dxv848 CCN Project ....
Changed :
*******************************************************************************/
IN_ROW_DATA               IN  CLOB,
IN_LEAD_FLAG              IN VARCHAR2)
IS
    V_LEAD_STORE_NBR                VARCHAR2(6);
    V_ROW_DATA                      XMLTYPE := SYS.XMLTYPE(IN_ROW_DATA);
    V_LD_EFFECTIVE_DATE             LEAD_BANK_CC.EFFECTIVE_DATE%TYPE;
	  V_BANK_ACC_NBR                  LEAD_BANK_CC.LEAD_BANK_ACCOUNT_NBR%TYPE;
    V_BK_EFFECTIVE_DATE             BANK_ACCOUNT.EFFECTIVE_DATE%TYPE;
    V_LDF_EFFECTIVE_DATE            LEAD_BANK_CC_FUTURE.EFFECTIVE_DATE%TYPE;
    V_BKF_EFFECTIVE_DATE            BANK_ACCOUNT_FUTURE.EFFECTIVE_DATE%TYPE;
    V_EFFECTIVE_DATE                BANK_ACCOUNT.EFFECTIVE_DATE%TYPE;
BEGIN

    IF NVL(IN_LEAD_FLAG, 'N')  = 'N' THEN
        V_EFFECTIVE_DATE := TO_DATE(V_ROW_DATA.EXTRACT('/ACCOUNT_MAINTENANCE_UI/BANK_ACCOUNT/EFFECTIVE_DATE/text()').GETSTRINGVAL(), 'MM-DD-YYYY HH12:MI:SS AM');
        IF (V_ROW_DATA.EXISTSNODE('/ACCOUNT_MAINTENANCE_UI/LEAD_BANK_CC/LEAD_STORE_NBR/text()') = 1) THEN
            V_LEAD_STORE_NBR := V_ROW_DATA.EXTRACT('/ACCOUNT_MAINTENANCE_UI/LEAD_BANK_CC/LEAD_STORE_NBR/text()').GETSTRINGVAL();  -- lead store
            IF TRUNC(V_EFFECTIVE_DATE) <= TRUNC(SYSDATE) THEN
                V_LD_EFFECTIVE_DATE := TO_DATE(V_ROW_DATA.EXTRACT('/ACCOUNT_MAINTENANCE_UI/LEAD_BANK_CC/EFFECTIVE_DATE/text()').GETSTRINGVAL(), 'MM-DD-YYYY HH12:MI:SS AM');   -- current lead bank effective date
            ELSE
                V_LDF_EFFECTIVE_DATE := TO_DATE(V_ROW_DATA.EXTRACT('/ACCOUNT_MAINTENANCE_UI/LEAD_BANK_CC/EFFECTIVE_DATE/text()').GETSTRINGVAL(), 'MM-DD-YYYY HH12:MI:SS AM');   --future lead bank effective date
            END IF;
        END IF;
        IF (V_ROW_DATA.EXISTSNODE('/ACCOUNT_MAINTENANCE_UI/BANK_ACCOUNT/BANK_ACCOUNT_NBR/text()') = 1) THEN
            V_BANK_ACC_NBR := V_ROW_DATA.EXTRACT('/ACCOUNT_MAINTENANCE_UI/BANK_ACCOUNT/BANK_ACCOUNT_NBR/text()').GETSTRINGVAL();   -- bank_acc_nbr
            IF TRUNC(V_EFFECTIVE_DATE) <= TRUNC(SYSDATE) THEN
                V_BK_EFFECTIVE_DATE := V_EFFECTIVE_DATE;  --current bank effective date
            ELSE
                V_BKF_EFFECTIVE_DATE := V_EFFECTIVE_DATE;  --future bank effective date
            END IF;
        END IF;

        -- check the business rule if the lead or bank account has future
        IF (TRUNC(V_LD_EFFECTIVE_DATE) > TRUNC(SYSDATE)
            OR TRUNC(V_LDF_EFFECTIVE_DATE) >= TRUNC(V_BKF_EFFECTIVE_DATE)) THEN
            BUSINESS_RULES_PKG.ACCOUNT_MAINTEN_LEAD_SP(V_LEAD_STORE_NBR,
                                                       V_BANK_ACC_NBR,
                                                       NVL(V_LD_EFFECTIVE_DATE,V_LDF_EFFECTIVE_DATE));
        END IF;
    END IF;
END ACCOUNT_MAINTEN_CHECK_FUTURE;

FUNCTION GET_SNZ_SAM_CODE(
/******************************************************************************
   This function returns exception code defined by mainframe as CODE1(Exception code)
    for the cost center and bank account number passed
    as SNZ, SAM or null depending on the criteria below  for the UAR POS FILE generation
    1) SNZ  := item was loaded without a valid store number
    2) SAM  := item does not match account number shown on serial file
    3) NULL := no issue

Created : 02/08/2015 nxk927/dxv848 CCN Project....
Changed : 04/28/2016 nxk927 CCN Project....
          added exception block to handle if nothing is returned from STR_BNK_DPST_DLY_RCNCL_TBL
          changed the function name from VALIDATE_CC_BNK_NBR to GET_SNZ_SAM_CODE
*******************************************************************************/
IN_COST_CENTER_CODE IN VARCHAR2,
IN_BANK_ACCT_NBR    IN VARCHAR2) RETURN VARCHAR2
IS
  V_RETURN VARCHAR2(3) := NULL; --if no issues then null as code1
  V_COUNT NUMBER;
  V_BANK_ACCOUNT_NBR VARCHAR2(17);
BEGIN
  SELECT COUNT(*)
    INTO V_COUNT --checking if the cost center is valid
    FROM COST_CENTER
   WHERE SUBSTR(COST_CENTER_CODE,3) = IN_COST_CENTER_CODE;

  IF V_COUNT > 0 THEN
     BEGIN
         SELECT BANK_ACCOUNT_NBR
           INTO V_BANK_ACCOUNT_NBR
           FROM STR_BNK_DPST_DLY_RCNCL_TBL
          WHERE SUBSTR(COST_CENTER_CODE,3) = IN_COST_CENTER_CODE;
     EXCEPTION
         WHEN OTHERS THEN
            V_BANK_ACCOUNT_NBR := 'XXXX'; 
     END;
     --checking if bank account number in the file matches with the actual bank account number
     IF LPAD(REPLACE(V_BANK_ACCOUNT_NBR,'-'),17,0) <> LPAD(REPLACE(IN_BANK_ACCT_NBR,'-'),17,0) THEN
        V_RETURN := 'SAM'; --assigning 'SAM' as code1 if bank account number doesn't match'
     END IF;
  ELSE
     V_RETURN := 'SNZ';--assigning 'SNZ' as code1 if bank account number doesn't match'
  END IF;
  RETURN V_RETURN;
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END GET_SNZ_SAM_CODE;

FUNCTION IS_PLACING_DPT_TKT_BAG_ORD_OK(
/******************************************************************************
   This function returns Y or N depending on the cost center closed date and open date
   as of 01-Jan-2099
   
Created : 09/27/2016 nxk927 
Changed : 11/30/2016 nxk927
          changed the business rule to allow placing the order if the cost center is not open
          but has the status code of '2'
*******************************************************************************/
IN_COST_CENTER_CODE IN VARCHAR2) RETURN VARCHAR2
IS
  V_COST_CENTER_REC       COST_CENTER%ROWTYPE;
  V_PLACING_ORDER_OK      VARCHAR2(1) := 'Y';
BEGIN

   BEGIN
       SELECT *
         INTO V_COST_CENTER_REC
         FROM COST_CENTER
        WHERE UPPER(COST_CENTER_CODE) = UPPER(IN_COST_CENTER_CODE);
   EXCEPTION
       WHEN OTHERS THEN
           NULL;
   END;

   --checking if cost center is present or not in CCN
   IF V_COST_CENTER_REC.COST_CENTER_CODE IS NOT NULL THEN
       --checking if the cost center is closed
       IF NVL(V_COST_CENTER_REC.CLOSE_DATE, TRUNC(SYSDATE)+1) >= TRUNC(SYSDATE) THEN
           --checking if the cost center has null open date but status as '2'
           IF V_COST_CENTER_REC.OPEN_DATE IS NULL THEN
               SELECT CASE
                          WHEN COUNT(*) > 0 THEN 'Y'
                          ELSE 'N'
                      END
                 INTO V_PLACING_ORDER_OK
                 FROM STATUS
                WHERE STATUS_CODE = '2'
                  AND EXPIRATION_DATE IS NULL
                  AND COST_CENTER_CODE = V_COST_CENTER_REC.COST_CENTER_CODE;
           ELSE
               --checking if the cost center has dummy open date
               IF V_COST_CENTER_REC.OPEN_DATE = TO_DATE('01-JAN-2099','DD-MON-YYYY') THEN
                   V_PLACING_ORDER_OK := 'N';
               END IF;
           END IF;
       ELSE
           V_PLACING_ORDER_OK := 'N';
       END IF;
   ELSE
       V_PLACING_ORDER_OK := 'N';
   END IF;

   RETURN V_PLACING_ORDER_OK;
EXCEPTION
    WHEN OTHERS THEN
        RETURN V_PLACING_ORDER_OK;
END IS_PLACING_DPT_TKT_BAG_ORD_OK;

END BUSINESS_RULES_PKG;